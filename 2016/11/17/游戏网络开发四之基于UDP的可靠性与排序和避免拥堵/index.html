<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">

<script>
    (function(){
        if(''){
          // alert('此文章并不公开, 输入文章密码方可阅读');
          var password = prompt('此文章并不公开, 输入文章密码方可阅读');
          if (password !== ''){
            if (password != null) // 如果用户点击了确认而且密码错误的时候, 因为当password == null的时候说明用户点了取消
            {
              alert('Error!');
            }
            if (history.length > 1)
            {
              history.back();
            }
            else
            {
              window.location.href = "about:blank";
            }
          }
        }
    })();
</script>








<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/dist/jquery.fancybox.css?v=3.2.10" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="GafferOnGames,UDP,">








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.2">






<meta name="description" content="原文原文出处 Introduction Hi, I&amp;rsquo;m Glenn Fiedler and welcome to Networking for Game Programmers.In the previous article, we added our own concept of virtual connection on top of UDP. In this article we">
<meta name="keywords" content="GafferOnGames,UDP">
<meta property="og:type" content="article">
<meta property="og:title" content="游戏网络开发四之基于UDP的可靠性与排序和避免拥堵">
<meta property="og:url" content="https://hulinhong.com/2016/11/17/游戏网络开发四之基于UDP的可靠性与排序和避免拥堵/index.html">
<meta property="og:site_name" content="烫">
<meta property="og:description" content="原文原文出处 Introduction Hi, I&amp;rsquo;m Glenn Fiedler and welcome to Networking for Game Programmers.In the previous article, we added our own concept of virtual connection on top of UDP. In this article we">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://gameweb-img.qq.com/gad/20160617/phpYxViiW.1466148040.jpg">
<meta property="og:updated_time" content="2023-12-02T15:35:53.359Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="游戏网络开发四之基于UDP的可靠性与排序和避免拥堵">
<meta name="twitter:description" content="原文原文出处 Introduction Hi, I&amp;rsquo;m Glenn Fiedler and welcome to Networking for Game Programmers.In the previous article, we added our own concept of virtual connection on top of UDP. In this article we">
<meta name="twitter:image" content="http://gameweb-img.qq.com/gad/20160617/phpYxViiW.1466148040.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"scrollpercent":true,"onmobile":true,"dimmer":true,"body_content_height":0,"display_duration":150},
    local_search: {"enable":true,"trigger":"auto","top_n_per_article":1},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"duration":222,"transition":{"header":"slideDownIn","menu":"slideDownIn","logo":"slideDownIn","post_block_else":"slideDownIn","post_header":"fadeIn","post_body":"fadeIn","coll_header":"slideDownIn","footer":"slideDownIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>








  <title>游戏网络开发四之基于UDP的可靠性与排序和避免拥堵 | 烫</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">烫</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">烫烫烫烫烫</p>
      
  </div>

  <div class="menu-item sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <div class="menu-item site-search">
    
  
  <form class="site-search-form">
    <span class="search-icon fa fa-search"></span>
    <input type="text" id="local-search-input" class="st-search-input">
    <i id="local-search-close">×</i>
  </form>


<script type="text/javascript" id="local.search.active">
var inputArea       = document.querySelector("#local-search-input");
inputArea.onclick   = function(){ getSearchFile(); this.onclick = null }
inputArea.onkeydown = function(){ if(event.keyCode == 13) return false }
</script>



  </div>
  <div id="local-search-result-pc" class="local-search-result-cls"></div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  
  

  
    <ul id="menu" class="menu menu-left">
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

       
    </ul>
  

  
    
  
</nav>



 </div>
    </header>

    <div id="local-search-result-mobile" class="local-search-result-cls"></div>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hulinhong.com/2016/11/17/游戏网络开发四之基于UDP的可靠性与排序和避免拥堵/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="no5ix">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="烫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">游戏网络开发四之基于UDP的可靠性与排序和避免拥堵</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-11-17T22:20:34+00:00">
                2016-11-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/GS/" itemprop="url" rel="index">
                    <span itemprop="name">GS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            <div class="post-tags">
              
                <a href="/tags/GafferOnGames/" rel="tag"><i class="fa fa-tag"></i> GafferOnGames</a>
              
                <a href="/tags/UDP/" rel="tag"><i class="fa fa-tag"></i> UDP</a>
              
            </div>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    




    
    
    
    <div class="post-body" itemprop="articleBody">
      
      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/11/16/virtual_connection_over_udp/" rel="next" title="游戏网络开发三之基于UDP的虚拟连接">
                <i class="fa fa-chevron-left"></i> 
                <p class="post-nav-pre-next-title">
                  游戏网络开发三之基于UDP的虚拟连接
                </p> 
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/11/18/游戏网络开发五之每个游戏开发者都需要知道的游戏网络知识/" rel="prev" title="游戏网络开发五之每个游戏开发者都需要知道的游戏网络知识">
              <p class="post-nav-pre-next-title">
                  游戏网络开发五之每个游戏开发者都需要知道的游戏网络知识
              </p> 
              <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      

      
      

      
        <h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><p><a href="https://gafferongames.com/post/reliability_ordering_and_congestion_avoidance_over_udp//" target="_blank" rel="noopener">原文出处</a></p>
<p></p><h2 id="introduction">Introduction</h2><p></p>
<p>Hi, I&rsquo;m <a href="https://gafferongames.com/about" target="_blank" rel="noopener">Glenn Fiedler</a> and welcome to <a href="https://gafferongames.com/categories/game-networking/" target="_blank" rel="noopener"><strong>Networking for Game Programmers</strong></a>.</p><br><p>In the <a href="https://gafferongames.com/post/virtual_connection_over_udp/" target="_blank" rel="noopener">previous article</a>, we added our own concept of virtual connection on top of UDP. In this article we’re going to add reliability, ordering and congestion avoidance to our virtual UDP connection.</p><br><h2 id="the-problem-with-tcp">The Problem with TCP</h2><br><p>Those of you familiar with TCP know that it already has its own concept of connection, reliability-ordering and congestion avoidance, so why are we rewriting our own mini version of TCP on top of UDP?</p><br><p>The issue is that multiplayer action games rely on a steady stream of packets sent at rates of 10 to 30 packets per second, and for the most part, the data contained is these packets is so time sensitive that only the most recent data is useful. This includes data such as player inputs, the position, orientation and velocity of each player character, and the state of physics objects in the world.</p><br><p>The problem with TCP is that it abstracts data delivery as a reliable ordered stream. Because of this, if a packet is lost, TCP has to stop and wait for that packet to be resent. This interrupts the steady stream of packets because more recent packets must wait in a queue until the resent packet arrives, so packets are received in the same order they were sent.</p><br><p>What we need is a different type of reliability. Instead of having all data treated as a reliable ordered stream, we want to send packets at a steady rate and get notified when packets are received by the other computer. This allows time sensitive data to get through without waiting for resent packets, while letting us make our own decision about how to handle packet loss at the application level.</p><br><p>It is not possible to implement a reliability system with these properties using TCP, so we have no choice but to roll our own reliability on top of UDP.</p><br><h2 id="sequence-numbers">Sequence Numbers</h2><br><p>The goal of our reliability system is simple: we want to know which packets arrive at the other side of the connection.</p><br><p>First we need a way to identify packets.</p><br><p>What if we had added the concept of a &ldquo;packet id&rdquo;? Let&rsquo;s make it an integer value. We could start this at zero then with each packet we send, increase the number by one. The first packet we send would be packet 0, and the 100th packet sent is packet 99.</p><br><p>This is actually quite a common technique. It&rsquo;s even used in TCP! These packet ids are called sequence numbers. While we’re not going to implement reliability exactly as TCP does, it makes sense to use the same terminology, so we’ll call them sequence numbers from now on.</p><br><p>Since UDP does not guarantee the order of packets, the 100th packet received is not necessarily the 100th packet sent. It follows that we need to insert the sequence number somewhere in the packet, so that the computer at the other side of the connection knows which packet it is.</p><br><p>We already have a simple packet header for the virtual connection from the previous article, so we&rsquo;ll just add the sequence number in the header like this:</p><br><pre>   [uint protocol id]<br>   [uint sequence]<br>   <em>(packet data…)</em></pre><br><p>Now when the other computer receives a packet it knows its sequence number according to the computer that sent it.</p><br><h2 id="acks">Acks</h2><br><p>Now that we can identify packets using sequence numbers, the next step is to let the other side of the connection know which packets we receive.</p><br><p>Logically this is quite simple, we just need to take note of the sequence number of each packet we receive, and send those sequence numbers back to the computer that sent them.</p><br><p>Because we are sending packets continuously between both machines, we can just add the ack to the packet header, just like we did with the sequence number:</p><br><pre>    [uint protocol id]<br>    [uint sequence]<br>    [uint ack]<br>    <em>(packet data…)</em></pre><br><p>Our general approach is as follows:</p><br><ul><br><li><p>Each time we send a packet we increase the <em>local sequence number</em></p></li><br><li><p>When we receieve a packet, we check the sequence number of the packet against the sequence number of the most recently received packet, called the <em>remote sequence number</em>. If the packet is more recent, we update the remote sequence to be equal to the sequence number of the packet.</p></li><br><li><p>When we compose packet headers, the local sequence becomes the sequence number of the packet, and the remote sequence becomes the ack.</p></li><br></ul><br><p>This simple ack system works provided that one packet comes in for each packet we send out.</p><br><p>But what if packets clump up such that two packets arrive before we send a packet? We only have space for one ack per-packet, so what do we do?</p><br><p>Now consider the case where one side of the connection is sending packets at a faster rate. If the client sends 30 packets per-second, and the server only sends 10 packets per-second, we need <em>at least</em> 3 acks included in each packet sent from the server.</p><br><p>Let&rsquo;s make it even more complex! What if the packet containing the ack is lost? The computer that sent the packet would think the packet got lost but it was actually received!</p><br><p>It seems like we need to make our reliability system&hellip; <em>more reliable!</em></p><br><h2 id="reliable-acks">Reliable Acks</h2><br><p>Here is where we diverge significantly from TCP.</p><br><p>What TCP does is maintain a sliding window where the ack sent is the sequence number of the next packet it expects to receive, in order. If TCP does not receive an ack for a given packet, it stops and resends a packet with that sequence number again. This is exactly the behavior we want to avoid!</p><br><p>In our reliability system, we never resend a packet with a given sequence number. We sequence n exactly once, then we send n+1, n+2 and so on. We never stop and resend packet n if it was lost, we leave it up to the application to compose a new packet containing the data that was lost, if necessary, and this packet gets sent with a new sequence number.</p><br><p>Because we&rsquo;re doing things differently to TCP, its now possible to have <em>holes</em> in the set of packets we ack, so it is no longer sufficient to just state the sequence number of the most recent packet we have received.</p><br><p>We need to include multiple acks per-packet.</p><br><p>How many acks do we need?</p><br><p>As mentioned previously we have the case where one side of the connection sends packets faster than the other. Let&rsquo;s assume that the worst case is one side sending no less than 10 packets per-second, while the other sends no more than 30. In this case, the average number of acks we&rsquo;ll need per-packet is 3, but if packets clump up a bit, we would need more. Let&rsquo;s say 6-10 worst case.</p><br><p>What about acks that don&rsquo;t get through because the packet containing the ack is lost?</p><br><p>To solve this, we&rsquo;re going to use a classic networking strategy of using redundancy to defeat packet loss!</p><br><p>Let&rsquo;s include 33 acks per-packet, and this isn&rsquo;t just going to be up to 33, but <em>always</em> 33. So for any given ack we <span style="text-decoration:underline;">redundantly</span> send it up to 32 additional times, just in case one packet with the ack doesn&rsquo;t get through!</p><br><p>But how can we possibly fit 33 acks in a packet? At 4 bytes per-ack thats 132 bytes!</p><br><p>The trick is to represent the 32 previous acks before &ldquo;ack&rdquo; using a bitfield:</p><br><pre><code>    [uint protocol id]<br>    [uint sequence]<br>    [uint ack]<br>    [uint ack bitfield]<br>    &lt;em&gt;(packet data…)&lt;/em&gt;<br></code></pre><br><p>We define &ldquo;ack bitfield&rdquo; such that each bit corresponds to acks of the 32 sequence numbers before &ldquo;ack&rdquo;. So let&rsquo;s say &ldquo;ack&rdquo; is 100. If the first bit of &ldquo;ack bitfield&rdquo; is set, then the packet also includes an ack for packet 99. If the second bit is set, then packet 98 is acked. This goes all the way down to the 32nd bit for packet 68.</p><br><p>Our adjusted algorithm looks like this:</p><br><ul><br><li><p>Each time we send a packet we increase the <em>local sequence number</em></p></li><br><li><p>When we receive a packet, we check the sequence number of the packet against the <em>remote sequence number</em>. If the packet sequence is more recent, we update the remote sequence number.</p></li><br><li><p>When we compose packet headers, the local sequence becomes the sequence number of the packet, and the remote sequence becomes the ack. The ack bitfield is calculated by looking into a queue of up to 33 packets, containing sequence numbers in the range [remote sequence - 32, remote sequence]. We set bit n (in [1,32]) in ack bits to 1 if the sequence number remote sequence - n is in the received queue.</p></li><br><li><p>Additionally, when a packet is received, ack bitfield is scanned and if bit n is set, then we acknowledge sequence number packet sequence - n, if it has not been acked already.</p></li><br></ul><br><p>With this improved algorithm, you would have to lose 100% of packets for more than a second to stop an ack getting through. And of course, it easily handles different send rates and clumped up packet receives.</p><br><h2 id="detecting-lost-packets">Detecting Lost Packets</h2><br><p>Now that we know what packets are received by the other side of the connection, how do we detect packet loss?</p><br><p>The trick here is to flip it around and say that if you don&rsquo;t get an ack for a packet within a certain amount of time, then we consider that packet lost.</p><br><p>Given that we are sending at no more than 30 packets per second, and we are redundantly sending acks roughly 30 times, if you don&rsquo;t get an ack for a packet within one second, it is <em>very</em> likely that packet was lost.</p><br><p>So we are playing a bit of a trick here, while we can know 100% for sure which packets get through, but we can only be <em>reasonably</em> certain of the set of packets that didn&rsquo;t arrive.</p><br><p>The implication of this is that any data which you resend using this reliability technique needs to have its own message id so that if you receive it multiple times, you can discard it. This can be done at the application level.</p><br><h2 id="handling-sequence-number-wrap-around">Handling Sequence Number Wrap-Around</h2><br><p>No discussion of sequence numbers and acks would be complete without coverage of sequence number wrap around!</p><br><p>Sequence numbers and acks are 32 bit unsigned integers, so they can represent numbers in the range [0,4294967295]. Thats a very high number! So high that if you sent 30 packets per-second, it would take over four and a half years for the sequence number to wrap back around to zero.</p><br><p>But perhaps you want to save some bandwidth so you shorten your sequence numbers and acks to 16 bit integers. You save 4 bytes per-packet, but now they wrap around in only half an hour.</p><br><p>So how do we handle this wrap around case?</p><br><p>The trick is to realize that if the current sequence number is already very high, and the next sequence number that comes in is very low, then you must have wrapped around. So even though the new sequence number is <em>numerically</em> lower than the current sequence value, it actually represents a more recent packet.</p><br><p>For example, let&rsquo;s say we encoded sequence numbers in one byte (not recommended btw. :)), then they would wrap around after 255 like this:</p><br><pre>    … 252, 253, 254, 255, 0, 1, 2, 3, …</pre><br><p>To handle this case we need a new function that is aware of the fact that sequence numbers wrap around to zero after 255, so that 0, 1, 2, 3 are considered more recent than 255. Otherwise, our reliability system stops working after you receive packet 255.</p><br><p>Here&rsquo;s a function for 16 bit sequence numbers:</p><br><pre><code>    inline bool sequence_greater_than( uint16_t s1, uint16_t s2 )<br>    {<br>        return ( ( s1 &gt; s2 ) &amp;&amp; ( s1 - s2 &lt;= 32768 ) ) ||<br>               ( ( s1 &lt; s2 ) &amp;&amp; ( s2 - s1  &gt; 32768 ) );<br>    }<br></code></pre><br><p>This function works by comparing the two numbers <em>and</em> their difference. If their difference is less than <sup>1</sup>&frasl;<sub>2</sub> the maximum sequence number value, then they must be close together - so we just check if one is greater than the other, as usual. However, if they are far apart, their difference will be greater than <sup>1</sup>&frasl;<sub>2</sub> the max sequence, then we paradoxically consider the sequence number more recent if it is <em>less</em> than the current sequence number.</p><br><p>This last bit is what handles the wrap around of sequence numbers transparently, so 0,1,2 are considered more recent than 255.</p><br><p>Make sure you include this in any sequence number processing you do.</p><br><h2 id="congestion-avoidance">Congestion Avoidance</h2><br><p>While we have solved reliability, there is still the question of congestion avoidance. TCP provides congestion avoidance as part of the packet when you get TCP reliability, but UDP has no congestion avoidance whatsoever!</p><br><p>If we just send packets without some sort of flow control, we risk flooding the connection and inducing severe latency (2 seconds plus!) as routers between us and the other computer become congested and buffer up packets. This happens because routers try <em>very hard</em> to deliver all the packets we send, and therefore tend to buffer up packets in a queue before they consider dropping them.</p><br><p>While it would be nice if we could tell the routers that our packets are time sensitive and should be dropped instead of buffered if the router is overloaded, we can&rsquo;t really do this without rewriting the software for all routers in the world.</p><br><p>Instead, we need to focus on what we can actually do which is to avoid flooding the connection in the first place. We try to avoid sending too much bandwidth in the first place, and then if we detect congestion, we attempt to back off and send even less.</p><br><p>The way to do this is to implement our own basic congestion avoidance algorithm. And I stress basic! Just like reliability, we have no hope of coming up with something as general and robust as TCP&rsquo;s implementation on the first try, so let&rsquo;s keep it as simple as possible.</p><br><h2 id="measuring-round-trip-time">Measuring Round Trip Time</h2><br><p>Since the whole point of congestion avoidance is to avoid flooding the connection and increasing round trip time (RTT), it makes sense that the most important metric as to whether or not we are flooding our connection is the RTT itself.</p><br><p>We need a way to measure the RTT of our connection.</p><br><p>Here is the basic technique:</p><br><ul><br><li><p>For each packet we send, we add an entry to a queue containing the sequence number of the packet and the time it was sent.</p></li><br><li><p>Each time we receive an ack, we look up this entry and note the difference in local time between the time we receive the ack, and the time we sent the packet. This is the RTT time for that packet.</p></li><br><li><p>Because the arrival of packets varies with network jitter, we need to smooth this value to provide something meaningful, so each time we obtain a new RTT we move a percentage of the distance between our current RTT and the packet RTT. 10% seems to work well for me in practice. This is called an exponentially smoothed moving average, and it has the effect of smoothing out noise in the RTT with a low pass filter.</p></li><br><li><p>To ensure that the sent queue doesn&rsquo;t grow forever, we discard packets once they have exceeded some maximum expected RTT. As discussed in the previous section on reliability, it is exceptionally likely that any packet not acked within a second was lost, so one second is a good value for this maximum RTT.</p></li><br></ul><br><p>Now that we have RTT, we can use it as a metric to drive our congestion avoidance. If RTT gets too large, we send data less frequently, if its within acceptable ranges, we can try sending data more frequently.</p><br><h2 id="simple-binary-congestion-avoidance">Simple Binary Congestion Avoidance</h2><br><p>As discussed before, let&rsquo;s not get greedy, we&rsquo;ll implement a very basic congestion avoidance. This congestion avoidance has two modes. Good and bad. I call it simple binary congestion avoidance.</p><br><p>Let&rsquo;s assume you send packets of a certain size, say 256 bytes. You would like to send these packets 30 times a second, but if conditions are bad, you can drop down to 10 times a second.</p><br><p>So 256 byte packets 30 times a second is around 64kbits/sec, and 10 times a second is roughly 20kbit/sec. There isn&rsquo;t a broadband network connection in the world that can&rsquo;t handle at least 20kbit/sec, so we&rsquo;ll move forward with this assumption. Unlike TCP which is entirely general for any device with any amount of send/recv bandwidth, we&rsquo;re going to assume a minimum supported bandwidth for devices involved in our connections.</p><br><p>So the basic idea is this. When network conditions are &ldquo;good&rdquo; we send 30 packets per-second, and when network conditions are &ldquo;bad&rdquo; we drop to 10 packets per-second.</p><br><p>Of course, you can define &ldquo;good&rdquo; and &ldquo;bad&rdquo; however you like, but I&rsquo;ve gotten good results considering only RTT. For example if RTT exceeds some threshold (say 250ms) then you know you are probably flooding the connection. Of course, this assumes that nobody would normally exceed 250ms under non-flooding conditions, which is reasonable given our broadband requirement.</p><br><p>How do you switch between good and bad? The algorithm I like to use operates as follows:</p><br><ul><br><li><p>If you are currently in good mode, and conditions become bad, immediately drop to bad mode</p></li><br><li><p>If you are in bad mode, and conditions have been good for a specific length of time &rsquo;t&rsquo;, then return to good mode</p></li><br><li><p>To avoid rapid toggling between good and bad mode, if you drop from good mode to bad in under 10 seconds, double the amount of time &rsquo;t&rsquo; before bad mode goes back to good. Clamp this at some maximum, say 60 seconds.</p></li><br><li><p>To avoid punishing good connections when they have short periods of bad behavior, for each 10 seconds the connection is in good mode, halve the time &rsquo;t&rsquo; before bad mode goes back to good. Clamp this at some minimum like 1 second.</p></li><br></ul><br><p>With this algorithm you will rapidly respond to bad conditions and drop your send rate to 10 packets per-second, avoiding flooding of the connection. You&rsquo;ll also <em>conservatively</em> try out good mode, and persist sending packets at a higher rate of 30 packets per-second, while network conditions are good.</p><br><p>Of course, you can implement much more sophisticated algorithms. Packet loss % can be taken into account as a metric, even the amount of network jitter (time variance in packet acks), not just RTT.</p><br><p>You can also get much more <em>greedy</em> with congestion avoidance, and attempt to discover when you can send data at a much higher bandwidth (eg. LAN), but you have to be very careful! With increased greediness comes more risk that you&rsquo;ll flood the connection.</p><br><h2 id="conclusion">Conclusion</h2><br><p>Our new reliability system let&rsquo;s us send a steady stream of packets and notifies us which packets are received. From this we can infer lost packets, and resend data that didn&rsquo;t get through if necessary. We also have a simple congestion avoidance system that drops from 30 packets per-second to 10 times a second so we don&rsquo;t flood the connection.</p>

<h1 id="译文"><a href="#译文" class="headerlink" title="译文"></a>译文</h1><p><a href="http://gad.qq.com/program/translateview/7161834" target="_blank" rel="noopener">译文出处</a></p>
<!-- <div style="display:none"> -->
<div class="WordSection1"><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-family: 微软雅黑, sans-serif; font-size: 12pt; line-height: 150%;">翻译：艾涛（轻描一个世界） </span><span style="font-family: 微软雅黑, sans-serif; font-size: 12pt; line-height: 150%;">  </span><span style="font-family: 微软雅黑, sans-serif; font-size: 12pt; line-height: 150%;">审校：黄威（横写丶意气风发）</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><br></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><b style="line-height: 1.5;"><span style="line-height: 40px; font-size: 20pt; font-family: 微软雅黑, sans-serif; color: rgb(34, 34, 34); border: 1pt none windowtext; padding: 0cm;">简介</span></b></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">嗨，我是格伦<span>-</span>菲德勒，欢迎来到我的</span><span><a rel="noopener" href="http://gafferongames.com/networking-for-game-programmers/" target="_blank"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:red"><span>游戏程序员网络设计</span></span></a></span><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">文章系列的第四篇。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">在</span><span><a rel="noopener" href="http://gafferongames.com/networking-for-game-programmers/virtual-connection-over-udp/" target="_blank"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:red"><span>之前的文章</span></span></a></span><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">里，我们将我们的虚拟连接的概念加入到<span>UDP</span>之上。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">现在我们将要给我们的虚拟<span>UDP</span>连接增加可靠性，排序和避免拥堵。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">这是迄今为止底层游戏网络设计中最复杂的一面，因此这将是一篇</span><span style="font-size: 12pt; line-height: 150%; font-family: 微软雅黑, sans-serif;">极其热情</span><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">的文章，跟上我启程出发！</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"> </span><img src="http://gameweb-img.qq.com/gad/20160617/phpYxViiW.1466148040.jpg" alt="游戏网络开发(四)：基于UDP的可靠性，排序和避免拥堵" style="line-height: 1.5;"></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><b><span style="font-size:20.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm">TCP</span></b><b><span style="font-size:20.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm">的问题</span></b></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">熟悉<span>TCP</span>的你们知道它已经有了自己关于连接、可靠性、排序和避免拥堵的概念，那么为什么我们还要重写我们自己的迷你版本的基于<span>UDP</span>的<span>TCP</span>呢？</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">问题是多人动作游戏依靠于一个稳定的每秒发送<span>10</span>到<span>30</span>包的数据包流，而且在大多数情况下，这些数据包中包含的数据对时间是如此敏感以至于只有最新的数据才是有用的。这包括玩家的输入，位置方向和每个玩家角色的速度以及游戏世界中物理对象的状态等数据。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">TCP</span><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">的问题是它提取的是以可靠有序的数据流发送的数据。正因为如此，如果一个数据包丢失了，<span>TCP</span>不得不停止以等待那个数据包重新发送，这打断了这个稳定的数据包流因为更多的最新的数据包在重新发送的数据包到达之前必须在队列中等待，所以数据包必须有序地提供。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">我们需要的是一种不同类型的可靠性。我们想要以一个稳定的速度发送数据包而且当数据被其他电脑接收到时我们会得到通知，而不是让所有的数据用一个可靠有效的数据流处理。这样的方法使得那些对时间敏感的数据能够不用等待重新发送的数据包就通过，而让我们自己拿主意怎么在应用层级去处理丢包。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">具有<span>TCP</span>这些特性的系统是不可能实现可靠性的，</span><span style="font-size: 12pt; line-height: 150%; font-family: 微软雅黑, sans-serif;">因此我们别无选择只能在<span>UDP</span>的基础上自行努力。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">不幸的是，可靠性并不是唯一一个我们必须重写的东西，这是因为<span>TCP</span>也提供避免拥堵功能，这样它就能够动态地衡量数据发送速率以来适应网络连接的性能。例如<span>TCP</span>在<span>28.8k</span>的调制调解器上会比在<span>T1</span>线路上发送更少的数据，而且它在不用事先知道这是什么类型的网络连接的情况下就能这么做！</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><b><span style="font-size:20.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm">序列号</span></b></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">现在回到可靠性！</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">我们可靠性系统的目标很简单：我们想要知道哪些数据包到了网络连接的另一端。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">首先我们得鉴别数据包。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">如果我们添加一个“数据包<span>id</span>”的概念会怎么样？让我们先给<span>id</span>赋一个整数值。我们能够从零开始，然后随着我们每发送一个数据包，增加一个数值。我们发送的第一个数据包就是“包<span>0</span>”，发送的第<span>100</span>个数据包就是“包<span>99</span>”。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">这实际上是一个相当普遍的技术。甚至于在<span>TCP</span>中也得到了应用！这些数据包<span>id</span>叫做序列号，然而我们并不打算像<span>TCP</span>那样去做来实现可靠性，使用相同的术语是有意义的，因此从现在起我们还将称之为序列号。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">因为<span>UDP</span>并不能保证数据包的顺序，所以第<span>100</span>个收到的数据包并不一定是第<span>100</span>个发出的数据包。接下来我们需要在数据包中插入序列号这样网络连接另一端电脑便能够知道是哪个数据包。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">我们在</span><span><a rel="noopener" href="http://gafferongames.com/networking-for-game-programmers/virtual-connection-over-udp/" target="_blank"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#C00000"><span>前一篇文章</span></span></a></span><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#C00000">中</span><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">已经有了一个简单的关于虚拟网络连接的数据头，因此我们将只需要像这样在数据头中插入序列号：</span></p><div style="border:solid #F0F0F0 1.0pt;border-left:solid #E0E0E0 2.25pt;padding:0cm 0cm 0cm 0cm;background:whitesmoke"><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222">   [uint protocol id]</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222">   [uint sequence]</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><i><span style="font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm">(packet data…)</span></i></p></div><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">现在当其他电脑收到一个数据包时通过发送数据包的电脑它就能知道数据包的序列号啦。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><b><span style="font-size:20.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm">应答系统</span></b></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">既然我们已经能够使用序列号来鉴别数据包，下一步就该是让网络连接的另一端知道我们收到了哪个包了。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">逻辑上来说这是非常简单的，我们只需要记录我们收到的每个包的序列号，然后把那些序列号发回发送他们的电脑即可。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">因为我们是在两个机器间相互发送数据包，我们只能在数据包头添加上确认字符，就像我们加上序列号一样：</span></p><div style="border:solid #F0F0F0 1.0pt;border-left:solid #E0E0E0 2.25pt;padding:0cm 0cm 0cm 0cm;background:whitesmoke"><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222">    [uint protocol id]</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222">    [uint sequence]</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222">    [uint ack]</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><i><span style="font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm">(packet data…)</span></i></p></div><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">我们的一般方法如下：</span></p><ul type="disc"><li class="MsoNormal" style="text-align:left;line-height:150%;vertical-align:     baseline"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">每次我们发送一个数据包我们就增加本地序列号。</span></li><li class="MsoNormal" style="text-align:left;line-height:150%;vertical-align:     baseline"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">当我们接收一个数据包时，我们将这个数据包的序列号与最近收到的数据包的序列号(称之为远程序列号)进行核对。如果这个包时间更近，我们就更新远程序列号使之等于这个数据包的序列号。</span></li><li class="MsoNormal" style="text-align:left;line-height:150%;vertical-align:     baseline"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">当我们编写数据包头时，本地序列号就变成了数据包的序列号，而远程序列号则变成确认字符。</span></li></ul><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">这个简单的应答系统工作条件是每当我们发出一个数据包就会接收到一个数据包。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">但如果数据包一起发送这样在我们发送一个数据包之前有两个数据包到达该怎么办呢？我们每个数据包只留了一个确认字符的位置，那我们该怎么处理呢<span>?</span></span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">现在考虑网络连接中的一端用更快的速率发送数据包这种情况。如果客户端每秒发送<span>30</span>个数据包，而服务器每秒只发送<span>10</span>个数据包，这样从服务器发出的每个数据包我们至少需要<span>3</span>个确认字符。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">让我们想得更复杂点！</span><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">如果数据包留下来了而确认字符丢失了会怎么样？这<span style="color:#222222">样发送这个数据包的电脑会认为这个数据包已经丢失了而实际上它已经被收到了！</span></span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">貌似我们需要让我们的可靠性系统……<span style="border:none windowtext 1.0pt;padding:0cm">更加可靠一点！</span></span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><b><span style="font-size:20.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm">可靠的应答系统</span></b></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">这就是我们偏离<span>TCP</span>的地方。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">TCP</span><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">的做法是在确认字符发送的地方给下一个按顺序预期该收到的数据包序列号的位置维持一个移动窗口。<span style="color:#222222">如果<span>TCP</span>对于一个已经发出的数据包没有收到确认字符，它将暂停并重新发送那个对应序列号的数据包。这正是我们想要避免的做法！</span></span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">因此在我们的可靠性系统里，我们从不为一个已经发出的序列号重新发送数据包，我们精确地只排序一次<span>n</span>，然后我们发送<span>n+1</span>，<span>n+2</span>，依次类推。如果数据包<span>n</span>丢失了我们也从不暂停重新发送它，而是把它留给应用程序来编写一个包含丢失数据的新的数据包，必要的话，这个包还会用一个新的序列号发送。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">因为我们工作的方式与<span>TCP</span>不同，</span><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">它的做法现在可能在我们数据包的确定字符设置中有了个洞，<span style="color:#222222">因此现在仅仅陈述最近的数据包的序列号已经远远不够了。</span></span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">我们需要在每个数据包中包含多个确认字符。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">那我们需要多少确认字符呢<span>?</span></span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">正如之前提到网络连接的一端发包速率比另一端快的情况，让我们假定最糟的情况是一端每秒钟发送不少于<span>10</span>个数据包，而另一端每秒钟发送不多于<span>30</span>个数据包。这种情况下，我们每个数据包需要的平均确认字符数是<span>3</span>个，但是如果数据包发送密集点，我们将需要更多。让我们说<span>6-10</span>个最差的情况。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">如果因为包含确认字符的数据包丢失而导致确认字符并没有到达怎么办<span>?</span></span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">为了解决这个问题，我们将要使用一种经典的使用冗余码的网络设计策略来处理数据包丢失的情况！</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">让我们在每个数据包中容纳<span>33</span>个确认字符，而且这不仅是他将要达到<span>33</span>个，而是一直是<span>33</span>个。因此对于每一个发出的确认字符我们多余地把它额外多发送了多达<span>32</span>次，仅仅是以防某个包含确认字符的数据包不能通过！</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">但是我们怎么可能在一个数据包里配置<span>33</span>个确认字符呢？每个确认字符<span>4</span>字节那就是<span>132</span>字节了！</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">窍门是在“相应确认字符”之前使用一段位域来代表<span>32</span>个之前的确认字符<span style="color:#222222">，就像这样</span></span><span style="font-size:12.0pt;line-height:150%;font-family:宋体;color:#222222">：</span></p><div style="border:solid #F0F0F0 1.0pt;border-left:solid #E0E0E0 2.25pt;padding:0cm 0cm 0cm 0cm;background:whitesmoke"><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm">   [uint protocol id]</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm">   [uint sequence]</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm">   [uint ack]</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm">   [uint ack bitfield]</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><i><span style="font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm">(packet data…)</span></i></p></div><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">我们这样规定“位域”中每一位对应“相应确认字符”之前的<span>32</span>个确认字符<span style="color:#222222">。因此让我们说“相应确认字符”是<span>100</span>。如果位域的第一位设置好了，那么这个数据包也包含包<span>99</span>的一个确认字符。如果第二位设置好了，那么它也包含包<span>98</span>的一个确认字符。这样一路下来就到了包<span>68</span>的第<span>32</span>位。</span></span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">我们调整过的算法看起来就像这样<span>:</span></span></p><ul type="disc"><li class="MsoNormal" style="color:#222222;text-align:left;line-height:150%;     vertical-align:baseline"><span style="font-size:12.0pt;line-height:150%;     font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:windowtext">每次我们发送一个数据包我们就增加本地序列号</span><span style="font-size:12.0pt;line-height:150%;font-family:&quot;quot;微软雅黑&quot;,&quot;sans-serif&quot;">。</span></li><li class="MsoNormal" style="text-align:left;line-height:150%;vertical-align:     baseline"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">当我们接收一个数据包时，我们将这个数据包的序列号与最近收到的数据包的序列号(称之为远程序列号)进行核对。如果这个包是更新的，我们就更新远程序列号使之等于数据包的序列号。</span></li><li class="MsoNormal" style="text-align:left;line-height:150%;vertical-align:     baseline"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">当我们编写数据包头时，本地序列号就变成了数据包的序列号，而远程序列号则变成确认字符<span style="color:#222222">。 计算确认字符位域是通过寻找一个多达<span>33</span>个数据包的队列，其中包括在<span>[</span>远程序列号<span>-32</span>，远程序列号<span>]</span>范围内的序列号。</span>如果序列号“远程序列号<span>-n</span>”正在接收队列中那就把确认字符位域中的位<span>n</span>（在<span>[1</span>，<span>32]</span>范围内）设置为位<span>1</span>。</span></li><li class="MsoNormal" style="color:#222222;text-align:left;line-height:150%;     vertical-align:baseline"><span style="font-size:12.0pt;line-height:150%;     font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:windowtext">此外，当一个数据包被接收了，确认字符位域也被扫描了，如果位<span>n</span>设置好了，那么即使它还没有被应答，我们也认可序列号“远程序列号<span>-n</span>”</span><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">。</span></li></ul><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">利用这个改善过的算法，你将可能不得不在不止一秒内丢掉<span>100%</span>的数据包而不是让一个数据包停止通过。当然，它能够轻松地处理不同的发包速率和接受一起发送的数据包。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><b><span style="font-size:20.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm">检测丢包</span></b></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">既然我们知道网络连接另一端接受的是哪些数据包，那么我们该怎么检测数据包的丢失呢<span>?</span></span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">这次的窍门是反过来想，如果你在一定时间内还没有收到某个数据包的应答，那么我们可以考虑说那个数据包已经丢失了。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">考虑到我们正在以每秒不超过<span>30</span>包的速率发送数据包，而且我们正在多余地发送数据包大概三十次。如果你在一秒内没有收到某个数据包的确认字符，那很有可能就是这个数据包已经丢失了。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">因此我们在这儿用了一些小窍门，尽管我们能<span>100%</span>确定哪个数据包通过了，但是我们只能适度地确定那些没有到达的数据包。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">这种情况的复杂性在于任何你重新发送的使用了这种可靠性方法的数据需要有它自己的信息<span>id</span>，这样的话在你多次收到它的时候你可以放弃它。这在应用层级是能够做到的。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><b><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm">应对环绕式处理的序列号</span></b></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">如果序列号没有环绕式处理覆盖，那么对于序列号和确认字符的讨论是不完整的！</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">序列号和确认字符都是<span>32</span>比特的无符号整数，因此它们能够代表在范围<span>[0</span>，<span>4294967295]</span>内的数字。那是一个非常大的数字！那么大以至于如果你每秒发送三十个数据包也将要花费四年半来把这个序列号环绕式处理回零。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">但是可能你想要节省一些带宽这样你将你的序列号和确认字符缩减到到<span>16</span>比特整数。你每个数据包节省了<span>4</span>个字节，但现在他们只需要在仅仅半个小时内即可完成环绕式处理！</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">所以我们该怎么应对这种环绕式处理的情况呢<span>?</span></span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">诀窍是要认识到如果当前序列号已经非常高了，而且下一个到达的序列号很低，那么你就必须进行环绕式处理。那么即使新的序列号数值上比当前序列号值更低它也能实际代表一个更新的数据包。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">举个例子，让我们假设我们用一个字节编码序列号（顺便说一下并不推荐这样做）。<span> :))</span>， 之后他们就会在<span>255</span>后面进行环绕式处理，就像这样</span><span style="font-size:12.0pt;line-height:150%;font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222">:</span></p><div style="border:solid #F0F0F0 1.0pt;border-left:solid #E0E0E0 2.25pt;padding:0cm 0cm 0cm 0cm;background:whitesmoke"><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222">   … 252, 253, 254, 255, 0, 1, 2, 3,…</span></p></div><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">为了解决这种情况我们需要一个能够意识到在<span>255</span>之后需要环绕式处理回零这样一个事实的新功能，这样<span>0</span>，<span>1</span>，<span>2</span>，<span>3</span>就会被认为比<span>255</span>更新。否则，我们的可靠性系统就会在你收到包<span>255</span>后停止工作。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">这就是那个新功能：</span></p><div style="border:solid #F0F0F0 1.0pt;border-left:solid #E0E0E0 2.25pt;padding:0cm 0cm 0cm 0cm;background:whitesmoke"><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm">boolsequence_more_recent( unsigned int s1, </span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm">                          unsigned int s2,</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm">                          unsigned int max )</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm">{</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm">   return </span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm">       ( s1 &gt; s2 ) &amp;&amp;</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm">       ( s1 - s2 &lt;= max/2 ) </span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm">          ||</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm">       ( s2 &gt; s1 ) &amp;&amp;</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm">       ( s2 - s1  &gt; max/2 );</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;Courier New&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm">}</span></p></div><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">这个功能通过比较两个数字和他们的不同来工作。如果它们之间的差异少于<span>1/2</span>的最大序列号值，那么它们必须靠在一起<span>– </span>因此我们只需要照常检查某个序列号是否比另一个大。然而，如果它们相差很多，它们之间的差异将会比<span>1/2</span>的最大序列号值大，那么如果它比当前序列号小我们反而认为这个序列号是更新的。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">这最后一点是显然需要环绕式处理序列号的地方，那么<span>0</span>，<span>1</span>，<span>2</span>就会被认为比<span>255</span>更新。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">多么简洁而巧妙！</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">一定要确保你在你所做的任何序列号处理当中包含了这一步！</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><b><span style="font-size:20.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm">避免拥堵</span></b></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">当你已经解决了可靠性的问题的时候，还有避免拥堵的问题。当你获得<span>TCP</span>的可靠性的时候<span>TCP</span>已经提供了避免拥堵的功能作为数据包的一部分，但是<span>UDP</span>无论怎样都不会有避免拥堵！</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">如果我们仅仅发送数据包而没有某种流量控制，我们正在冒险占满网络连接而且会引起严重的延迟（<span>2</span>秒以上！），正如我们和另外一台电脑之间的路由器会超负荷而缓冲数据包。这个发生是因为路由器很努力地想要尝试传送我们发送的所有数据包，因此在它们考虑丢弃数据包之前会在队列中缓冲数据包。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">然而如果我们能告诉路由器我们的数据包是时间敏感的而且如果路由器超载的话这些数据包应该丢弃而不是缓冲这样会很棒的，但只有我们重写世界上所有路由器的软件才能做到这一点！</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">那么我们反而需要把重点放在我们实际上能做的是<u>避免占满首位网络连接</u>。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">做到这个的方法是实施我们自己的基础避免拥堵算法。我强调基础！就像可靠性，我们并不寄希望于像<span>TCP</span>第一次尝试应用那样普通而粗暴地想出某些东西，那么让我们让它尽可能简单吧。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><b><span style="font-size:20.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm">衡量往返时间</span></b></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">因为所有避免拥堵的要点就是避免占满网络连接和避免增加往返时间（<span>RTT</span>），关于我们是不是占满网络的最重要的衡量标准是<span>RTT</span>它本身的观点是有道理的。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">我们需要一种方法来衡量我们网络连接的<span>RTT</span>。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">这是基础的技巧：</span></p><ul type="disc"><li class="MsoNormal" style="color:#222222;text-align:left;line-height:150%;     vertical-align:baseline"><span style="font-size:12.0pt;line-height:150%;     font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">对我们发送的每个数据包，我们对数据包队列中包含的序列号和他们发送的时间添加一个登记。</span></li><li class="MsoNormal" style="color:#222222;text-align:left;line-height:150%;     vertical-align:baseline"><span style="font-size:12.0pt;line-height:150%;     font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:windowtext">当我们收到一个应答时，我们找到这个登记, 然后记录我们收到这个应答的时间t1与我们发送数据包的时间的t2的差值(都基于本地时间来计算)。这就是是这个数据包的<span>RTT</span>时间</span><span style="font-size:12.0pt;line-height:     150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">。</span></li><li class="MsoNormal" style="color:#222222;text-align:left;line-height:150%;     vertical-align:baseline"><span style="font-size:12.0pt;line-height:150%;     font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">因为数据包的到达因网络波动而不同，我们需要缓和这个值来提供某些有意义的东西，这样每次我们获得一个新的<span>RTT</span>我们就移动一个我们当前的<span>RTT</span>和数据包的<span>RTT</span>之间距离的百分比。<span>10%</span>在实践中看起来效果很好。这就叫做一个指数级平滑移动平均值，而且它在用一个低通滤波器的情况下能有效地平滑<span>RTT</span>中的杂音。</span></li><li class="MsoNormal" style="color:#222222;text-align:left;line-height:150%;     vertical-align:baseline"><span style="font-size:12.0pt;line-height:150%;     font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">为了确保发送队列永不增长，一旦超过某些最大预期<span>RTT</span>值我们就丢弃数据包。正如上一节关于可靠性讨论过的，任何在一秒内未应答的数据包都极有可能丢失了，那么对于最大<span>RTT</span>来说，一秒是个很棒的值。</span></li></ul><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">既然我们有<span>RTT</span>，我们能把它作为一个衡量标准来推动我们的避免拥堵功能。如果<span>RTT</span>变得太大了，我们更缓慢地发送数据，如果它的值低于可接受范围，我们能努力更频繁地发送数据。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><b><span style="font-size:20.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm">简单的好坏机制避免拥堵</span></b></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">正如之前讨论的，我们不要那么贪心，我们将要执行一个非常基础的避免拥堵机制。这个避免拥堵机制有两种模式。好和坏。我把它叫做简单的二进制避免拥堵。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">让我们假设你在发送一个确定大小的数据包，就假设<span>256</span>字节吧。你想要每秒发送这些数据包<span>30</span>次，但是如果网络条件差，你可以削减为每秒<span>10</span>次。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">那么<span>30</span>次<span>256</span>字节的数据包的速率大概是<span>64kbits/sec</span>，每秒<span>10</span>次的话大概<span>20kbits/sec</span>。世界上没有一个宽带连接不能处理至少<span>20kbits/sec</span>的速率，所以我们在这样的假定下继续前进。不像<span>TCP</span>这样对有任何数量的发送<span>/</span>接受带宽的任何设备都完全通用，我们将假设一个设备的最小支持带宽来参与我们的网络连接。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">所以基础想法就是这样了。当网络条件好的时候我们每秒发送<span>30</span>个数据包，当网络条件差的时候我们降至每秒<span>10</span>个数据包。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">当然，你能随你喜爱定义好和坏，但是仅考虑<span>RTT</span>的时候我已经得到了好的成效。举个例子，如果<span>RTT</span>超过某些极限值（假设<span>250ms</span>）那你就知道你可能已经正占满了网络连接。当然，这里假设一般没人在非占满网络条件下超过<span>250ms</span>，考虑到我们的宽带要求这是合理的。。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">好和坏之间你会怎么转换？我喜欢用下列操作的算法<span>:</span></span></p><ul type="disc"><li class="MsoNormal" style="color:#222222;text-align:left;line-height:150%;     vertical-align:baseline"><span style="font-size:12.0pt;line-height:150%;     font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">如果你当前在好模式下，而网络条件突然变坏，立即降至坏模式。</span></li><li class="MsoNormal" style="color:#222222;text-align:left;line-height:150%;     vertical-align:baseline"><span style="font-size:12.0pt;line-height:150%;     font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">如果你正在坏模式下，而且网络条件已经好了一段特定时长<span>”t”</span>，那么回到好模式。</span></li><li class="MsoNormal" style="color:#222222;text-align:left;line-height:150%;     vertical-align:baseline"><span style="font-size:12.0pt;line-height:150%;     font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">为了避免好模式和坏模式之间的快速切换，如果你从好模式降至坏模式持续<span>10</span>秒钟以内，从坏模式回到好模式之前的时间是<span>”t”</span>的两倍。在某些最大值中固定这个时间值，假设<span>60</span>秒。</span></li><li class="MsoNormal" style="color:#222222;text-align:left;line-height:150%;     vertical-align:baseline"><span style="font-size:12.0pt;line-height:150%;     font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:windowtext">为了避免打击良好的网络连接，当它们有一小段时期的差连接时，每过<span>10</span>秒连接就处于好模式，把坏模式回到好模式之前的时间<span>“t”</span>减半。在某些最小值中固定这个时间值，例如<span>1</span>秒</span><span style="font-size:12.0pt;line-height:150%;     font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">。</span></li></ul><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">利用这个算法，你将对差网络连接迅速反应然后降低你的发送速率至每秒<span>10</span>个数据包，避免占满网络。在网络条件好时，你也将谨慎地尝试好模式，坚持以更高的每秒发送<span>30</span>个数据包的速率发送数据包。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">当然，你也能实施复杂得多的算法，丢包率百分比甚至是网络波动（数据包确认字符的时间差异）都可以考虑作为一个衡量标准，而不仅仅是<span>RTT</span>。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">对于避免拥堵你还可以更贪心点，并尝试发现什么时候你能以一个更高的带宽（例如<span>LAN</span>）发送数据，但是你必须非常小心！随着贪婪心的增加你占满网络连接的风险也在增大！</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"> </span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><b><span style="font-size:20.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm">结语</span></b></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">我们全新的可靠性系统让我们稳定流畅发送数据包，而且能通知我们收到了什么数据包。从这我们能推断出丢失的数据包，必要的话重新发送没有通过的数据。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">基于此我们有了能够取决于网络条件在每秒<span>10</span>次和每秒<span>30</span>次发包速率间轮流切换的一个简单的避免拥堵系统，因此我们不会占满网络连接。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">还有很多实施细节因为太具体而不能在这篇文章一一提到，所以务必确保你检查</span><span><a rel="noopener" href="http://netgame.googlecode.com/files/ReliabilityAndFlowControl.zip" target="_blank"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:red"><span>示例源代码</span></span></a></span><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">来看是否它都被实施了。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">这就是关于可靠性，排序和避免拥堵的一切了，或许是低层次网络设计中最复杂的一面了。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"> </span></p><p class="MsoNormal" style="line-height:150%"><br></p><p class="MsoNormal" style="line-height:150%">【版权声明】</p><p class="MsoNormal" style="line-height:150%"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">原文作者未做权利声明，视为共享知识产权进入公共领域，自动获得授权；</span><span style="font-size:9.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#333333"> </span></p><p class="MsoNormal" align="left" style="text-indent: 24pt;"><span style="font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222"> </span></p></div>                    <br>                



<h1 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h1><p>因 Gaffer On Games 的源码原下载地址失效, 所以特地补上.</p>
<p><a href="https://github.com/no5ix/ReliableUDP" target="_blank" rel="noopener">请点击</a></p>

      


      

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/GafferOnGames/" rel="tag"><i class="fa fa-tag"></i> GafferOnGames</a>
            
              <a href="/tags/UDP/" rel="tag"><i class="fa fa-tag"></i> UDP</a>
            
          </div>
        

        
        
        

        
          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2016/11/16/virtual_connection_over_udp/" rel="next" title="游戏网络开发三之基于UDP的虚拟连接">
                  <i class="fa fa-chevron-left"></i> 
                  <p class="post-nav-pre-next-title">
                    游戏网络开发三之基于UDP的虚拟连接
                  </p> 
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2016/11/18/游戏网络开发五之每个游戏开发者都需要知道的游戏网络知识/" rel="prev" title="游戏网络开发五之每个游戏开发者都需要知道的游戏网络知识">
                <p class="post-nav-pre-next-title">
                    游戏网络开发五之每个游戏开发者都需要知道的游戏网络知识
                </p> 
                <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        

        
        
      </footer>
      
    </div>
    
    
    

    

    

    

  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  

  <aside id="sidebar" class="sidebar">

    
      
        <div id="sidebar-dimmer"></div>
      
    

    <div class="sidebar-inner">
    
      <div class="sidebar-toggle-inside motion-element">
        <div class="sidebar-toggle-line-wrap">
          <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
          <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
          <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
        </div>
      </div>

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a href="/" class="site-author-image" rel="start" style="border:none">
            <img class="site-author-image" itemprop="image" src="/uploads/avatar.png" alt="no5ix">
          </a>
          <p class="site-author-name" itemprop="name">no5ix</p>
           
              <p class="site-description motion-element" itemprop="description">推荐使用Chrome/Firefox/Safari阅读本博客. 以前的老笔记将会一篇一篇慢慢整理为博客, 这既启发了他人, 也锻炼了自己的描述交流能力.</p>
          
        </div>

        <nav class="site-state motion-element">

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">256</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">97</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

          <div class="site-state-item site-state-about">
            <a href="/about/">
              <span class="site-state-item-about fa fa-fw fa-user"></span>
              <span class="site-state-item-name">关于</span>
            </a>
          </div>
          
        </nav>

        

        <div class="links-of-author motion-element">
          
          
          <!-- 网易云音乐 -->
            <!-- <div class="netease-cloud-music"> -->
              <!-- <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=280 height=110 src="//music.163.com/outchain/player?type=0&id=992743594&auto=0&height=90"></iframe> -->
            <!-- </div> -->
          <!-- 网易云音乐 -->

        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-block">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://119.23.17.57" title="ksun的博客" target="_blank">ksun的博客</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://mp.weixin.qq.com/mp/homepage?__biz=MzU3MTUyNzg0NQ==&hid=1&sn=7a3ae61b7af714f75d68e7ae826a2d2c&scene=18#wechat_redirect" title="你有图么我有故事" target="_blank">你有图么我有故事</a>
                </li>
              
            </ul>
          </div>
        

        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#原文"><span class="nav-number">1.</span> <span class="nav-text">原文</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#introduction"><span class="nav-number">1.1.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#the-problem-with-tcp"><span class="nav-number">1.2.</span> <span class="nav-text">The Problem with TCP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sequence-numbers"><span class="nav-number">1.3.</span> <span class="nav-text">Sequence Numbers</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#acks"><span class="nav-number">1.4.</span> <span class="nav-text">Acks</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#reliable-acks"><span class="nav-number">1.5.</span> <span class="nav-text">Reliable Acks</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#detecting-lost-packets"><span class="nav-number">1.6.</span> <span class="nav-text">Detecting Lost Packets</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#handling-sequence-number-wrap-around"><span class="nav-number">1.7.</span> <span class="nav-text">Handling Sequence Number Wrap-Around</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#congestion-avoidance"><span class="nav-number">1.8.</span> <span class="nav-text">Congestion Avoidance</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#measuring-round-trip-time"><span class="nav-number">1.9.</span> <span class="nav-text">Measuring Round Trip Time</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#simple-binary-congestion-avoidance"><span class="nav-number">1.10.</span> <span class="nav-text">Simple Binary Congestion Avoidance</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#conclusion"><span class="nav-number">1.11.</span> <span class="nav-text">Conclusion</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#译文"><span class="nav-number">2.</span> <span class="nav-text">译文</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#源码下载"><span class="nav-number">3.</span> <span class="nav-text">源码下载</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2013 - 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">no5ix</span>
</div>



        

        
      </div>
    </footer>

    <!--
    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      
        <span id="scrollpercent"><span>0</span>%</span>
      
    </div>
    -->

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/dist/jquery.fancybox.js?v=3.2.10"></script>


  




  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>


  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  

  <script type="text/javascript">

    var is_load_xml_finished = 0;

    var searchFunc = function (path, search_id, content_id) {
      // 0x00. environment initialization
      'use strict';

      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      // var datas = [];

      /* loading css1 : Dot Css Loader*/
      var DotLoader = "<div class='loader'>Loading...</div>";

      /* loading css2 : Pure Css Loader - Square */
      var SquareLoader = 
        "<div class='loader'>" +
          "<div class='square' ></div>" +
          "<div class='square'></div>" +
          "<div class='square last'></div>" +
          "<div class='square clear'></div>" +
          "<div class='square'></div>" +
          "<div class='square last'></div>" +
          "<div class='square clear'></div>" +
          "<div class='square '></div>" +
          "<div class='square last'></div>" +
        "</div>";

      var ProgressBar = 
          "<div class='progress-bar'>" +
            "<div class='progress-bar-charge'></div>" +
          "</div>";

      var str = "";
      var keywords = [];
      var temp_keyword = "";

      // 是否为第一个字母被键入的标志位
      var first_char_flag = 0;

      // 因为在移动设备上, 点击搜索之后会 scroll 到页面顶部, 所以需要记录之前的页面x, y坐标值, 以便于搜索完点击 close 按钮之后 scroll 回原来的页面坐标值.
      var last_page_x = 0;
      var last_page_y = 0;

      var local_search_tips = 
            "<span class='local-search-empty'>" + "第一次搜索可能较慢, 先思考一个经典算法问题, 跳台阶:" + "</span>" +
            "<span class='local-search-empty'>" + "一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个6级的台阶总共有多少种跳法?n级呢?" + "</span>";

      function CloseLocalSearch()
      {
        first_char_flag = 0;

        $('#local-search-input').val('');
        $('#local-search-close').hide();

        // $('.local-search-result-cls ul li').velocity('stop').velocity('transition.slideDownOut', 200);

        $('#' + content_id).attr("headroom_special_attr","true"); 
        
        if (isMobile())
        {
          // $('body').scrollTop(last_page_y);  // scrollTop 有兼容性问题
          scrollTo(last_page_x, last_page_y);

          $('#' + content_id).hide();
        }
        else
        {
          $('#' + content_id).velocity('stop').velocity( 'transition.bounceUpOut', 200 );
        }

        // $('#' + content_id).velocity('stop').velocity( isMobile() ? 'transition.fadeOut' : 'transition.bounceUpOut', {
        //   // delay: isMobile() ? 50 : 0,
        //   duration: isMobile() ? 500 : 200,
        //   // begin: function() { 
        //   //   if (isMobile())
        //   //   {
        //   //     $('body').scrollTop(last_page_y);
        //   //   } 
        //   // }
        //   complete: function () {
        //     if (isMobile())
        //     {
        //       if (last_page_y < 20000)
        //       {
        //         $('body').velocity('scroll', { offset: last_page_y+"px", duration: last_page_y < 10000 ? 1000 : 2000 });
        //       }
        //       else
        //       {
        //         $('body').scrollTop(last_page_y);
        //       }
        //       // $('body').velocity('scroll');

        //       // $('html,body').animate({
        //       //   scrollTop: last_page_y
        //       // },400);
        //       // $('body').velocity('transition.slideDownIn', 1000);
        //       // $('body').velocity('scroll', { offset: last_page_y+"px", duration: document.body.scrollHeight < 20000 ? 1500 : 3000 });
        //     }
        //   }
        // });
      }

      function handleSearch()
      {
        if (keywords.length <= 0) {
          return;
        }
        $resultContent.innerHTML = "";
        $('#local-search-close').show();

        // 0x04. perform local searching
        if (is_load_xml_finished == 0)
        {
          $resultContent.innerHTML = 
            "<ul class='local-search-empty-ul'>" + 
            local_search_tips +
            ProgressBar;
        }
        else
        {
          // Retrieve the object from local storage
          var xml_resp = retrieve_search_xml()

          xml_resp.forEach(function (data) {
          // datas.forEach(function (data) {
            var isMatch = true;
            var content_index = [];
            if (!data.title || data.title.trim() === '') {
              data.title = "Untitled";
            }
            var is_encrypted = data.encrypted.trim() == '1'
            var is_sensitive = CONFIG.local_search.sensitive_word && data_content.indexOf(CONFIG.local_search.sensitive_word) >= 0
            var orig_data_title = data.title.trim();
            var data_title = orig_data_title.toLowerCase();
            var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
            var data_content = orig_data_content.toLowerCase();
            var data_url = decodeURIComponent(data.url);
            var index_title = -1;
            var index_content = -1;
            var first_occur = -1;
            // only match artiles with not empty contents
            if (data_content !== '') {
              keywords.forEach(function (keyword, i) {
                index_title = data_title.indexOf(keyword);
                index_content = (is_sensitive || is_encrypted) ? -1 : data_content.indexOf(keyword);

                if (index_title < 0 && index_content < 0) {
                  isMatch = false;
                } else {
                  if (index_content < 0) {
                    index_content = 0;
                  }
                  if (i == 0) {
                    first_occur = index_content;
                  }
                  // content_index.push({index_content:index_content, keyword_len:keyword_len});
                }
              });
            } else {
              isMatch = false;
            }
            // 0x05. show search results
            if (isMatch) {
              var content = orig_data_content;
              if (first_occur >= 0) {
                var match_content = "";
                if (!is_sensitive && !is_encrypted)
                {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  match_content = content.substr(start, end);
                }

                // highlight all keywords
                var regS = "";
                if (match_content != "")
                {
                  keywords.forEach(function (keyword) {
                    regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<b class=\"search-keyword\">" + keyword + "</b>");
                    orig_data_title = orig_data_title.replace(regS, "<b class=\"search-keyword\">" + keyword + "</b>");
                  });
                }
                else
                {
                  keywords.forEach(function (keyword) {
                    regS = new RegExp(keyword, "gi");
                    orig_data_title = orig_data_title.replace(regS, "<b class=\"search-keyword\">" + keyword + "</b>");
                  });
                }
                str += "<li><a href='" + data_url + "' class='search-result-title' target='_blank'>" + orig_data_title + "</a>";
                str += "<p class=\"search-result\">" + match_content + "...</p>"
              }
              str += "</li>";
            }
          });

          str += "</ul>";
          if (str.indexOf('<li>') === -1) {
            return $resultContent.innerHTML = 
              "<ul class='local-search-empty-ul'><span class='local-search-empty'>找不到, 换个搜索关键字试一哈.<span></ul>";
          }
          $resultContent.innerHTML = str;
        }
      }

      $input.addEventListener('input', function () {
        // 0x03. parse query to keywords list
        str = '<ul class=\"search-result-list\">';
        temp_keyword = this.value.trim();
        if (temp_keyword.length <= 0) {
          CloseLocalSearch();
          return;
        }

        keywords = temp_keyword.toLowerCase().split(/[\s\-]+/);
        handleSearch();

        // 当用户键入第一个字母的时候的动画处理逻辑 : 
        // 当 first_char_flag 为 0 的时候, 
        // 要播放一个动画
        if (first_char_flag == 0)
        {
            // $('body').scrollTop(0);
          if (isMobile())
          {
            last_page_x = window.pageXOffset;
            last_page_y = window.pageYOffset;
            // $('body').scrollTop(0);
            scrollTo(0,0);

          }
          first_char_flag = 1;
          $('#' + content_id).removeAttr("headroom_special_attr");
          
          $('#' + content_id).velocity('stop').velocity('transition.slideDownIn', 300);

          $('.local-search-result-cls ul li').velocity('stop').velocity('transition.slideDownIn', 1000);
        }
      });


      var local_search_xml_data = localStorage.getItem('local_search_xml_data');
      if (!local_search_xml_data) {
        $.ajax({
          // 0x01. load xml file
          url: path,
          dataType: "xml",
          success: function (xmlResponse) {
            store_search_xml(xmlResponse);

            // setTimeout(function(){
            //   is_load_xml_finished = 1;

            //   handleSearch();
            //   $('.local-search-result-cls ul li').velocity('stop').velocity('transition.slideDownIn', 800);
            // }, 2000);
            
            // is_load_xml_finished = 1;

            handleSearch();
            $('.local-search-result-cls ul li').velocity('stop').velocity('transition.slideDownIn', 800);
          }
        });
      }

      $(document).on('click', '#local-search-close', function() {
        CloseLocalSearch();
      });

      $(document).keyup(function(event){
        switch(event.keyCode) {
          case 27:
            // alert("ESC");
            CloseLocalSearch();
        }
      });

      // $(document).on('blur', '#local-search-input', function(e) {
      //   // console.log(document.activeElement.getAttribute('class'));
        
      //   if (isMobile() == false)
      //   {
      //     CloseLocalSearch();
      //   }
      // });
    }

    function isMobile() {
      // console.log(document.body.clientWidth);
      return document.body.clientWidth < 768

      // var userAgent = window.navigator.userAgent;

      // var isiPad = userAgent.match(/iPad/i) !== null;
      // var mobileUA = [
      //   'iphone', 'android', 'phone', 'mobile',
      //   'wap', 'netfront', 'x11', 'java', 'opera mobi',
      //   'opera mini', 'ucweb', 'windows ce', 'symbian',
      //   'symbianos', 'series', 'webos', 'sony',
      //   'blackberry', 'dopod', 'nokia', 'samsung',
      //   'palmsource', 'xda', 'pieplus', 'meizu',
      //   'midp' ,'cldc' , 'motorola', 'foma',
      //   'docomo', 'up.browser', 'up.link', 'blazer',
      //   'helio', 'hosin', 'huawei', 'novarra',
      //   'coolpad', 'webos', 'techfaith', 'palmsource',
      //   'alcatel', 'amoi', 'ktouch', 'nexian',
      //   'ericsson', 'philips', 'sagem', 'wellcom',
      //   'bunjalloo', 'maui', 'smartphone', 'iemobile',
      //   'spice', 'bird', 'zte-', 'longcos',
      //   'pantech', 'gionee', 'portalmmm', 'jig browser',
      //   'hiptop', 'benq', 'haier', '^lct',
      //   '320x320', '240x320', '176x220'
      // ];
      // var pattern = new RegExp(mobileUA.join('|'), 'i');

      // return !isiPad && userAgent.match(pattern);
    }

    function store_search_xml(xmlResponse) {
        datas = $("entry", xmlResponse).map(function () {
          return {
            title: $("title", this).text(),
            content: $("content", this).text(),
            url: $("url", this).text(),
            encrypted: $("encrypted", this).text(),
          };
        }).get();
        // Put the object into storage
        localStorage.setItem('local_search_xml_data', JSON.stringify(datas));
        is_load_xml_finished = 1;

        console.log("store search.xml finished.");
    }

    function ajax_store_search_xml() {
      $.ajax({
        url: "/search.xml",
        dataType: "xml",
        success: function (xmlResponse) {
            store_search_xml(xmlResponse);
        }
      });
    }

    function retrieve_search_xml() {
        // Retrieve the object from local storage
        var retrievedObject = localStorage.getItem('local_search_xml_data');
        var xml_resp = JSON.parse(retrievedObject)
        return xml_resp
    }

    var getSearchFile = function(){
      var path = "/search.xml";
      var local_search_result_name = isMobile() ? "local-search-result-mobile" : "local-search-result-pc";
      searchFunc(path, 'local-search-input', local_search_result_name);
    }

    var local_search_xml_data = localStorage.getItem('local_search_xml_data');
    if (local_search_xml_data) {
      is_load_xml_finished = 1;
      console.log("load search.xml finished.");
    }
    var last_use_local_search_date = localStorage.getItem('last_use_local_search_date');
    var curDate = new Date();
    // 只有在 localStorage 没有 search.xml数据或者 距离上次使用local search已经超过一天了才去取search.xml
    // 节省流量
    if (last_use_local_search_date != curDate.getDate() || !local_search_xml_data) {
      // preload search.xml
      ajax_store_search_xml();
    }

    localStorage.setItem('last_use_local_search_date', curDate.getDate());
    

  </script>





  

  

  

  

  

  


  <script type="text/javascript" src="/lib/wobble_window/wobblewindow.js"> </script>
<script type="text/javascript" src="/js/src/custom.js"></script>
</body>
</html>


<!-- 页面点击小红心 -->





<script type="text/javascript" src="/js/src/headroom.js"></script> 

<!-- 代码块复制功能 -->
<script type="text/javascript" src="/js/src/clipboard-use.js"></script>
