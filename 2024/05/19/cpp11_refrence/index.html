<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">

<script>
    (function(){
        if(''){
          // alert('此文章并不公开, 输入文章密码方可阅读');
          var password = prompt('此文章并不公开, 输入文章密码方可阅读');
          if (password !== ''){
            if (password != null) // 如果用户点击了确认而且密码错误的时候, 因为当password == null的时候说明用户点了取消
            {
              alert('Error!');
            }
            if (history.length > 1)
            {
              history.back();
            }
            else
            {
              window.location.href = "about:blank";
            }
          }
        }
    })();
</script>








<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/dist/jquery.fancybox.css?v=3.2.10" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="CPP,">








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.2">






<meta name="description" content="本文由 简悦 SimpRead 转码， 原文地址 www.zhihu.com iker 同学  . . .">
<meta name="keywords" content="CPP">
<meta property="og:type" content="article">
<meta property="og:title" content="C++11各种左右引用">
<meta property="og:url" content="https://hulinhong.com/2024/05/19/cpp11_refrence/index.html">
<meta property="og:site_name" content="烫">
<meta property="og:description" content="本文由 简悦 SimpRead 转码， 原文地址 www.zhihu.com iker 同学  . . .">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://picx.zhimg.com/v2-15990a1e06fd213fc5db8a29a0579f44_l.jpg?source=2c26e567">
<meta property="og:image" content="https://picx.zhimg.com/v2-a10e15ec0fef0b578d7bf794c4c8f6ac_r.jpg?source=2c26e567">
<meta property="og:image" content="https://picx.zhimg.com/v2-054c65836cb9dad817399a471386e154_r.jpg?source=2c26e567">
<meta property="og:updated_time" content="2024-08-28T14:45:37.052Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++11各种左右引用">
<meta name="twitter:description" content="本文由 简悦 SimpRead 转码， 原文地址 www.zhihu.com iker 同学  . . .">
<meta name="twitter:image" content="https://picx.zhimg.com/v2-15990a1e06fd213fc5db8a29a0579f44_l.jpg?source=2c26e567">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"scrollpercent":true,"onmobile":true,"dimmer":true,"body_content_height":0,"display_duration":150},
    local_search: {"enable":true,"trigger":"auto","top_n_per_article":1},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"duration":222,"transition":{"header":"slideDownIn","menu":"slideDownIn","logo":"slideDownIn","post_block_else":"slideDownIn","post_header":"fadeIn","post_body":"fadeIn","coll_header":"slideDownIn","footer":"slideDownIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>








  <title>C++11各种左右引用 | 烫</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">烫</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">烫烫烫烫烫</p>
      
  </div>

  <div class="menu-item sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <div class="menu-item site-search">
    
  
  <form class="site-search-form">
    <span class="search-icon fa fa-search"></span>
    <input type="text" id="local-search-input" class="st-search-input">
    <i id="local-search-close">×</i>
  </form>


<script type="text/javascript" id="local.search.active">
var inputArea       = document.querySelector("#local-search-input");
inputArea.onclick   = function(){ getSearchFile(); this.onclick = null }
inputArea.onkeydown = function(){ if(event.keyCode == 13) return false }
</script>



  </div>
  <div id="local-search-result-pc" class="local-search-result-cls"></div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  
  

  
    <ul id="menu" class="menu menu-left">
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

       
    </ul>
  

  
    
  
</nav>



 </div>
    </header>

    <div id="local-search-result-mobile" class="local-search-result-cls"></div>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hulinhong.com/2024/05/19/cpp11_refrence/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="no5ix">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="烫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C++11各种左右引用</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-05-19T17:42:01+00:00">
                2024-05-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CPP/" itemprop="url" rel="index">
                    <span itemprop="name">CPP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            <div class="post-tags">
              
                <a href="/tags/CPP/" rel="tag"><i class="fa fa-tag"></i> CPP</a>
              
            </div>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    




    
    
    
    <div class="post-body" itemprop="articleBody">
      
      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2024/02/27/eng_easy_english_043_immigrant_life/" rel="next" title="Easy English-043-Immigrant Life">
                <i class="fa fa-chevron-left"></i> 
                <p class="post-nav-pre-next-title">
                  Easy English-043-Immigrant Life
                </p> 
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2024/05/27/eng_dengdeng_det_notes/" rel="prev" title="Duolingo Notes">
              <p class="post-nav-pre-next-title">
                  Duolingo Notes
              </p> 
              <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      

      
      

      
        <blockquote>
<p>本文由 <a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead</a> 转码， 原文地址 <a href="https://www.zhihu.com/question/363686723/answer/2590214399" target="_blank" rel="noopener">www.zhihu.com</a> <img src="https://picx.zhimg.com/v2-15990a1e06fd213fc5db8a29a0579f44_l.jpg?source=2c26e567" alt>iker 同学</p>
</blockquote>
<p><strong>. . .</strong><a id="more"></a></p>
<p>简单来说，<strong><a href="https://www.zhihu.com/search?q=%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2590214399%7D" target="_blank" rel="noopener">右值引用</a></strong>就是这个东东, 比我们传统所了解的<a href="https://www.zhihu.com/search?q=%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2590214399%7D" target="_blank" rel="noopener">左值引用</a>多了一个 <strong>&amp;</strong> 符号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T&amp;&amp;</span><br></pre></td></tr></table></figure>
<p>老规矩，先从概念入手。拆分一下有两个概念：<strong>右值</strong> 和 <strong>引用</strong>。引用自然不必多说，先看看什么叫<strong>右值</strong>。</p>
<p>根据</p>
<p><a href="https://en.cppreference.com/w/cpp/language/value_category#cite_ref-1" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/language/value_category#cite_ref-1</a></p>
<p>现代 c++ 把表达式分为三种主要类型，每一个 c++ 表达式都可以被确切的分为以下某一类：</p>
<ol>
<li><p><strong>lvalue</strong>(左值)：</p>
</li>
<li><p><strong><a href="https://www.zhihu.com/search?q=prvalue&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2590214399%7D" target="_blank" rel="noopener">prvalue</a></strong>(pure rvalue, <a href="https://www.zhihu.com/search?q=%E7%BA%AF%E5%8F%B3%E5%80%BC&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2590214399%7D" target="_blank" rel="noopener">纯右值</a>)：</p>
</li>
<li><p><strong>xvalue</strong>(eXpiring value, 将亡值):</p>
</li>
</ol>
<p>实际上 <strong>prvalue 和 <a href="https://www.zhihu.com/search?q=xvalue&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2590214399%7D" target="_blank" rel="noopener">xvalue</a> 都属于右值</strong>。</p>
<h2 id="1-值分类"><a href="#1-值分类" class="headerlink" title="1. 值分类"></a>1. 值分类</h2><h3 id="1-1-左值（lvalue）"><a href="#1-1-左值（lvalue）" class="headerlink" title="1.1 左值（lvalue）"></a>1.1 左值（lvalue）</h3><p><strong>左值不能简单理解为就是等号左边的值，其实只要能取地址，那这个表达式就是左值。</strong>可以取地址意味着在程序的<strong>某块内存地址</strong>上已经存储了他的内容。</p>
<p>举例一些常见的左值：</p>
<ul>
<li>具名的变量名</li>
<li>左值引用</li>
<li><strong>右值引用也是左值</strong></li>
<li>返回左值引用的函数或是操作符重载的调用语句。</li>
<li>a=b, a+=b, 等内置的赋值表达式。</li>
<li><strong>前缀自增</strong>。如 ++a, –a 是左值。</li>
<li><strong>字符串常量</strong></li>
<li>左值引用的类型转换语句。如 <a href="https://www.zhihu.com/search?q=static_cast&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2590214399%7D" target="_blank" rel="noopener">static_cast</a><int&>(x)</int&></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure>
<p>这里 a 是左值，因为 a 这个变量确实被存到内存里了，并且在内存里面写入的值是 1. 同理，str 也是左值。</p>
<p>那<strong>数字常量 1</strong> 是左值吗？并不是，1 是在运行到这行代码是，临时产生的一个值，他是没有地址的, 仅仅存在<strong>寄存器</strong>中用作临时运算。所以数字常量 1 不是左值。</p>
<p>那么 “hello” 这个字符串常量，请问他是左值还是右值? 按照惯性思维，既然前面的数字常量 1 都不是左值，那这里字符串常量是不是也不是左值？</p>
<p>然而事实上， <strong>“hello” 这个字符串常量实实在在的是左值</strong>，原因如下：</p>
<p>简单来说，编译的时候， hello 这个字符串会真的被单独的存放在某一内存地址上存储，一般是<strong>静态数据区</strong>。所以你直接对 hello 这个字符串常量 取地址（&amp;），是完全可以取到的。能取到地址说明他就是个左值。</p>
<p>而为什么要特意把字符串常量存放在<strong>静态数据区</strong>呢？思考一下，当要赋值 hello 字符串给某个变量的时候。 hello 这个字符串从哪里来呢呢？运行时再让寄存器构造一个 hello 的值吗。这显然不是高效的做法。既然编译的时候我就知道了程序总共用到了哪些字符串常量，我提前把所有的字符串常量都放在某块内存地址上，用到的时候再从这里拷贝就好了。况且如果是字符串常量重复使用的话，还可以节省效率。</p>
<p>总之，我们知道<strong>只要能取得地址，那就说明是左值</strong>。因为能取地址，那么我们就能修改它的值 (理论上都能修改，只是比如字符串常量一般是不能修改的)，所以左值是能放在等号左边的，我们能给左值进行赋值。</p>
<p>引出几个问题： <strong>左值一定能赋值？</strong></p>
<p>不是， 字符串常量是左值，但不能修改其值。</p>
<p>左值一定能取地址？ 是的。</p>
<h3 id="1-2-纯右值（prvalue）"><a href="#1-2-纯右值（prvalue）" class="headerlink" title="1.2 纯右值（prvalue）"></a>1.2 纯右值（prvalue）</h3><p><strong>prvalue</strong> 是纯右值，他是属于右值的一种。</p>
<p><strong>右值是临时产生的值，不能对右值取地址，因为它本身就没存在内存地址空间上。</strong></p>
<p>举例纯右值如下：</p>
<ul>
<li>除字符串以外的常量，如 1，true，nullptr</li>
<li>返回非引用的函数或操作符重载的调用语句。</li>
<li>a++, a– 是右值</li>
<li>a+b, a &lt;&lt; b 等</li>
<li>&amp;a，对变量取地址的表达式是右值。</li>
<li>this 指针</li>
<li>lambda 表达式</li>
</ul>
<p>理解也很简单，其实就是一些运算时的中间值，这些值只存在寄存器中辅助运算，不会实际写到内存地址空间中，因此也无法对他们取地址。</p>
<h3 id="1-3-将亡值（xvalue）"><a href="#1-3-将亡值（xvalue）" class="headerlink" title="1.3 将亡值（xvalue）"></a>1.3 将亡值（xvalue）</h3><p><strong>xvalue</strong> 叫将亡值，顾名思义，就是即将销毁的东西。<strong>xvalue</strong> 也是<strong>右值</strong>的一种。</p>
<p>主要记住这两种就行了：</p>
<ul>
<li>返回<strong>右值引用</strong>的函数或者操作符重载的调用表达式。如某个函数返回值是 <strong>std::move(x),</strong> 并且函数返回类型是 <strong>T&amp;&amp;</strong></li>
<li>目标为<strong>右值引用</strong>的类型转换表达式。如 <strong>static<int&&>(a)</int&&></strong></li>
</ul>
<p><strong>xvalue</strong> 和 <strong>prvalue</strong> 都是属于右值，你不必对它们过度的区分。</p>
<h2 id="2-左值引用和右值引用"><a href="#2-左值引用和右值引用" class="headerlink" title="2. 左值引用和右值引用"></a>2. 左值引用和右值引用</h2><p>说了这么多，其实没必要去真的纠结哪些是左值，哪些是右值。心里有点数能区分常见的就行了。右值引用才是重点。先复习一下左值引用。</p>
<h3 id="2-1-左值引用"><a href="#2-1-左值引用" class="headerlink" title="2.1 左值引用"></a>2.1 左值引用</h3><p>左值引用是我们很熟悉的老朋友了，左值引用可以分为两种：<strong>非 const 左值引用</strong> 和 <strong><a href="https://www.zhihu.com/search?q=const%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2590214399%7D" target="_blank" rel="noopener">const 左值引用</a></strong>。</p>
<p>有很重要的一点是，<strong>非 const 左值引用只能绑定左值；const 左值引用既能绑定左值，又能绑定右值！</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">int&amp; lref_a = a;</span><br><span class="line">lref_a ++; // 通过非 const 左值引用可以修改其值</span><br><span class="line">const int&amp; lref_const_a = a;</span><br><span class="line">// lref_const_a++; // error, const左值引用不能修改其值</span><br><span class="line"></span><br><span class="line">const int&amp; lref_const_rvalue = 999;  // const 左值引用可以直接绑定右值 999 </span><br><span class="line">cout &lt;&lt; &quot;lref_const_rvalue = &quot; &lt;&lt; lref_const_rvalue;</span><br></pre></td></tr></table></figure>
<p>可以看到，lref_const_rvalue 是 const 左值引用，但是他直接绑定到一个右值（数字常量 999）上了。有没有想过为什么 c++ 要这么设计呢？</p>
<p>举个例子，你要设计 print 方法。如何设计 print 方法的参数呢？</p>
<p>首先，考虑到值传递参数会产生额外的拷贝，这是难以接受的。于是你想到了<strong><a href="https://www.zhihu.com/search?q=%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2590214399%7D" target="_blank" rel="noopener">引用传递</a></strong>（你要用指针？那这篇文章不用看了。。。）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void print(int&amp; a);</span><br></pre></td></tr></table></figure>
<p>于是添加数据需要这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">print(a);</span><br></pre></td></tr></table></figure>
<p>好像有点麻烦，有时候你只需要添加一个常量（数字常量就是右值）进去，你还有首先声明一个变量，有点麻烦，如果能直接这样添加就好了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(1);</span><br></pre></td></tr></table></figure>
<p>也就是说，无论入参是<strong>左值</strong>和<strong>右值</strong>，push 函数都能正常接收。于是，用 <strong>const 左值引用</strong> 可以解决这个问题。实际上不知不觉中我们很多代码都用到了这种参数形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void print(const int&amp; a);</span><br></pre></td></tr></table></figure>
<p>然后就只可以直接 print(1) 了。当然，<strong>由于是 const 左值引用，因此你无法修改其值。只可读不可写。</strong></p>
<p>ok, 左值引用掌握到这种程度就可以了。接下来是右值引用。</p>
<h3 id="2-2-右值引用"><a href="#2-2-右值引用" class="headerlink" title="2.2 右值引用"></a>2.2 右值引用</h3><p>不像左值引用那么麻烦，<strong>右值引用只能绑定到右值</strong>上。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int b = 2;</span><br><span class="line">// int&amp;&amp; rref_b = b; // error,右值引用只能绑定到右值上，b是一个左值</span><br><span class="line">int&amp;&amp; rref_2 = 2; // ok</span><br><span class="line">cout &lt;&lt; &quot;rref_2=&quot; &lt;&lt; rref_2 &lt;&lt; endl;  // 输出 2</span><br><span class="line">rref_2++;</span><br><span class="line">cout &lt;&lt; &quot;rref_2=&quot; &lt;&lt; rref_2 &lt;&lt; endl;  // 输出 3</span><br></pre></td></tr></table></figure>
<h3 id="2-3-move-语义"><a href="#2-3-move-语义" class="headerlink" title="2.3 move 语义"></a>2.3 move 语义</h3><p>那如果是一个<strong>左值</strong>，我们有办法把它标记为<strong>右值</strong>吗。可以，使用 <strong>move</strong> 语义。</p>
<p><strong>std::move</strong> 也是随着右值引用诞生的重要语法。move 这个词看上去像是做了资源的移动，其实真的吗？并不是。 <strong>move</strong> 唯一做的事情其实就是个<strong>类型转换</strong>。如 cppreference 原文：</p>
<blockquote>
<p>In particular, std::move produces an xvalue expression that identifies its argument t. It is exactly equivalent to a static_cast to an rvalue reference type.</p>
</blockquote>
<p>翻译过来就是：move(x) 产生一个将亡值 (<strong>xvalue</strong>) 表达式来标识其参数 x。他就完全等同于 <strong>static_cast<t&&>(x)。</t&&></strong></p>
<p>所以说，<strong>move 并不作任何的资源转移操作。单纯的 move(x) 不会有任何的性能提升，不会有任何的资源转移。</strong>它的作用仅仅是产生一个标识 x 的右值表达式。</p>
<p>而经过 <strong>move</strong> 之后，就能用<strong>右值引用</strong>将其绑定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int b = 2;</span><br><span class="line">// int&amp;&amp; rref_b = b; // error,右值引用只能绑定到右值上，b是一个左值</span><br><span class="line">int&amp;&amp; rref_b = std::move(b); // ok, std::move(b) 是一个右值，可以用右值引用绑定</span><br></pre></td></tr></table></figure>
<h3 id="2-3-函数重载"><a href="#2-3-函数重载" class="headerlink" title="2.3 函数重载"></a>2.3 函数重载</h3><p>到这里，你会发现<strong>右值引用</strong>以及 <strong>move</strong> 好像都也没什么用, 凸显不出它跟左值引用有什么特殊点。其他它们主要用在函数参数中。以下是摘自 cppreference 的一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void f(int&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;lvalue reference overload f(&quot; &lt;&lt; x &lt;&lt; &quot;)\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void f(const int&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;lvalue reference to const overload f(&quot; &lt;&lt; x &lt;&lt; &quot;)\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void f(int&amp;&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;rvalue reference overload f(&quot; &lt;&lt; x &lt;&lt; &quot;)\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i = 1;</span><br><span class="line">    const int ci = 2;</span><br><span class="line">    f(i);  // calls f(int&amp;)</span><br><span class="line">    f(ci); // calls f(const int&amp;)</span><br><span class="line">    f(3);  // calls f(int&amp;&amp;)</span><br><span class="line">           // would call f(const int&amp;) if f(int&amp;&amp;) overload wasn&apos;t provided</span><br><span class="line">    f(std::move(i)); // calls f(int&amp;&amp;)</span><br><span class="line"></span><br><span class="line">    // rvalue reference variables are lvalues when used in expressions</span><br><span class="line">    int&amp;&amp; x = 1;</span><br><span class="line">    f(x);            // calls f(int&amp; x)</span><br><span class="line">    f(std::move(x)); // calls f(int&amp;&amp; x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当函数参数既有左值引用重载，又有右值引用重载的时候, 我们得到重载规则如下:</p>
<ul>
<li>若传入参数是<strong>非 const 左值</strong>，调用<strong>非 const 左值引用</strong>重载函数</li>
<li>若传入参数是 <strong>const 左值</strong>，调用 <strong>const 左值引用</strong>重载函数</li>
<li>若传入参数是<strong>右值</strong>，调用<strong>右值引用重载函数</strong> (即使是有 const 左值引用重载的情况下)</li>
</ul>
<p>因此，f(3) 和 f(std::move(i)) 会调用 f(int&amp;&amp;), 因为他们提供的入参都是<strong>右值</strong>。</p>
<p>所以，通过 move 语义 和 右值引用的配合，我们能提供右值引用的重载函数。这给我们一个机会，一个可以利用右值的机会。特别是对于 <strong>xvalue（将亡值）</strong>来说，他们都是即将销毁的资源，如果我们能最大程度利用这些资源的话，这显然会极大的增加效率、节省空间。</p>
<h3 id="2-4-实现真正的资源转移"><a href="#2-4-实现真正的资源转移" class="headerlink" title="2.4 实现真正的资源转移"></a>2.4 实现真正的资源转移</h3><p>前面说过，<strong>单纯的 move 不会有任何的资源转移</strong>，那么到底资源是在哪里转移的呢？</p>
<p>考虑一个很简单的 <strong>string</strong> 类，我们提供简单的 <strong>构造函数</strong> 和 <strong><a href="https://www.zhihu.com/search?q=%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2590214399%7D" target="_blank" rel="noopener">拷贝构造函数</a></strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class string &#123;</span><br><span class="line">  string(const char* a, length) &#123;</span><br><span class="line">    m_length = length;</span><br><span class="line">    m_ptr = malloc(m_length);</span><br><span class="line">    memcpy(a, mptr, length);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  string(const string&amp; b) &#123;</span><br><span class="line">    m_length = b.m_length;</span><br><span class="line">    m_ptr = malloc(m_length);</span><br><span class="line">    memcpy(m_ptr, b.m_ptr, b.length);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  char* m_ptr;</span><br><span class="line">  int m_length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意，由于 m_ptr 是个指针，需要在<strong>堆</strong>上申请内存空间存放实际的字符串。因此在实现拷贝构造函数的时候，必须要<strong>深拷贝</strong>，即重新申请内存空间，并且将其内存数据使用 memcpy 拷贝过来。</p>
<p>当向一个数组里面添加 string 元素时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">tmeplate&lt;T&gt;</span><br><span class="line">class vector&lt;T&gt; &#123;</span><br><span class="line">  void push(const T&amp; v) &#123;</span><br><span class="line">    // 调用拷贝构造函数复制对象副本</span><br><span class="line">    T a(v);</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void fun() &#123;</span><br><span class="line">  vector&lt;string&gt; list;</span><br><span class="line">  string a(&quot;hello world&quot;, 11);</span><br><span class="line"></span><br><span class="line">  // 这里会调用拷贝构造函数, 将 a 对象拷贝一份，vector 再把这个副本添加到 vector 中</span><br><span class="line">  list.push(a);</span><br><span class="line"></span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当调用 push 方法时，由于入参是左值，因此调用到了函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void push(const string&amp; v) &#123;</span><br><span class="line">  // 调用拷贝构造函数复制对象副本</span><br><span class="line">  string tmp(v);</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数里面此处调用了拷贝构造函数，将对象 a 完全拷贝了一份到临时对象 tmp 中，再把对象 v 放入到 vector 中。</p>
<p>如图所示：</p>
<p><img src="https://picx.zhimg.com/v2-a10e15ec0fef0b578d7bf794c4c8f6ac_r.jpg?source=2c26e567" alt></p>
<p>然而实际上我们可以看出来，fun 函数中 <strong>a</strong> 这个对象已经没用了，出了作用域就被析构掉了。有没有办法能<strong>把 a 对象的资源移动，而不是重新拷贝一份</strong>呢。这样就能节省很多资源，最大化提高利用率。</p>
<p>有两个问题：</p>
<ol>
<li>push 函数如何通过入参来区分对象是应该<strong>拷贝资源</strong>还是应该<strong>移动资源</strong></li>
<li>如何用已有的 string 对象通过资源转移构造出另一个 string，而不是调用拷贝构造函数</li>
</ol>
<p>先思考问题 1，事实上我们知道<strong>右值</strong>可以用来标识对象即将要销毁，因为他是临时值，只要 push 能区分入参是左值还是右值就知道应该拷贝还是移动了。然而 <strong>const T&amp;</strong> 这种形参既能接收左值，又能接收右值。</p>
<p>因此需要为 push 函数提供<strong>右值引用的重载</strong>，根据调用规则，<strong>右值会优先调用到右值引用</strong>参数的函数 (注意优先级比 const T&amp; 高)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// const 左值引用</span><br><span class="line">void push_back(const string&amp; v) &#123;</span><br><span class="line">  string a(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 右值引用重载版本</span><br><span class="line">void push(string&amp;&amp; v) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如何调用到这个右值引用重载的版本呢，答案是使用 <strong>move</strong> 。 std::move(a) 产生一个将亡值，将亡值的含义就代表这个变量将要销毁，不应该在使用。注意，move 本身只相当于一个类型转换，而并未对变量做什么移动操作。所以<strong>实际上你仍然可以使用 move 后的变量，但这是<a href="https://www.zhihu.com/search?q=%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2590214399%7D" target="_blank" rel="noopener">未定义行为</a>。</strong></p>
<p>然后思考问题 2. 既然不能拷贝，那么需要确保不能调用到拷贝构造函数, 而是<strong>一种新的构造函数</strong>，<strong>这个函数能够通过转移旧对象的资源去构造新对象。</strong></p>
<p>使用<strong>右值引用作为参数</strong>来重载构造函数能很好解决这个问题，于是在 string 类里面新增加了函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string(string&amp;&amp; b) &#123;</span><br><span class="line">  m_length = b.m_length;</span><br><span class="line">  m_ptr = b.m_ptr;</span><br><span class="line">  b.m_ptr = nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是的，这个函数叫做 <strong>移动构造函数</strong>。它的参数是<strong>右值引用</strong>，并且从实现中可以看到，并没有像拷贝构造函数那样重新调用 malloc 申请资源，而是直接用了另一个对象的<strong>堆上的资源</strong>。<strong>也就是在移动构造函数中，才真正完成了资源的转移。</strong></p>
<p>根据前面左右引用函数重载的规则，要想调用移动构造函数，那么必须<strong>传入参数为右值</strong>才行。使用 <strong>move</strong> 可以将左值转换为右值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string a(&quot;hello world&quot;, 11);</span><br><span class="line">// 这里会调用到移动构造函数</span><br><span class="line">string b(std::move(a));</span><br></pre></td></tr></table></figure>
<p>这里通过移动构造函数将对象 a 资源移动到对象 b 中，如下图所示：</p>
<p><img src="https://picx.zhimg.com/v2-054c65836cb9dad817399a471386e154_r.jpg?source=2c26e567" alt></p>
<p>还没完，看前面的代码，我们调用的是 vector 的 push 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string a(&quot;hello world&quot;, 11);</span><br><span class="line">list.push(a);</span><br></pre></td></tr></table></figure>
<p>而此时我想要通过 string 的移动构造函数来转移 a 对象的资源，还需要完善右值引用重载的 push 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 右值引用重载版本</span><br><span class="line">void push(string&amp;&amp; v) &#123;</span><br><span class="line">  // 调用 移动构造函数</span><br><span class="line">  string a(std::move(v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意必须要加 <strong>move</strong>。<strong>因为 v 虽然是右值引用，但是他是个左值（</strong>参考前面所说，具有名字的右值引用是一个左值<strong>）。</strong>如果没有 move, 那么入参是个左值，将会调用拷贝构造函数。</p>
<p>当我们传入<strong>右值</strong>时，如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string a(&quot;hello world&quot;, 11);</span><br><span class="line">list.push(std::move(a));</span><br></pre></td></tr></table></figure>
<p>此时优先匹配到函数 push(string&amp;&amp; v)， 自然就调用<strong>移动构造函数</strong>了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void push(string&amp;&amp; v);</span><br></pre></td></tr></table></figure>
<p>以上只介绍了<strong>移动构造函数</strong>，实际上还有<strong>移动赋值运算重载</strong>，本质是一样的，不再另说。</p>
<p>当然，STL 标准库的 <strong>vector</strong> 容器已经提供了<strong>右值引用</strong>的 <strong>push_back</strong> 重载，可以用如下代码测试上面的结论：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line"> public:</span><br><span class="line">  A() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;A::A()&quot; &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~A() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;A::~A()&quot; &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  A(const A&amp; a) &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;A::A(const A&amp; a)&quot; &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  A(A&amp;&amp; a) &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;A::A(A&amp;&amp; a)&quot; &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  int a &#123;1&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line"></span><br><span class="line">  A a;</span><br><span class="line">  std::vector&lt;A&gt; list;</span><br><span class="line">  list.push_back(a);</span><br><span class="line">  // list.push_back(std::move(a));</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总之，除了标准库提供的类型，如 string 等。我们自定义类的移动资源操作都需要自己通过编写移动构造函数来实现。</p>
<h3 id="2-5-什么时候应该实现移动构造函数？"><a href="#2-5-什么时候应该实现移动构造函数？" class="headerlink" title="2.5 什么时候应该实现移动构造函数？"></a>2.5 什么时候应该实现移动构造函数？</h3><p>先看上面 string 的<strong>拷贝构造</strong>函数和<strong>移动构造</strong>函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 拷贝构造函数</span><br><span class="line">string(const string&amp; b) &#123;</span><br><span class="line">  m_length = b.m_length;</span><br><span class="line">  m_ptr = malloc(m_length);</span><br><span class="line">  memcpy(b.m_ptr, m_ptr, b.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 移动构造函数</span><br><span class="line">string(string&amp;&amp; b) &#123;</span><br><span class="line">  m_length = b.m_length;</span><br><span class="line">  m_ptr = b.m_ptr;</span><br><span class="line">  b.m_ptr = nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，移动构造函数对比拷贝构造函数而言，<strong>大多数地方都是相同的复制操作</strong>。其实只要是栈上的资源，都是采用<strong>复制</strong>的方式。而<strong>只有堆上的资源，才能复用旧的对象的资源。</strong></p>
<p>为什么<strong>栈上</strong>的资源不能复用，而要重新复制一份？因为你不知道旧的对象何时析构，<strong>旧的对象一旦析构，其栈上所占用的资源也会完全被销毁掉，新的对象如果复用的这些资源就会产生崩溃。</strong></p>
<p>为什么<strong>堆上</strong>的资源可以复用，因为<strong>堆上的资源不会自动释放</strong>，除非你手动去释放资源。</p>
<p>可以看到，在移动构造函数特意将旧对象的 <strong>m_ptr</strong> 指针置为 <strong>null</strong>，就是为了预防外面对其进行 <strong>delete 释放资源。</strong></p>
<p>所以说，只有当你的类<strong>申请到了堆上的内存资源</strong>的时候，才需要专门实现<strong>移动构造函数</strong>，否则其实没有必要，因为<strong>他的消耗跟拷贝构造函数是一模一样的。</strong></p>
<p>举个例子，如果类成员中有 <strong>std::string</strong>，那么自己实现<strong>移动构造</strong>函数是合理的，因为 string 里面存在<strong>堆上</strong>的资源。反之，如果类成员全是一些 <strong>int</strong> 变量，那就没必要额外去实现移动构造函数，即使你写了也会发现跟拷贝构造函数是一模一样的。</p>
<h3 id="2-6-万能引用与完美转发"><a href="#2-6-万能引用与完美转发" class="headerlink" title="2.6 万能引用与完美转发"></a>2.6 万能引用与完美转发</h3><p>先要了解一下前置知识：<strong>引用折叠</strong>。</p>
<p>利用 <strong>模板</strong> 或 <strong>typedef</strong>，允许出现<strong>引用的引用</strong>。这些引用会按照一定的规则最终折叠起来：</p>
<ol>
<li><strong>右值引用的右值引用</strong>折叠为<strong>右值引用</strong></li>
<li>其他所有类型折叠为<strong>左值引用</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef int&amp;  lref;</span><br><span class="line">typedef int&amp;&amp; rref;</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">lref&amp;  r1 = n; // type of r1 is int&amp;</span><br><span class="line">lref&amp;&amp; r2 = n; // type of r2 is int&amp;</span><br><span class="line">rref&amp;  r3 = n; // type of r3 is int&amp;</span><br><span class="line">rref&amp;&amp; r4 = 1; // type of r4 is int&amp;&amp;</span><br></pre></td></tr></table></figure>
<p><strong>万能引用</strong>：万能引用又被叫做<strong>转发引用</strong>，<strong>他既可能是左值引用，又可能是右值引用。</strong> 当满足以下两种情况时，此时属于万能引用：</p>
<ol>
<li>函数参数是 <strong>T&amp;&amp;</strong>, 且 <strong>T 是这个函数模板的模板类型</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">int f(T&amp;&amp; x)                      // x is a forwarding reference</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>auto&amp;&amp;</strong>，并且不能是由<a href="https://www.zhihu.com/search?q=%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2590214399%7D" target="_blank" rel="noopener">初始化列表</a>推断出来。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto&amp;&amp; vec = foo();</span><br></pre></td></tr></table></figure>
<p>我们暂时只关注<strong>模板参数</strong>这种情况。为什么说他是万能引用，是因为它<strong>同时支持左值和右值入参</strong>。</p>
<p>当我们<strong>入参传入左值时，他就是个左值引用</strong>；当我们<strong>入参传入右值时，他就是个右值引用</strong>。通过这个规则，我们可以进而推断出 <strong>T</strong> 的类型, 以 <strong>string</strong> 为模板为例:</p>
<ul>
<li>假设入参是一个 <strong>string 左值</strong>: 此时 <strong>T&amp;&amp;</strong> 应该等同于 <strong>string&amp;</strong>, 根据引用折叠的规则，T 应该是一个左值引用，于是得到 <strong>T 为 string&amp;</strong>，即非 const 左值引用</li>
<li>假设入参是一个 <strong>const string 左值</strong>： 此时 <strong>T&amp;&amp;</strong> 等同于 <strong>const string&amp;</strong>，得到 <strong>T 为 const string &amp;</strong>，即 const 左值引用。</li>
<li>假设入参是<strong>右值</strong>，如 <strong>move（string）</strong>： 此时 <strong>T&amp;&amp;</strong> 等同于 <strong>string&amp;&amp;</strong>， 于是得到 T 为 <strong>string&amp;&amp;</strong>，即右值引用。</li>
</ul>
<p>我们再思考另外一个问题，当需要在 f 函数中调用其他函数，并且转发参数的时候，例如调用之前讲的 push 函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">int f(T&amp;&amp; x) &#123;</span><br><span class="line">  push(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接 <strong>push(x)</strong> 吗？ 好像不对。由于这里是万能引用，传进来的入参有可能是个左值，有可能是一个右值。然而<strong>形参 x 一定是一个左值</strong>，因为他是个具名的对象。<strong>直接 push(x) 的话，就相当于入参传递的一定是左值了。</strong></p>
<p>也就是说，<strong>不论我们实际入参是左值还是右值，最后都会被当做左值来转发。</strong>即我们丢失了它本身的值类型。有没有办法能仍然保留其值属性？左值就按照左值转发，右值按照右值转发？</p>
<p>有的，完美转发 <strong>std::forward</strong> 就派上用场了。它的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt; class T &gt;</span><br><span class="line">T&amp;&amp; forward( typename std::remove_reference&lt;T&gt;::type&amp; t ) noexcept;</span><br></pre></td></tr></table></figure>
<p>在转发时，只需要这样做就行了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">int f(T&amp;&amp; x) &#123;</span><br><span class="line">  push(std::forward&lt;T&gt;(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是迷惑为什么它能实现完美转发？很简单，注意观察 <strong>std::forward</strong> 的返回值是什么，是 <strong>T&amp;&amp;</strong>。 根据前面推断模板类型 T 的过程：</p>
<ul>
<li>若入参是 <strong>string 左值</strong>，则 T 为 <strong>string&amp;</strong>. 那么 <strong>T&amp;&amp; = string&amp; &amp;&amp; = string&amp;</strong>. 也就是等同于 <strong>push(string&amp;)</strong> , 自然就会调用到<strong>左值引用重载</strong>去。</li>
<li>若入参是 <strong>const string 左值</strong>，<strong>T 为 const string&amp;</strong>, 同理得到 <strong>push(const string&amp;)</strong>, 优先匹配 const 左值引用重载。</li>
<li>若入参是 <strong>string 右值</strong>，<strong>T 为 string&amp;&amp;, T&amp;&amp; = string&amp;&amp; &amp;&amp; = string&amp;&amp;</strong>; 得到 <strong>push(string&amp;&amp;)</strong>, 调用右值引用重载。</li>
</ul>
<p>可以看到，<strong>forward</strong> 让完美的保留了参数的值类型，<strong>左值就按照左值转发，右值按照右值转发</strong>。这也是为什么他可以叫做完美转发。</p>
<h3 id="2-7-copy-elision"><a href="#2-7-copy-elision" class="headerlink" title="2.7 copy elision"></a>2.7 copy elision</h3><p><strong>copy elision</strong> 直译过来就是拷贝省略, 简单来说就是在某些情况下，编译器会智能的省略拷贝操作，实现<strong><a href="https://www.zhihu.com/search?q=%E9%9B%B6%E6%8B%B7%E8%B4%9D&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2590214399%7D" target="_blank" rel="noopener">零拷贝</a></strong>，从而提升效率。</p>
<p>为什么在这里提及 <strong>copy elision</strong>, 它本身与右值引用毫无关系. 但我见过很多误区，一些自以为是的写法导致实际减低了程序的性能。</p>
<p>主要是以下几种情况：</p>
<p>case1: 在函数 <strong>return</strong> 语句中，返回的操作数是一个与函数返回类型（忽略 const ）相同的 <strong>prvalue</strong> 值，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">T f()</span><br><span class="line">&#123;</span><br><span class="line">  return T();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 只会调用一次构造函数</span><br><span class="line">T a = f();</span><br></pre></td></tr></table></figure>
<p>在这种情况下，编译器<strong>不会调用的拷贝构造函数或是移动构造函数</strong>，而是直接使用这个临时变量。<strong>整个过程只会调用一次构造函数，没有任何拷贝。</strong>这个优化过程叫做 <strong>Return Value Optimization(RVO)</strong>.</p>
<p>另外这种情况也会 <strong>copy elision</strong>：在初始化一个对象时，如果初始化表达式是一个与类类型相同（忽略 const）的 <strong>prvalue</strong> , 如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 只会调用一次构造函数</span><br><span class="line">T a = T(T(f()));</span><br></pre></td></tr></table></figure>
<p>需要注意的是, <strong>RVO</strong> 在 <strong>c++11 是可选的</strong>（<strong>非必须</strong>，编译器自行决定是否使用），但在 <strong>c++17 之后会变成必须的。</strong></p>
<p>case2: 函数 <strong>return</strong> 语句中，返回的操作数是一个与返回类型相同的（忽略 const）<strong>非 volatile 对象</strong>，并且不是函数参数。这个优化叫 <strong>Named Return Value Optimization(NRVO)</strong>. <strong>NRVO 是可选的</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A g() &#123;</span><br><span class="line">  A a;</span><br><span class="line">  return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<strong>RVO 和 NRVO 都是省略了拷贝的过程</strong>，直接复用临时对象。这无疑是一种优化。然而一些自以为是的错误写法可能会导致 <strong>RVO</strong> 和 <strong>NRVO 无法实施</strong>，从而反而<strong>降低</strong>了性能. 例如，以下这几种情况都会降低性能：</p>
<p>case1: <strong>返回 std::move，并且函数返回类型是值类型</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A f() &#123;</span><br><span class="line">  A a;</span><br><span class="line">  return std::move(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一种非常典型的<strong>错误</strong>写法，<strong>由于返回返回类型与 return 的操作数的类型不一致，NRVO 无法实施</strong>，从而进行了<strong>拷贝</strong>。不论是拷贝构造还是移动构造都降低了性能。</p>
<p>case2: <strong>返回 std::move，且函数返回类型是右值引用</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A&amp;&amp; f() &#123;</span><br><span class="line">  A a;</span><br><span class="line">  return std::move(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种情况倒是不会产生拷贝，但<strong>返回了局部对象的引用</strong>，会<strong>导致运行时错误</strong>。如果返回的是<strong>左值引用</strong>，一样的道理。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://en.cppreference.com/" target="_blank" rel="noopener">https://en.cppreference.com/</a></p>

      


      

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/CPP/" rel="tag"><i class="fa fa-tag"></i> CPP</a>
            
          </div>
        

        
        
        

        
          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2024/02/27/eng_easy_english_043_immigrant_life/" rel="next" title="Easy English-043-Immigrant Life">
                  <i class="fa fa-chevron-left"></i> 
                  <p class="post-nav-pre-next-title">
                    Easy English-043-Immigrant Life
                  </p> 
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2024/05/27/eng_dengdeng_det_notes/" rel="prev" title="Duolingo Notes">
                <p class="post-nav-pre-next-title">
                    Duolingo Notes
                </p> 
                <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        

        
        
      </footer>
      
    </div>
    
    
    

    

    

    

  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  

  <aside id="sidebar" class="sidebar">

    
      
        <div id="sidebar-dimmer"></div>
      
    

    <div class="sidebar-inner">
    
      <div class="sidebar-toggle-inside motion-element">
        <div class="sidebar-toggle-line-wrap">
          <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
          <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
          <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
        </div>
      </div>

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a href="/" class="site-author-image" rel="start" style="border:none">
            <img class="site-author-image" itemprop="image" src="/uploads/avatar.png" alt="no5ix">
          </a>
          <p class="site-author-name" itemprop="name">no5ix</p>
           
              <p class="site-description motion-element" itemprop="description">推荐使用Chrome/Firefox/Safari阅读本博客. 以前的老笔记将会一篇一篇慢慢整理为博客, 这既启发了他人, 也锻炼了自己的描述交流能力.</p>
          
        </div>

        <nav class="site-state motion-element">

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">263</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">97</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

          <div class="site-state-item site-state-about">
            <a href="/about/">
              <span class="site-state-item-about fa fa-fw fa-user"></span>
              <span class="site-state-item-name">关于</span>
            </a>
          </div>
          
        </nav>

        

        <div class="links-of-author motion-element">
          
          
          <!-- 网易云音乐 -->
            <!-- <div class="netease-cloud-music"> -->
              <!-- <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=280 height=110 src="//music.163.com/outchain/player?type=0&id=992743594&auto=0&height=90"></iframe> -->
            <!-- </div> -->
          <!-- 网易云音乐 -->

        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-block">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://119.23.17.57" title="ksun的博客" target="_blank">ksun的博客</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://mp.weixin.qq.com/mp/homepage?__biz=MzU3MTUyNzg0NQ==&hid=1&sn=7a3ae61b7af714f75d68e7ae826a2d2c&scene=18#wechat_redirect" title="你有图么我有故事" target="_blank">你有图么我有故事</a>
                </li>
              
            </ul>
          </div>
        

        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-值分类"><span class="nav-number">1.</span> <span class="nav-text">1. 值分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-左值（lvalue）"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 左值（lvalue）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-纯右值（prvalue）"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 纯右值（prvalue）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-将亡值（xvalue）"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 将亡值（xvalue）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-左值引用和右值引用"><span class="nav-number">2.</span> <span class="nav-text">2. 左值引用和右值引用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-左值引用"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 左值引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-右值引用"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 右值引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-move-语义"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 move 语义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-函数重载"><span class="nav-number">2.4.</span> <span class="nav-text">2.3 函数重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-实现真正的资源转移"><span class="nav-number">2.5.</span> <span class="nav-text">2.4 实现真正的资源转移</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-什么时候应该实现移动构造函数？"><span class="nav-number">2.6.</span> <span class="nav-text">2.5 什么时候应该实现移动构造函数？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-万能引用与完美转发"><span class="nav-number">2.7.</span> <span class="nav-text">2.6 万能引用与完美转发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-copy-elision"><span class="nav-number">2.8.</span> <span class="nav-text">2.7 copy elision</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考文献"><span class="nav-number">3.</span> <span class="nav-text">参考文献</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2013 - 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">no5ix</span>
</div>



        

        
      </div>
    </footer>

    <!--
    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      
        <span id="scrollpercent"><span>0</span>%</span>
      
    </div>
    -->

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/dist/jquery.fancybox.js?v=3.2.10"></script>


  




  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>


  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  

  <script type="text/javascript">

    var is_load_xml_finished = 0;

    var searchFunc = function (path, search_id, content_id) {
      // 0x00. environment initialization
      'use strict';

      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      // var datas = [];

      /* loading css1 : Dot Css Loader*/
      var DotLoader = "<div class='loader'>Loading...</div>";

      /* loading css2 : Pure Css Loader - Square */
      var SquareLoader = 
        "<div class='loader'>" +
          "<div class='square' ></div>" +
          "<div class='square'></div>" +
          "<div class='square last'></div>" +
          "<div class='square clear'></div>" +
          "<div class='square'></div>" +
          "<div class='square last'></div>" +
          "<div class='square clear'></div>" +
          "<div class='square '></div>" +
          "<div class='square last'></div>" +
        "</div>";

      var ProgressBar = 
          "<div class='progress-bar'>" +
            "<div class='progress-bar-charge'></div>" +
          "</div>";

      var str = "";
      var keywords = [];
      var temp_keyword = "";

      // 是否为第一个字母被键入的标志位
      var first_char_flag = 0;

      // 因为在移动设备上, 点击搜索之后会 scroll 到页面顶部, 所以需要记录之前的页面x, y坐标值, 以便于搜索完点击 close 按钮之后 scroll 回原来的页面坐标值.
      var last_page_x = 0;
      var last_page_y = 0;

      var local_search_tips = 
            "<span class='local-search-empty'>" + "第一次搜索可能较慢, 先思考一个经典算法问题, 跳台阶:" + "</span>" +
            "<span class='local-search-empty'>" + "一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个6级的台阶总共有多少种跳法?n级呢?" + "</span>";

      function CloseLocalSearch()
      {
        first_char_flag = 0;

        $('#local-search-input').val('');
        $('#local-search-close').hide();

        // $('.local-search-result-cls ul li').velocity('stop').velocity('transition.slideDownOut', 200);

        $('#' + content_id).attr("headroom_special_attr","true"); 
        
        if (isMobile())
        {
          // $('body').scrollTop(last_page_y);  // scrollTop 有兼容性问题
          scrollTo(last_page_x, last_page_y);

          $('#' + content_id).hide();
        }
        else
        {
          $('#' + content_id).velocity('stop').velocity( 'transition.bounceUpOut', 200 );
        }

        // $('#' + content_id).velocity('stop').velocity( isMobile() ? 'transition.fadeOut' : 'transition.bounceUpOut', {
        //   // delay: isMobile() ? 50 : 0,
        //   duration: isMobile() ? 500 : 200,
        //   // begin: function() { 
        //   //   if (isMobile())
        //   //   {
        //   //     $('body').scrollTop(last_page_y);
        //   //   } 
        //   // }
        //   complete: function () {
        //     if (isMobile())
        //     {
        //       if (last_page_y < 20000)
        //       {
        //         $('body').velocity('scroll', { offset: last_page_y+"px", duration: last_page_y < 10000 ? 1000 : 2000 });
        //       }
        //       else
        //       {
        //         $('body').scrollTop(last_page_y);
        //       }
        //       // $('body').velocity('scroll');

        //       // $('html,body').animate({
        //       //   scrollTop: last_page_y
        //       // },400);
        //       // $('body').velocity('transition.slideDownIn', 1000);
        //       // $('body').velocity('scroll', { offset: last_page_y+"px", duration: document.body.scrollHeight < 20000 ? 1500 : 3000 });
        //     }
        //   }
        // });
      }

      function handleSearch()
      {
        if (keywords.length <= 0) {
          return;
        }
        $resultContent.innerHTML = "";
        $('#local-search-close').show();

        // 0x04. perform local searching
        if (is_load_xml_finished == 0)
        {
          $resultContent.innerHTML = 
            "<ul class='local-search-empty-ul'>" + 
            local_search_tips +
            ProgressBar;
        }
        else
        {
          // Retrieve the object from local storage
          var xml_resp = retrieve_search_xml()

          xml_resp.forEach(function (data) {
          // datas.forEach(function (data) {
            var isMatch = true;
            var content_index = [];
            if (!data.title || data.title.trim() === '') {
              data.title = "Untitled";
            }
            var is_encrypted = data.encrypted.trim() == '1'
            var is_sensitive = CONFIG.local_search.sensitive_word && data_content.indexOf(CONFIG.local_search.sensitive_word) >= 0
            var orig_data_title = data.title.trim();
            var data_title = orig_data_title.toLowerCase();
            var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
            var data_content = orig_data_content.toLowerCase();
            var data_url = decodeURIComponent(data.url);
            var index_title = -1;
            var index_content = -1;
            var first_occur = -1;
            // only match artiles with not empty contents
            if (data_content !== '') {
              keywords.forEach(function (keyword, i) {
                index_title = data_title.indexOf(keyword);
                index_content = (is_sensitive || is_encrypted) ? -1 : data_content.indexOf(keyword);

                if (index_title < 0 && index_content < 0) {
                  isMatch = false;
                } else {
                  if (index_content < 0) {
                    index_content = 0;
                  }
                  if (i == 0) {
                    first_occur = index_content;
                  }
                  // content_index.push({index_content:index_content, keyword_len:keyword_len});
                }
              });
            } else {
              isMatch = false;
            }
            // 0x05. show search results
            if (isMatch) {
              var content = orig_data_content;
              if (first_occur >= 0) {
                var match_content = "";
                if (!is_sensitive && !is_encrypted)
                {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  match_content = content.substr(start, end);
                }

                // highlight all keywords
                var regS = "";
                if (match_content != "")
                {
                  keywords.forEach(function (keyword) {
                    regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<b class=\"search-keyword\">" + keyword + "</b>");
                    orig_data_title = orig_data_title.replace(regS, "<b class=\"search-keyword\">" + keyword + "</b>");
                  });
                }
                else
                {
                  keywords.forEach(function (keyword) {
                    regS = new RegExp(keyword, "gi");
                    orig_data_title = orig_data_title.replace(regS, "<b class=\"search-keyword\">" + keyword + "</b>");
                  });
                }
                str += "<li><a href='" + data_url + "' class='search-result-title' target='_blank'>" + orig_data_title + "</a>";
                str += "<p class=\"search-result\">" + match_content + "...</p>"
              }
              str += "</li>";
            }
          });

          str += "</ul>";
          if (str.indexOf('<li>') === -1) {
            return $resultContent.innerHTML = 
              "<ul class='local-search-empty-ul'><span class='local-search-empty'>找不到, 换个搜索关键字试一哈.<span></ul>";
          }
          $resultContent.innerHTML = str;
        }
      }

      $input.addEventListener('input', function () {
        // 0x03. parse query to keywords list
        str = '<ul class=\"search-result-list\">';
        temp_keyword = this.value.trim();
        if (temp_keyword.length <= 0) {
          CloseLocalSearch();
          return;
        }

        keywords = temp_keyword.toLowerCase().split(/[\s\-]+/);
        handleSearch();

        // 当用户键入第一个字母的时候的动画处理逻辑 : 
        // 当 first_char_flag 为 0 的时候, 
        // 要播放一个动画
        if (first_char_flag == 0)
        {
            // $('body').scrollTop(0);
          if (isMobile())
          {
            last_page_x = window.pageXOffset;
            last_page_y = window.pageYOffset;
            // $('body').scrollTop(0);
            scrollTo(0,0);

          }
          first_char_flag = 1;
          $('#' + content_id).removeAttr("headroom_special_attr");
          
          $('#' + content_id).velocity('stop').velocity('transition.slideDownIn', 300);

          $('.local-search-result-cls ul li').velocity('stop').velocity('transition.slideDownIn', 1000);
        }
      });


      var local_search_xml_data = localStorage.getItem('local_search_xml_data');
      if (!local_search_xml_data) {
        $.ajax({
          // 0x01. load xml file
          url: path,
          dataType: "xml",
          success: function (xmlResponse) {
            store_search_xml(xmlResponse);

            // setTimeout(function(){
            //   is_load_xml_finished = 1;

            //   handleSearch();
            //   $('.local-search-result-cls ul li').velocity('stop').velocity('transition.slideDownIn', 800);
            // }, 2000);
            
            // is_load_xml_finished = 1;

            handleSearch();
            $('.local-search-result-cls ul li').velocity('stop').velocity('transition.slideDownIn', 800);
          }
        });
      }

      $(document).on('click', '#local-search-close', function() {
        CloseLocalSearch();
      });

      $(document).keyup(function(event){
        switch(event.keyCode) {
          case 27:
            // alert("ESC");
            CloseLocalSearch();
        }
      });

      // $(document).on('blur', '#local-search-input', function(e) {
      //   // console.log(document.activeElement.getAttribute('class'));
        
      //   if (isMobile() == false)
      //   {
      //     CloseLocalSearch();
      //   }
      // });
    }

    function isMobile() {
      // console.log(document.body.clientWidth);
      return document.body.clientWidth < 768

      // var userAgent = window.navigator.userAgent;

      // var isiPad = userAgent.match(/iPad/i) !== null;
      // var mobileUA = [
      //   'iphone', 'android', 'phone', 'mobile',
      //   'wap', 'netfront', 'x11', 'java', 'opera mobi',
      //   'opera mini', 'ucweb', 'windows ce', 'symbian',
      //   'symbianos', 'series', 'webos', 'sony',
      //   'blackberry', 'dopod', 'nokia', 'samsung',
      //   'palmsource', 'xda', 'pieplus', 'meizu',
      //   'midp' ,'cldc' , 'motorola', 'foma',
      //   'docomo', 'up.browser', 'up.link', 'blazer',
      //   'helio', 'hosin', 'huawei', 'novarra',
      //   'coolpad', 'webos', 'techfaith', 'palmsource',
      //   'alcatel', 'amoi', 'ktouch', 'nexian',
      //   'ericsson', 'philips', 'sagem', 'wellcom',
      //   'bunjalloo', 'maui', 'smartphone', 'iemobile',
      //   'spice', 'bird', 'zte-', 'longcos',
      //   'pantech', 'gionee', 'portalmmm', 'jig browser',
      //   'hiptop', 'benq', 'haier', '^lct',
      //   '320x320', '240x320', '176x220'
      // ];
      // var pattern = new RegExp(mobileUA.join('|'), 'i');

      // return !isiPad && userAgent.match(pattern);
    }

    function store_search_xml(xmlResponse) {
        datas = $("entry", xmlResponse).map(function () {
          return {
            title: $("title", this).text(),
            content: $("content", this).text(),
            url: $("url", this).text(),
            encrypted: $("encrypted", this).text(),
          };
        }).get();
        // Put the object into storage
        localStorage.setItem('local_search_xml_data', JSON.stringify(datas));
        is_load_xml_finished = 1;

        console.log("store search.xml finished.");
    }

    function ajax_store_search_xml() {
      $.ajax({
        url: "/search.xml",
        dataType: "xml",
        success: function (xmlResponse) {
            store_search_xml(xmlResponse);
        }
      });
    }

    function retrieve_search_xml() {
        // Retrieve the object from local storage
        var retrievedObject = localStorage.getItem('local_search_xml_data');
        var xml_resp = JSON.parse(retrievedObject)
        return xml_resp
    }

    var getSearchFile = function(){
      var path = "/search.xml";
      var local_search_result_name = isMobile() ? "local-search-result-mobile" : "local-search-result-pc";
      searchFunc(path, 'local-search-input', local_search_result_name);
    }

    var local_search_xml_data = localStorage.getItem('local_search_xml_data');
    if (local_search_xml_data) {
      is_load_xml_finished = 1;
      console.log("load search.xml finished.");
    }
    var last_use_local_search_date = localStorage.getItem('last_use_local_search_date');
    var curDate = new Date();
    // 只有在 localStorage 没有 search.xml数据或者 距离上次使用local search已经超过一天了才去取search.xml
    // 节省流量
    if (last_use_local_search_date != curDate.getDate() || !local_search_xml_data) {
      // preload search.xml
      ajax_store_search_xml();
    }

    localStorage.setItem('last_use_local_search_date', curDate.getDate());
    

  </script>





  

  

  

  

  

  


  <script type="text/javascript" src="/lib/wobble_window/wobblewindow.js"> </script>
<script type="text/javascript" src="/js/src/custom.js"></script>
</body>
</html>


<!-- 页面点击小红心 -->





<script type="text/javascript" src="/js/src/headroom.js"></script> 

<!-- 代码块复制功能 -->
<script type="text/javascript" src="/js/src/clipboard-use.js"></script>
