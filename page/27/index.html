<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">

<script>
    (function(){
        if(''){
          // alert('此文章并不公开, 输入文章密码方可阅读');
          var password = prompt('此文章并不公开, 输入文章密码方可阅读');
          if (password !== ''){
            if (password != null) // 如果用户点击了确认而且密码错误的时候, 因为当password == null的时候说明用户点了取消
            {
              alert('Error!');
            }
            if (history.length > 1)
            {
              history.back();
            }
            else
            {
              window.location.href = "about:blank";
            }
          }
        }
    })();
</script>








<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/dist/jquery.fancybox.css?v=3.2.10" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.2">






<meta name="description" content="推荐使用Chrome/Firefox/Safari阅读本博客. 以前的老笔记将会一篇一篇慢慢整理为博客, 这既启发了他人, 也锻炼了自己的描述交流能力.">
<meta property="og:type" content="website">
<meta property="og:title" content="烫">
<meta property="og:url" content="https://hulinhong.com/page/27/index.html">
<meta property="og:site_name" content="烫">
<meta property="og:description" content="推荐使用Chrome/Firefox/Safari阅读本博客. 以前的老笔记将会一篇一篇慢慢整理为博客, 这既启发了他人, 也锻炼了自己的描述交流能力.">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="烫">
<meta name="twitter:description" content="推荐使用Chrome/Firefox/Safari阅读本博客. 以前的老笔记将会一篇一篇慢慢整理为博客, 这既启发了他人, 也锻炼了自己的描述交流能力.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"scrollpercent":true,"onmobile":true,"dimmer":true,"body_content_height":0,"display_duration":150},
    local_search: {"enable":true,"trigger":"auto","top_n_per_article":1},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"duration":222,"transition":{"header":"slideDownIn","menu":"slideDownIn","logo":"slideDownIn","post_block_else":"slideDownIn","post_header":"fadeIn","post_body":"fadeIn","coll_header":"slideDownIn","footer":"slideDownIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>








  <title>烫 - 烫烫烫烫烫</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">烫</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">烫烫烫烫烫</p>
      
  </div>

  <div class="menu-item sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <div class="menu-item site-search">
    
  
  <form class="site-search-form">
    <span class="search-icon fa fa-search"></span>
    <input type="text" id="local-search-input" class="st-search-input">
    <i id="local-search-close">×</i>
  </form>


<script type="text/javascript" id="local.search.active">
var inputArea       = document.querySelector("#local-search-input");
inputArea.onclick   = function(){ getSearchFile(); this.onclick = null }
inputArea.onkeydown = function(){ if(event.keyCode == 13) return false }
</script>



  </div>
  <div id="local-search-result-pc" class="local-search-result-cls"></div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  
  

  
    <ul id="menu" class="menu menu-left">
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

       
    </ul>
  

  
    
  
</nav>



 </div>
    </header>

    <div id="local-search-result-mobile" class="local-search-result-cls"></div>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hulinhong.com/2017/03/29/reliable_ordered_messages/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="no5ix">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="烫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/29/reliable_ordered_messages/" itemprop="url">构建游戏网络协议五之可靠的有序消息</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-29T13:13:35+00:00">
                2017-03-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/GS/" itemprop="url" rel="index">
                    <span itemprop="name">GS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    




    
    
    
    <div class="post-body" itemprop="articleBody">
      
      

      

      
      
        <div class="post-eof"></div>
      

      
      

      
        
          
            <h1 id="本篇自我总结"><a href="#本篇自我总结" class="headerlink" title="本篇自我总结"></a>本篇自我总结</h1><p>本篇主要讲了数据包的分包和重组问题, 到底数据包多大才好呢?是不是越大越好呢?包太大了怎么办呢?<br>请看总结, 不明之处再看文中具体讲解.</p>
<h2 id="为什么需要做这个可靠UDP协议"><a href="#为什么需要做这个可靠UDP协议" class="headerlink" title="为什么需要做这个可靠UDP协议"></a>为什么需要做这个可靠UDP协议</h2><p>网络协议在动作游戏类型（FPS）中的典型特征就是一个持续发送的数据包，在两个方向上以稳定的速度如20或30包每秒发送。这些数据包都包含有不可靠的无序数据例如t时间内的世界状态；所以，当一个数据包丢失，重新发送它并不是特别有用。当重新发送的数据包到达时，时间t已经过去了。</p>
<p>所以这就是我们将要实现可靠性的现状。对于我们90%的数据包，仅丢弃并不再重新发送它会更好。对于10%或更少（误差允许范围内）的情况，我们确实需要可靠性，但这样的数据是非常罕见的，很少被发送而且比不可靠的数据的平均大小要小得多。这个使用案例适用于所有过去十五年来发布的AAA级的FPS游戏。</p>
<h2 id="应答系统是实现可靠UDP的最重要的部分"><a href="#应答系统是实现可靠UDP的最重要的部分" class="headerlink" title="应答系统是实现可靠UDP的最重要的部分"></a>应答系统是实现可靠UDP的最重要的部分</h2><p>为实现数据包层级的应答，在每个包的前面添加如下的报头：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Header</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> sequence;</span><br><span class="line">    <span class="keyword">uint16_t</span> ack;</span><br><span class="line">    <span class="keyword">uint32_t</span> ack_bits;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这些报头元素组合起来以创建应答系统：</p>
<ul>
<li>sequence 是一个数字，随每个数据包发送而增长（并且在达到65535后回往复）。</li>
<li>ack 是从另一方接收到的最新的数据包序列号。</li>
<li>ack_bits 是一个位字段，它编码与ack相关的收到的数据包组合：如果位n已经设置，即 ack– n 数据包被接收了。</li>
</ul>
<p>ack_bits 不仅是一个节省带宽的巧妙的编码，它同样也增加了信息冗余来抵御包的丢失。每个应答码要被发送32次。如果有一个包丢失了，仍然有其他31个包有着相同的应答码。从统计上来说，应答码还是非常有可能送达的。</p>
<p>但突发的传送数据包的丢失还是有可能发生的，所以重要的是要注意：</p>
<ul>
<li>如果你收到一个数据包n的应答码，那么这个包肯定已经收到了。</li>
<li>如果你没有收到应答码，那么这个包就很有可能 没有被收到。但是…它也许会是，仅是应答码没有送达。这种情况是极其罕见的。</li>
</ul>
<p>以我的经验，没有必要设计完善的应答机制。在一个极少丢应答码的系统上构建一个可靠性系统并不会增加什么大问题。</p>
<h2 id="发送方如何追踪数据包是否已经被应答"><a href="#发送方如何追踪数据包是否已经被应答" class="headerlink" title="发送方如何追踪数据包是否已经被应答"></a>发送方如何追踪数据包是否已经被应答</h2><p>为实现这个应答系统，我们在发送方还需要一个数据结构来追踪一个数据包是否已经被应答，这样我们就可以忽略冗余的应答（每个包会通过 <code>ack_bits</code>多次应答)。我们同样在接收方也还需要一个数据结构来追踪那些已经收到的包，这样我们就可以在数据包的报头填写<code>ack_bits</code>的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> BufferSize = <span class="number">1024</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">uint32_t</span> sequence_buffer[BufferSize];</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PacketData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> acked;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">PacketData packet_data[BufferSize];</span><br><span class="line"> </span><br><span class="line"><span class="function">PacketData * <span class="title">GetPacketData</span><span class="params">( <span class="keyword">uint16_t</span> sequence )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> index = sequence % BufferSize;</span><br><span class="line">    <span class="keyword">if</span> ( sequence_buffer[index] == sequence )</span><br><span class="line">        <span class="keyword">return</span> &amp;packet_data[index];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你在这可以看到的窍门是这个滚动的缓冲区是以序列号来作为索引的：</p>
<p><code>const int index =sequence % BufferSize;</code></p>
<p>当条目被顺序添加，就像一个被发送的队列，对插入所需要做的就是把这个序列缓冲区的值更新为新的序列号并且在该索引处重写这个数据：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PacketData &amp; <span class="title">InsertPacketData</span><span class="params">( <span class="keyword">uint16_t</span> sequence )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> index = sequence % BufferSize;</span><br><span class="line">    sequence_buffer[index] = sequence;</span><br><span class="line">    <span class="keyword">return</span> packet_data[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><p><a href="https://gafferongames.com/post/reliable_ordered_messages/" target="_blank" rel="noopener">原文出处</a></p>
<p>原文标题 : <strong>Reliable Ordered Messages</strong> (<em>How to implement reliable-ordered messages on top of UDP</em>)</p>
<hr>
<p></p><h2 id="introduction">Introduction</h2><p></p>
<p>Hi, I’m <a href="https://gafferongames.com/about" target="_blank" rel="noopener">Glenn Fiedler</a> and welcome to <strong><a href="https://gafferongames.com/categories/building-a-game-network-protocol/" target="_blank" rel="noopener">Building a Game Network Protocol</a></strong>.</p><br><p>Many people will tell you that implementing your own reliable message system on top of UDP is foolish. After all, why reimplement TCP?</p><br><p>But why limit ourselves to how TCP works? But there are so many different ways to implement reliable-messages and most of them work <em>nothing</em> like TCP!</p><br><p>So let&rsquo;s get creative and work out how we can implement a reliable message system that&rsquo;s <em>better</em> and <em>more flexible</em> than TCP for real-time games.</p><br><h2 id="different-approaches">Different Approaches</h2><br><p>A common approach to reliability in games is to have two packet types: reliable-ordered and unreliable. You&rsquo;ll see this approach in many network libraries.</p><br><p>The basic idea is that the library resends reliable packets until they are received by the other side. This is the option that usually ends up looking a bit like TCP-lite for the reliable-packets. It&rsquo;s not that bad, but you can do much better.</p><br><p>The way I prefer to think of it is that messages are smaller bitpacked elements that know how to serialize themselves. This makes the most sense when the overhead of length prefixing and padding bitpacked messages up to the next byte is undesirable (eg. lots of small messages included in each packet). Sent messages are placed in a queue and each time a packet is sent some of the messages in the send queue are included in the outgoing packet. This way there are no reliable packets that need to be resent. Reliable messages are simply included in outgoing packets until they are received.</p><br><p>The easiest way to do this is to include all unacked messages in each packet sent. It goes something like this: each message sent has an id that increments each time a message is sent. Each outgoing packet includes the start <em>message id</em> followed by the data for <em>n</em> messages. The receiver continually sends back the most recent received message id to the sender as an ack and only messages newer than the most recent acked message id are included in packets.</p><br><p>This is simple and easy to implement but if a large burst of packet loss occurs while you are sending messages you get a spike in packet size due to unacked messages.</p><br><p>You can avoid this by extending the system to have an upper bound on the number of messages included per-packet <em>n</em>. But now if you have a high packet send rate (like 60 packets per-second) you are sending the same message multiple times until you get an ack for that message.</p><br><p>If your round trip time is 100ms each message will be sent 6 times redundantly before being acked on average. Maybe you really need this amount of redundancy because your messages are extremely time critical, but in most cases, your bandwidth would be better spent on other things.</p><br><p>The approach I prefer combines packet level acks with a prioritization system that picks the n most important messages to include in each packet. This combines time critical delivery and the ability to send only n messages per-packet, while distributing sends across all messages in the send queue.</p><br><h2 id="packet-level-acks">Packet Level Acks</h2><br><p>To implement packet level acks, we add the following packet header:</p><br><pre>struct Header<br>{<br>    uint16_t sequence;<br>    uint16_t ack;<br>    uint32_t ack_bits;<br>};<br></pre><br><p>These header elements combine to create the ack system: <strong>sequence</strong> is a number that increases with each packet sent, <strong>ack</strong> is the most recent packet sequence number received, and <strong>ack_bits</strong> is a bitfield encoding the set of acked packets.</p><br><p>If bit <strong>n</strong> is set in <strong>ack_bits</strong>, then <strong>ack - n</strong> is acked. Not only is <strong>ack_bits</strong> a smart encoding that saves bandwidth, it also adds <em>redundancy</em> to combat packet loss. Each ack is sent 32 times. If one packet is lost, there&rsquo;s 31 other packets with the same ack. Statistically speaking, acks are very likely to get through.</p><br><p>But bursts of packet loss do happen, so it&rsquo;s important to note that:</p><br><ol><br><li><p>If you receive an ack for packet n then that packet was <strong>definitely received</strong>.</p></li><br><li><p>If you don&rsquo;t receive an ack, the packet was <em>most likely</em> not received. But, it might have been, and the ack just didn&rsquo;t get through. <strong>This is extremely rare</strong>.</p></li><br></ol><br><p>In my experience it&rsquo;s not necessary to send perfect acks. Building a reliability system on top of a system that very rarely drops acks adds no significant problems. But it does create a challenge for testing this system works under all situations because of the edge cases when acks are dropped.</p><br><p>So please if you do implement this system yourself, setup a soak test with terrible network conditions to make sure your ack system is working correctly. You&rsquo;ll find such a soak test in the <a href="http://www.patreon.com/gafferongames" target="_blank" rel="noopener">example source code</a> for this article, and the open source network libraries <a href="https://github.com/networkprotocol/reliable.io" target="_blank" rel="noopener">reliable.io</a> and <a href="http://www.libyojimbo.com" target="_blank" rel="noopener">yojimbo</a> which also implement this technique.</p><br><h2 id="sequence-buffers">Sequence Buffers</h2><br><p>To implement this ack system we need a data structure on the sender side to track whether a packet has been acked so we can ignore redundant acks (each packet is acked multiple times via <strong>ack_bits</strong>. We also need a data structure on the receiver side to keep track of which packets have been received so we can fill in the <strong>ack_bits</strong> value in the packet header.</p><br><p>The data structure should have the following properties:</p><br><ul><br><li>Constant time insertion (inserts may be <em>random</em>, for example out of order packets&hellip;)</li><br><li>Constant time query if an entry exists given a packet sequence number</li><br><li>Constant time access for the data stored for a given packet sequence number</li><br><li>Constant time removal of entries</li><br></ul><br><p>You might be thinking. Oh of course, <em>hash table</em>. But there&rsquo;s a much simpler way:</p><br><pre>const int BufferSize = 1024;<br><br>uint32_t sequence_buffer[BufferSize];<br><br>struct PacketData<br>{<br>    bool acked;<br>};<br><br>PacketData packet_data[BufferSize];<br><br>PacketData <em> GetPacketData( uint16_t sequence )<br>{<br>    const int index = sequence % BufferSize;<br>    if ( sequence_buffer[index] == sequence )<br>        return &amp;packet_data[index];<br>    else<br>        return NULL;<br>}<br></em></pre><br><p>As you can see the trick here is a rolling buffer indexed by sequence number:</p><br><pre>const int index = sequence % BufferSize;<br></pre><br><p>This works because we don&rsquo;t care about being destructive to old entries. As the sequence number increases older entries are naturally overwritten as we insert new ones. The sequence_buffer[index] value is used to test if the entry at that index actually corresponds to the sequence number you&rsquo;re looking for. A sequence buffer value of 0xFFFFFFFF indicates an empty entry and naturally returns NULL for any sequence number query without an extra branch.</p><br><p>When entries are added in order like a send queue, all that needs to be done on insert is to update the sequence buffer value to the new sequence number and overwrite the data at that index:</p><br><pre>PacketData &amp; InsertPacketData( uint16_t sequence )<br>{<br>    const int index = sequence % BufferSize;<br>    sequence_buffer[index] = sequence;<br>    return packet_data[index];<br>}<br></pre><br><p>Unfortunately, on the receive side packets arrive out of order and some are lost. Under ridiculously high packet loss (99%) I&rsquo;ve seen old sequence buffer entries stick around from before the previous sequence number wrap at 65535 and break my ack logic (leading to false acks and broken reliability where the sender thinks the other side has received something they haven&rsquo;t&hellip;).</p><br><p>The solution to this problem is to walk between the previous highest insert sequence and the new insert sequence (if it is more recent) and clear those entries in the sequence buffer to 0xFFFFFFFF. Now in the common case, insert is <em>very close</em> to constant time, but worst case is linear where n is the number of sequence entries between the previous highest insert sequence and the current insert sequence.</p><br><p>Before we move on I would like to note that you can do much more with this data structure than just acks. For example, you could extend the per-packet data to include time sent:</p><br><pre>struct PacketData<br>{<br>    bool acked;<br>    double send_time;<br>};<br></pre><br><p>With this information you can create your own estimate of round trip time by comparing send time to current time when packets are acked and taking an <a href="https://en.wikipedia.org/wiki/Exponential_smoothing" target="_blank" rel="noopener">exponentially smoothed moving average</a>. You can even look at packets in the sent packet sequence buffer older than your RTT estimate (you should have received an ack for them by now&hellip;) to create your own packet loss estimate.</p><br><h2 id="ack-algorithm">Ack Algorithm</h2><br><p>Now that we have the data structures and packet header, here is the algorithm for implementing packet level acks:</p><br><p><strong>On packet send:</strong></p><br><ol><br><li><p>Insert an entry for for the current send packet sequence number in the sent packet sequence buffer with data indicating that it hasn&rsquo;t been acked yet</p></li><br><li><p>Generate <strong>ack</strong> and <strong>ack_bits</strong> from the contents of the local received packet sequence buffer and the most recent received packet sequence number</p></li><br><li><p>Fill the packet header with <strong>sequence</strong>, <strong>ack</strong> and <strong>ack_bits</strong></p></li><br><li><p>Send the packet and increment the send packet sequence number</p></li><br></ol><br><p><strong>On packet receive:</strong></p><br><ol><br><li><p>Read in <strong>sequence</strong> from the packet header</p></li><br><li><p>If <strong>sequence</strong> is more recent than the previous most recent received packet sequence number, update the most recent received packet sequence number</p></li><br><li><p>Insert an entry for this packet in the received packet sequence buffer</p></li><br><li><p>Decode the set of acked packet sequence numbers from <strong>ack</strong> and <strong>ack_bits</strong> in the packet header.</p></li><br><li><p>Iterate across all acked packet sequence numbers and for any packet that is not already acked call <strong>OnPacketAcked</strong>( uint16_t sequence ) and mark that packet as <em>acked</em> in the sent packet sequence buffer.</p></li><br></ol><br><p>Importantly this algorithm is done on both sides so if you have a client and a server then each side of the connection runs the same logic, maintaining its own sequence number for sent packets, tracking most recent received packet sequence # from the other side and a sequence buffer of received packets from which it generates <strong>sequence</strong>, <strong>ack</strong> and <strong>ack_bits</strong> to send to the other side.</p><br><p>And that&rsquo;s really all there is to it. Now you have a callback when a packet is received by the other side: <strong>OnPacketAcked</strong>. The main benefit of this ack system is now that you know which packets were received, you can build <em>any</em> reliability system you want on top. It&rsquo;s not limited to just reliable-ordered messages. For example, you could use it to implement delta encoding on a per-object basis.</p><br><h2 id="message-objects">Message Objects</h2><br><p>Messages are small objects (smaller than packet size, so that many will fit in a typical packet) that know how to serialize themselves. In my system they perform serialization using a <a href="https://gafferongames.com/building-a-game-network-protocol/serialization-strategies" target="_blank" rel="noopener">unified serialize function</a>unified serialize function.</p><br><p>The serialize function is templated so you write it once and it handles read, write and <em>measure</em>.</p><br><p>Yes. Measure. One of my favorite tricks is to have a dummy stream class called <strong>MeasureStream</strong> that doesn&rsquo;t do any actual serialization but just measures the number of bits that <em>would</em> be written if you called the serialize function. This is particularly useful for working out which messages are going to fit into your packet, especially when messages themselves can have arbitrarily complex serialize functions.</p><br><pre>struct TestMessage : public Message<br>{<br>    uint32_t a,b,c;<br><br>    TestMessage()<br>    {<br>        a = 0;<br>        b = 0;<br>        c = 0;<br>    }<br><br>    template &lt;typename Stream&gt; bool Serialize( Stream &amp; stream )<br>    {<br>        serialize_bits( stream, a, 32 );<br>        serialize_bits( stream, b, 32 );<br>        serialize_bits( stream, c, 32 );<br>        return true;<br>    }<br><br>    virtual SerializeInternal( WriteStream &amp; stream )<br>    {<br>        return Serialize( stream );<br>    }<br><br>    virtual SerializeInternal( ReadStream &amp; stream )<br>    {<br>        return Serialize( stream );<br>    }<br><br>    virtual SerializeInternal( MeasureStream &amp; stream )<br>    {<br>        return Serialize( stream );<br>    }<br>};<br></pre><br><p>The trick here is to bridge the unified templated serialize function (so you only have to write it once) to virtual serialize methods by calling into it from virtual functions per-stream type. I usually wrap this boilerplate with a macro, but it&rsquo;s expanded in the code above so you can see what&rsquo;s going on.</p><br><p>Now when you have a base message pointer you can do this and it <em>just works</em>:</p><br><pre>Message  message = CreateSomeMessage();<br>message-&gt;SerializeInternal( stream );<br></pre><br><p>An alternative if you know the full set of messages at compile time is to implement a big switch statement on message type casting to the correct message type before calling into the serialize function for each type. I&rsquo;ve done this in the past on console platform implementations of this message system (eg. PS3 SPUs) but for applications today (2016) the overhead of virtual functions is neglible.</p><br><p>Messages derive from a base class that provides a common interface such as serialization, querying the type of a message and reference counting. Reference counting is necessary because messages are passed around by pointer and stored not only in the message send queue until acked, but also in outgoing packets which are themselves C++ structs.</p><br><p>This is a strategy to avoid copying data by passing both messages and packets around by pointer. Somewhere else (ideally on a separate thread) packets and the messages inside them are serialized to a buffer. Eventually, when no references to a message exist in the message send queue (the message is acked) and no packets including that message remain in the packet send queue, the message is destroyed.</p><br><p>We also need a way to create messages. I do this with a message factory class with a virtual function overriden to create a message by type. It&rsquo;s good if the packet factory also knows the total number of message types, so we can serialize a message type over the network with tight bounds and discard malicious packets with message type values outside of the valid range:</p><br><pre>enum TestMessageTypes<br>{<br>    TEST_MESSAGE_A,<br>    TEST_MESSAGE_B,<br>    TEST_MESSAGE_C,<br>    TEST_MESSAGE_NUM_TYPES<br>};<br><br>// message definitions omitted<br><br>class TestMessageFactory : public MessageFactory<br>{<br>public:<br><br>    Message <em> Create( int type )<br>    {<br>        switch ( type )<br>        {<br>            case TEST_MESSAGE_A: return new TestMessageA();<br>            case TEST_MESSAGE_B: return new TestMessageB();<br>            case TEST_MESSAGE_C: return new TestMessageC();<br>        }<br>    }<br><br>    virtual int GetNumTypes() const<br>    {<br>        return TEST_MESSAGE_NUM_TYPES;<br>    }<br>};<br></em></pre><br><p>Again, this is boilerplate and is usually wrapped by macros, but underneath this is what&rsquo;s going on.</p><br><h2 id="reliable-ordered-message-algorithm">Reliable Ordered Message Algorithm</h2><br><p>The algorithm for sending reliable-ordered messages is as follows:</p><br><p><strong>On message send:</strong></p><br><ol><br><li><p>Measure how many bits the message serializes to using the measure stream</p></li><br><li><p>Insert the message pointer and the # of bits it serializes to into a sequence buffer indexed by message id. Set the time that message has last been sent to -1</p></li><br><li><p>Increment the send message id</p></li><br></ol><br><p><strong>On packet send:</strong></p><br><ol><br><li><p>Walk across the set of messages in the send message sequence buffer between the oldest unacked message id and the most recent inserted message id from left -&gt; right (increasing message id order).</p></li><br><li><p>Never send a message id that the receiver can&rsquo;t buffer or you&rsquo;ll break message acks (since that message won&rsquo;t be buffered, but the packet containing it will be acked, the sender thinks the message has been received, and will not resend it). This means you must <em>never</em> send a message id equal to or more recent than the oldest unacked message id plus the size of the message receive buffer.</p></li><br><li><p>For any message that hasn&rsquo;t been sent in the last 0.1 seconds <em>and</em> fits in the available space we have left in the packet, add it to the list of messages to send. Messages on the left (older messages) naturally have priority due to the iteration order.</p></li><br><li><p>Include the messages in the outgoing packet and add a reference to each message. Make sure the packet destructor decrements the ref count for each message.</p></li><br><li><p>Store the number of messages in the packet <strong>n</strong> and the array of message ids included in the packet in a sequence buffer indexed by the outgoing packet sequence number so they can be used to map packet level acks to the set of messages included in that packet.</p></li><br><li><p>Add the packet to the packet send queue.</p></li><br></ol><br><p><strong>On packet receive:</strong></p><br><ol><br><li><p>Walk across the set of messages included in the packet and insert them in the receive message sequence buffer indexed by their message id.</p></li><br><li><p>The ack system automatically acks the packet sequence number we just received.</p></li><br></ol><br><p><strong>On packet ack:</strong></p><br><ol><br><li><p>Look up the set of messages ids included in the packet by sequence number.</p></li><br><li><p>Remove those messages from the message send queue if they exist and decrease their ref count.</p></li><br><li><p>Update the last unacked message id by walking forward from the previous unacked message id in the send message sequence buffer until a valid message entry is found, or you reach the current send message id. Whichever comes first.</p></li><br></ol><br><p><strong>On message receive:</strong></p><br><ol><br><li><p>Check the receive message sequence buffer to see if a message exists for the current receive message id.</p></li><br><li><p>If the message exists, remove it from the receive message sequence buffer, increment the receive message id and return a pointer to the message.</p></li><br><li><p>Otherwise, no message is available to receive. Return <strong>NULL</strong>.</p></li><br></ol><br><p>In short, messages keep getting included in packets until a packet containing that message is acked. We use a data structure on the sender side to map packet sequence numbers to the set of message ids to ack. Messages are removed from the send queue when they are acked. On the receive side, messages arriving out of order are stored in a sequence buffer indexed by message id, which lets us receive them in the order they were sent.</p><br><h2 id="the-end-result">The End Result</h2><br><p>This provides the user with an interface that looks something like this on send:</p><br><pre>TestMessage  message = (TestMessage<em>) factory.Create( TEST_MESSAGE );<br>if ( message )<br>{<br>    message-&gt;a = 1;<br>    message-&gt;b = 2;<br>    message-&gt;c = 3;<br>    connection.SendMessage( message );<br>}</em></pre><br><p>And on the receive side:</p><br><pre>while ( true )<br>{<br>    Message  message = connection.ReceiveMessage();<br>    if ( !message )<br>        break;<br><br>    if ( message-&gt;GetType() == TEST_MESSAGE )<br>    {<br>        TestMessage <em> testMessage = (TestMessage</em>) message;<br>        // process test message<br>    }<br><br>    factory.Release( message );<br>}<br></pre><br><p>Which is flexible enough to implement whatever you like on top of it.</p>


<h1 id="译文">译文</h1>


<p><a href="http://gad.qq.com/program/translateview/7168700" target="_blank" rel="noopener">译文出处</a></p>
<div class="WordSection1"><div><p class="MsoNormal" align="left" style="vertical-align: baseline; border: none; padding: 0cm;"><span style="font-family:微软雅黑;font-size:medium;"><span style="color: rgb(34, 34, 34);">译者：翁僖骏（</span><span style="color: rgb(34, 34, 34);"><a href="http://gad.qq.com/user/index?id=304098" target="_blank" rel="noopener"><span><span>∈星际长途←</span></span></a></span><span style="color: rgb(34, 34, 34);">）</span><span style="color: rgb(34, 34, 34);">  </span><span style="color: rgb(34, 34, 34);">审校：侯鹏（</span><span style="color: rgb(34, 34, 34);"><a href="http://gad.qq.com/user/index?id=391222" target="_blank" rel="noopener"><span><span>叶落&amp;</span></span><span><span>无痕</span></span></a></span><span style="color: rgb(34, 34, 34);">）</span><span style="color: rgb(34, 34, 34);"> </span></span> </p></div><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"><br></span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">嗨，我是格伦费德勒，欢迎来到</span><u><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#DD3333">创建一个游戏网络协议</span></u><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">第五篇文章。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">从<span><a rel="noopener" href="http://gafferongames.com/building-a-game-network-protocol/sending-large-blocks-of-data/" target="_blank"><span style="color:#DD3333"><span>上一篇文章</span></span></a></span>到现在已经有很长一段时间了，上次我已经率先而且实现了余下的这一系列文章所需的源码并创建了开源库<span><a rel="noopener" href="https://github.com/networkprotocol/libyojimbo" target="_blank"><span style="color:#DD3333">libyojimbo</span></a></span>，是本系列文章所要描述的网络协议的一个质量有保证的的和经过单元测试的版本。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">如果你想要有一个开源库来为自己在<span>UDP</span>之上实现可靠消息或是为了其他更多，看看<span><a rel="noopener" href="https://github.com/networkprotocol/libyojimbo" target="_blank"><span style="color:#DD3333">libyojimbo</span></a></span>。但是，如果你像我这样是想理解它具体是怎么工作的并且可能自己去实现它，阅读下去，因为我们将要从头到脚地去建立一个在<span>UDP</span>之上用来发送可靠有序消息的完整的系统！</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"><br></span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"></p><h2 id="说明"><span style="font-size:18.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">说明</span></h2> <p></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">很多人也许会跟你说，要在<span>UDP</span>之上实现你自己的可靠消息系统是愚蠢的。为什么要撰写你特有的简化版本的<span>TCP</span>？这些人深信，任何可靠性的实现<i><u><span style="border:none windowtext 1.0pt;padding:0cm">不可避免地</span></u></i><span> </span>最终会成为一个（简化的）<span>TCP</span>的重实现。 </span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">但也有很多不同的方法来在<span>UDP</span>之上实现可靠消息，各有不同的优势和劣势。<span>TCP</span>的方法并不是唯一的选择。事实上，我所了解到的大多数可靠有序信息的选择的原理和<span>TCP</span>并不相同。所以让我们为我们的目标发挥创造力并弄懂我们该如何充分利用我们的现状来实现一个比<span>TCP</span><i><u><span style="border:none windowtext 1.0pt;padding:0cm">更好</span></u></i><span> </span>的可靠性系统。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">网络协议在动作游戏类型（<span>FPS</span>）中的典型特征就是一个<u><span style="border:none windowtext 1.0pt;padding:0cm">持续发送的数据包，</span></u>在两个方向上以稳定的速度如<span>20</span>或<span>30</span>包每秒发送。这些数据包都包含有不可靠的无序数据例如<span>t</span>时间内的世界状态；所以，当一个数据包丢失，重新发送它并不是特别有用。当重新发送的数据包到达时，时间<span>t</span>已经过去了。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">所以这就是我们将要实现可靠性的现状。对于我们<span>90%</span>的数据包，仅丢弃并不再重新发送它会更好。对于<span>10%</span>或更少（误差允许范围内）的情况，我们确实需要可靠性，但这样的数据是非常罕见的，很少被发送而且比不可靠的数据的平均大小要小得多。这个使用案例适用于所有过去十五年来发布的<span>AAA</span>级的<span>FPS</span>游戏。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"><br></span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"><br></span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"></p><h2 id="不同的方法"><span style="font-size:18.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">不同的方法</span></h2> <p></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">可靠性的一个常用的方法是使用两种包类型：可靠有序的和不可靠的。你在众多网络库中都会看到这个方法。它基本的想法是，这个库不断重新发送可靠的数据包直到它的另一方接收到为止。这是一个最终看起来会有一点像<span>TCP</span>方式传输的可靠包的选择。这并没有很糟糕，但你也可以做得更好。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"><br></span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">我更愿意去考虑的方法就是消息其实是更小的位包装元素，它知道如何使它们自己序列化。这就显得非常有意义了，因为按位打包的消息中，用于描述下个字节的前缀或者后缀的字节开销在大部分的情况下是不必需的（例如每个包中包含的许多小的消息）。被发送的消息会被放在一个队列并且每次一个包被发送时，发送队列中的一些消息就会被包含在外发的包中。这样一来，就没有可靠的数据包需要被重新发送了。可靠消息也只会包含在数据包里直到它们被接收。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"><br></span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">要做到这样最简单的方法就是，把所有未应答的消息包含到每个被发送的包中。它是这样的：每个被发送的消息都有一个随每当一个消息被发送时递增的<span>id</span>。每个输出数据包包含起始<b><span style="border:none windowtext 1.0pt;padding:0cm">消息<span>id</span></span></b><span> </span>，紧跟着的是<b><span style="border:none windowtext 1.0pt;padding:0cm">n</span></b><span> </span>个消息的数据。接收方不断发回最新收到消息的<span>id</span>给发送方作为一个应答信号，并且消息要当且仅当比最新的应答消息<span>id</span>要更新，才会被包含在数据包中。 </span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"><br></span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">这很简单也易于实现，但当你正在发送消息时如果突发一个很大的包丢失情况，你会遇到一个数据包大小的峰值，因为有很多未应答的消息。。正如在<span><a rel="noopener" href="http://gafferongames.com/building-a-game-network-protocol/packet-fragmentation-and-reassembly/" target="_blank"><span style="color:#DD3333"><span>数据包分割</span></span><span style="color:#DD3333"><span>和重组</span></span></a></span>中讨论的需要按照<span>MTU</span>分割包的方式来发送大的数据包会增加丢包的情况。在高丢包率下你最不想做的就是增大包的规格并引起更多的包的丢失。这是一个潜在的无底洞。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"><br></span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">你可以通过扩展系统来给每个包的消息数量<span>n</span>设置一个上限，来避免这种情况。但现在如果你有一个高数据包发送率（如每秒<span>60</span>包）你就要多次发送同样的消息直到你得到该消息的应答信号。如果的往返时间是<span>100ms</span>，每条消息在被应答之前将要平均被多余发送六次。也许你真的需要这些多余的发送数量因为你的消息是对时间极其敏感的，但在大多数情况下，你应该给队列里的其他消息分配合理的带宽。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">我比较喜欢的方法是用一个优先次序系统整合每包的应答信号，这个系统检出<span>n</span>条最重要的消息并包含在每个包中。在散布的消息穿过所有在发送队列中的消息发送时，这样就把对时间敏感的递送与每包仅发送<span>n</span>条消息的能力联合起来了。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"><br></span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"><br></span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"></p><h2 id="数据包层级应答"><span style="font-size:18.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">数据包层级应答</span></h2> <p></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="line-height: 150%; font-size: 12pt; font-family: 微软雅黑, sans-serif; color: rgb(34, 34, 34);">让我们行动起来实现它。</span> <span style="line-height: 150%; color: rgb(34, 34, 34); font-family: 微软雅黑, sans-serif; font-size: 12pt;">这种可靠性系统的基础是每个包的应答。</span></p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">但为什么应答是在数据包层级而不是在消息层级呢？简要截说原因就是包的数量会远远少于消息的数量。假设每个包中有<span>32</span>或<span>64</span>条消息，显然让一个包含<span>32</span>或<span>64</span>条消息的包来应答会比让每个消息都分别应答要高效得多。</span> </p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">这样同样也增加了灵活性，因为你可以在数据包层级应答上构建其他可靠性系统，不仅仅是为了可靠有序的消息。例如，使用了数据包层级应答，你就知道哪一个时间先决的不可靠状态更新已结束，所以你可以轻易地构建一个系统，在一旦一个数据包所包含的最后一个状态更新已经应答时，停止发送不再改变的对象状态。</span> </p><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><span style="font-size:12.0pt;line-height:150%;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">为实现数据包层级的应答，在每个包的前面添加如下的报头：</span></p><div><div id="highlighter_102525" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">struct</code> <code class="cpp plain">Header</code></div><div class="line number2 index1 alt1"><code class="cpp plain">{</code></div><div class="line number3 index2 alt2"><code class="cpp spaces">    </code><code class="cpp plain">uint16_t sequence;</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">    </code><code class="cpp plain">uint16_t ack;</code></div><div class="line number5 index4 alt2"><code class="cpp spaces">    </code><code class="cpp plain">uint32_t ack_bits;</code></div><div class="line number6 index5 alt1"><code class="cpp plain">};</code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left" style="line-height: 150%; vertical-align: baseline;"><br></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">这些报头元素组合起来以创建应答系统：</span> </p><ul type="disc"><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><b><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;     border:none windowtext 1.0pt;padding:0cm">sequence</span></b><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;"> </span><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">是一个数字，随每个数据包发送而增长（并且在达到<span>65535</span>后回往复）。</span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><b><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;     border:none windowtext 1.0pt;padding:0cm">ack</span></b><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;"> </span><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">是从另一方接收到的最新的数据包序列号。</span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><b><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;     border:none windowtext 1.0pt;padding:0cm">ack_bits</span></b><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;"> </span><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">是一个位字段，它编码与<b><span style="border:none windowtext 1.0pt;padding:0cm">ack</span></b>相关的收到的数据包组合：如果位<b><span style="border:none windowtext 1.0pt;padding:0cm">n</span></b>已经设置，即<span> <b><span style="border:none windowtext 1.0pt;padding:     0cm">ack–</span></b> <b><span style="border:none windowtext 1.0pt;     padding:0cm">n</span></b> </span>数据包被接收了。</span> </li></ul><p class="MsoNormal" align="left" style="vertical-align: baseline;"><b><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm">ack_bits</span></b><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"> </span><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">不仅是一个节省带宽的巧妙的编码，它同样也增加了<u><span style="border:none windowtext 1.0pt;padding:0cm">信息冗余</span></u>来抵御包的丢失。每个应答码要被发送<span>32</span>次。如果有一个包丢失了，仍然有其他<span>31</span>个包有着相同的应答码。从统计上来说，应答码还是非常有可能送达的。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"><br></span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">但突发的传送数据包的丢失还是有可能发生的，所以重要的是要注意：</span> </p><ol type="1"><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">如果你收到一个数据包<span>n</span>的应答码，那么这个包<u><span style="border:none windowtext 1.0pt;     padding:0cm">肯定已经收到</span></u>了。</span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">如果你没有收到应答码，那么这个包就<i><span style="border:none windowtext 1.0pt;padding:0cm">很有可能</span></i><span> </span>没有被收到。但是<span>…</span>它也许会是，仅是应答码没有送达。<u><span style="border:none windowtext 1.0pt;padding:0cm">这种情况是极其罕见的。</span></u> </span> </li></ol><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">以我的经验，没有必要设计完善的应答机制。在一个极少丢应答码的系统上构建一个可靠性系统并不会增加什么大问题。但对于在所有情况下来测试这个系统的工作将会成为很大的挑战，因为还要考虑应答码丢失的边界情况。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">所以如果你自己实现这个系统的话，请设置一个浸泡测试来覆盖糟糕的网络情况，用来确保你的应答系统是在正确的工作，相关地，你的消息系统的执行实际上是在这些网络情况下<i><u>可靠地而且有序的</u></i>交付可靠有序消息。以我之见（并且我已经写了许多这样的系统的变式至少有十次了），这是确保正确行为的一个必要步骤。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">你在这篇文章的示例源代码中会找到这样一个浸泡测试，它对<span><a rel="noopener" href="https://www.patreon.com/gafferongames" target="_blank"><span style="color:#DD3333">patreon</span><span style="color:#DD3333"><span>支持</span></span></a></span>是有效的，并且也在开源网络库<span><a rel="noopener" href="http://www.libyojimbo.com/" target="_blank"><span style="color:#DD3333">libyojimbo</span></a></span>中。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"><br></span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"><br></span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"></p><h2 id="序列缓冲区"><span style="font-size:18.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">序列缓冲区</span></h2> <p></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">为实现这个应答系统，我们在发送方还需要一个数据结构来追踪一个数据包是否已经被应答，这样我们就可以忽略冗余的应答（每个包会通过<span> <b><span style="border:none windowtext 1.0pt;padding:0cm">ack_bits</span></b></span>多次应答）。我们同样在接收方也还需要一个数据结构来追踪那些已经收到的包，这样我们就可以在数据包的报头填写<b><span style="border:none windowtext 1.0pt;padding:0cm">ack_bits</span></b>的值。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">这个数据结构应该具有以下属性：</span> </p><ul type="disc"><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">常量时间内插入（插入可能会是<i><u><span style="border:none windowtext 1.0pt;padding:0cm">随机</span></u></i>的，例如乱序数据包<span>…</span>）</span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">给定的数据包的序列号在常量时间内查询一个条目是否存在</span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">对给定的数据包序列号，在常量时间内访问数据存储</span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">常量时间内删除条目</span> </li></ul><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">你可能会想。哦，当然，<i><u><span style="border:none windowtext 1.0pt;padding:0cm">哈希表</span></u></i>。但还有一个更简单的方法：</span></p><div><div id="highlighter_389542" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div><div class="line number15 index14 alt2">15</div><div class="line number16 index15 alt1">16</div><div class="line number17 index16 alt2">17</div><div class="line number18 index17 alt1">18</div><div class="line number19 index18 alt2">19</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">const</code> <code class="cpp color1 bold">int</code> <code class="cpp plain">BufferSize = 1024;</code></div><div class="line number2 index1 alt1"> </div><div class="line number3 index2 alt2"><code class="cpp plain">uint32_t sequence_buffer[BufferSize];</code></div><div class="line number4 index3 alt1"> </div><div class="line number5 index4 alt2"><code class="cpp keyword bold">struct</code> <code class="cpp plain">PacketData</code></div><div class="line number6 index5 alt1"><code class="cpp plain">{</code></div><div class="line number7 index6 alt2"><code class="cpp spaces">    </code><code class="cpp color1 bold">bool</code> <code class="cpp plain">acked;</code></div><div class="line number8 index7 alt1"><code class="cpp plain">};</code></div><div class="line number9 index8 alt2"> </div><div class="line number10 index9 alt1"><code class="cpp plain">PacketData packet_data[BufferSize];</code></div><div class="line number11 index10 alt2"> </div><div class="line number12 index11 alt1"><code class="cpp plain"><code>PacketData * GetPacketData( uint16_t sequence )</code></code></div><div class="line number13 index12 alt2"><code class="cpp plain">{</code></div><div class="line number14 index13 alt1"><code class="cpp spaces">    </code><code class="cpp keyword bold">const</code> <code class="cpp color1 bold">int</code> <code class="cpp plain">index = sequence % BufferSize;</code></div><div class="line number15 index14 alt2"><code class="cpp spaces">    </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( sequence_buffer[index] == sequence )</code></div><div class="line number16 index15 alt1"><code class="cpp spaces">        </code><code class="cpp keyword bold">return</code> <code class="cpp plain">&amp;packet_data[index];</code></div><div class="line number17 index16 alt2"><code class="cpp spaces">    </code><code class="cpp keyword bold">else</code></div><div class="line number18 index17 alt1"><code class="cpp spaces">        </code><code class="cpp keyword bold">return</code> <code class="cpp plain">NULL;</code></div><div class="line number19 index18 alt2"><code class="cpp plain">}</code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left" style="vertical-align: baseline;"><br></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">你在这可以看到的窍门是这个滚动的缓冲区是以序列号来作为索引的：</span> </p><div style="border:solid #F0F0F0 1.0pt;border-left:solid #E0E0E0 2.25pt;padding:0cm 0cm 0cm 0cm;background:whitesmoke"><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline; border: none; padding: 0cm; background-image: initial; background-attachment: initial; background-size: initial; background-origin: initial; background-clip: initial; background-position: initial; background-repeat: initial;"><span style="font-family:&quot;Courier New&quot;;color:#222222">const int index =sequence % BufferSize;</span> </p></div><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">这是可行的，因为我们并不在意旧条目破坏。随着序列号的递增，旧的条目也自然而然地随着我们插入了新条目而被重写。<span>sequence_buffer[index]</span>的值是用来测试该索引的条目是否实际上与你所搜寻的序列号相符。一个缓冲序列的值是<span>0xFFFFFFFF </span>就表示一个空的条目并自然地对任何序列号查询返回<span>NULL</span>，没有任何其他（代码）分支。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">当条目被顺序添加，就像一个被发送的队列，对插入所需要做的就是把这个序列缓冲区的值更新为新的序列号并且在该索引处重写这个数据：</span></p><div><div id="highlighter_839387" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">PacketData &amp; InsertPacketData( uint16_t sequence )</code></div><div class="line number2 index1 alt1"><code class="cpp plain">{</code></div><div class="line number3 index2 alt2"><code class="cpp spaces">    </code><code class="cpp keyword bold">const</code> <code class="cpp color1 bold">int</code> <code class="cpp plain">index = sequence % BufferSize;</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">    </code><code class="cpp plain">sequence_buffer[index] = sequence;</code></div><div class="line number5 index4 alt2"><code class="cpp spaces">    </code><code class="cpp keyword bold">return</code> <code class="cpp plain">packet_data[index];</code></div><div class="line number6 index5 alt1"><code class="cpp plain">}</code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left" style="vertical-align: baseline;"><br></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">但在接收端数据包以乱序到达并且有一部分丢失。在高得离谱的丢包率下（<span>99%</span>），我就会看到旧的序列缓冲区条目还存在，但是新条目的序列号已经超过了<span>65535</span>并且循环到达了旧条目之前，并且打破了我的应答逻辑（导致错误应答并打破了可靠性，这时发送方会真的认为对方已经接收到了一些东西但其实并不是<span>…</span>）</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">解决这个问题的办法是遍历上一个最高的插入序列与最新收到的插入序列之间的条目（如果它是更加新的话）并在缓冲区清除这些条目即都置为<span>0xFFFFFFFF</span>。现在，在一般情况下，插入操作是<i><u><span style="border:none windowtext 1.0pt;padding:0cm">非常接近</span></u></i><span> </span>时间常量的，但最糟的情况是，在先前最高的序列号和当前插入的序列号之间线性遍历的次数<span>n</span>等于缓冲区的长度。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">在我们继续之前，我想指出，你可以用这个数据结构做更多事情而不仅是对于应答码。例如，你可以加入发送时间，来扩展每个包的数据：</span></p><div><div id="highlighter_615471" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">struct</code> <code class="cpp plain">PacketData</code></div><div class="line number2 index1 alt1"><code class="cpp plain">{</code></div><div class="line number3 index2 alt2"><code class="cpp spaces">    </code><code class="cpp color1 bold">bool</code> <code class="cpp plain">acked;</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">    </code><code class="cpp color1 bold">double</code> <code class="cpp plain">send_time;</code></div><div class="line number5 index4 alt2"><code class="cpp plain">};</code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left" style="vertical-align: baseline;"><br></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">有了这些信息你可以对往返时间通过做指数级的平滑取平均数做修正，最终得到合理的预期往返时间。你甚至可以看到在发送数据包的序列缓存区的数据包会比你<span>RTT</span>预计的（你现在应该已经收到了它们的应答码<span>…</span>）要旧，通过这个往返时间对还没有应答的包做判断，来决定创建你的数据包丢失预计。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"><br></span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"><br></span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"></p><h2 id="应答算法"><span style="font-size:18.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">应答算法</span></h2> <p></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">现在我们来把注意力集中在数据包层级应答的实际算法上。</span><span style="color: rgb(34, 34, 34); font-family: 微软雅黑, sans-serif; font-size: 12pt;">该算法如下：</span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><b><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm">在数据包发送端：</span></b> </p><ol type="1"><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">在数据包发送缓冲区插入一个为当前发送的数据包序列号的条目，并且带着表示它还没有被应答的字段</span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">从本地接收到的数据包序列缓存和最新接收到的数据包序列号中生成<span> <b><span style="border:none windowtext 1.0pt;padding:     0cm">ack</span></b> </span>和<b><span style="border:none windowtext 1.0pt;     padding:0cm">ack_bits</span></b><span> </span></span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">填写数据包报头的<b><span style="border:none windowtext 1.0pt;padding:0cm">sequence, ack</span></b><span> </span>和<span> <b><span style="border:     none windowtext 1.0pt;padding:0cm">ack_bits</span></b> </span>值</span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">发送数据包并递增发送数据包的序列号</span> </li></ol><p class="MsoNormal" align="left" style="vertical-align: baseline;"><b><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm">在数据包接收端：</span></b> </p><ol type="1"><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">从数据包报头读取<span> <b><span style="border:none windowtext 1.0pt;padding:     0cm">sequence</span></b> </span></span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">如果<span> <b><span style="border:none windowtext 1.0pt;padding:     0cm">sequence</span></b> </span>比之前的最新收到的数据包序列号要新，就更新最新的接收到的数据包序列号</span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">在接收数据包序列缓冲区中为这个数据包插入一个条目</span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">从数据包报头中的<b><span style="border:none windowtext 1.0pt;padding:0cm">ack</span></b>和<b><span style="border:none windowtext 1.0pt;padding:0cm">ack_bits</span></b>解码应答的数据包序列号组合</span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">迭代应答的数据包序列号以及任何还没有被应答的数据包调用<span> <b><span style="border:none windowtext 1.0pt;padding:     0cm">OnPacketAcked</span></b>( uint16_t sequence ) </span>在数据包发送缓冲区把这个数据包设置为<span>‘</span>已应答的<span>’</span>。</span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;"><br></span></li></ol><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">重要的一点是这个算法是在两端都可以执行的，所以如果你有一个客户端和一个服务端，然后每一方的连接运行着同样的逻辑，维护自己的序列号发送的数据包，跟踪最新从另一方收到的数据包序列<span>#</span>还有从一个序列缓冲区里接收到的数据包中生成<b><span style="border:none windowtext 1.0pt;padding:0cm">sequence, ack</span></b><span> </span>和<b><span style="border:none windowtext 1.0pt;padding:0cm">ack_bits</span></b><span> </span>来发送到另一方。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">并且这真的就是和它有关的全部了。现在当一个数据包被另一方接收到时，你有一个回调：<b><span style="border:none windowtext 1.0pt;padding:0cm">OnPacketAcked</span></b><span> </span>。这个可靠性系统的关键就在于你得知道哪个数据包被接收，你可以在你想的媒介之上创建<i><u><span style="border:none windowtext 1.0pt;padding:0cm">任何</span></u></i><span> </span>可靠性系统。它不仅限于可靠有序的消息。例如，你可以用它确认哪个不可靠的状态更新已经完成了，用以实现基于每个物体的增量编码。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"><br></span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"><br></span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"></p><h2 id="消息对象"><span style="font-size:18.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">消息对象</span></h2> <p></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">消息是小型的对象（比数据包大小要小，所以很多消息装配在一个典型的数据包中）并且知道如何将它们自己序列化。在我的系统里，它们使用一个</span><u><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#DD3333">统一的序列化函数</span></u><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">来执行序列化。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">这个序列化的函数是模板化的，所以你只要写它一次它就会处理读、写以及<i><u><span style="border:none windowtext 1.0pt;padding:0cm">测量</span></u></i> 。<i><span style="border:none windowtext 1.0pt;padding:0cm"> </span></i></span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">是的。测量。我喜欢的一个技巧就是有一个虚拟流类叫做<b><span style="border:none windowtext 1.0pt;padding:0cm">MeasureStream</span></b>，如果你调用了序列化函数，它不参与任何的序列化，而只是测量<i><u><span style="border:none windowtext 1.0pt;padding:0cm">可能</span></u></i>被写入的比特数。这对于解决哪个消息要装载到你的数据包里，特别是当消息可以有任意复杂的序列化函数的情况时是特别有用的。</span></p><div><div id="highlighter_699334" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div><div class="line number15 index14 alt2">15</div><div class="line number16 index15 alt1">16</div><div class="line number17 index16 alt2">17</div><div class="line number18 index17 alt1">18</div><div class="line number19 index18 alt2">19</div><div class="line number20 index19 alt1">20</div><div class="line number21 index20 alt2">21</div><div class="line number22 index21 alt1">22</div><div class="line number23 index22 alt2">23</div><div class="line number24 index23 alt1">24</div><div class="line number25 index24 alt2">25</div><div class="line number26 index25 alt1">26</div><div class="line number27 index26 alt2">27</div><div class="line number28 index27 alt1">28</div><div class="line number29 index28 alt2">29</div><div class="line number30 index29 alt1">30</div><div class="line number31 index30 alt2">31</div><div class="line number32 index31 alt1">32</div><div class="line number33 index32 alt2">33</div><div class="line number34 index33 alt1">34</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">struct</code> <code class="cpp plain">TestMessage : </code><code class="cpp keyword bold">public</code> <code class="cpp plain">Message</code></div><div class="line number2 index1 alt1"><code class="cpp plain">{</code></div><div class="line number3 index2 alt2"><code class="cpp spaces">    </code><code class="cpp plain">uint32_t a,b,c;</code></div><div class="line number4 index3 alt1"> </div><div class="line number5 index4 alt2"><code class="cpp spaces">    </code><code class="cpp plain">TestMessage()</code></div><div class="line number6 index5 alt1"><code class="cpp spaces">    </code><code class="cpp plain">{</code></div><div class="line number7 index6 alt2"><code class="cpp spaces">        </code><code class="cpp plain">a = 0;</code></div><div class="line number8 index7 alt1"><code class="cpp spaces">        </code><code class="cpp plain">b = 0;</code></div><div class="line number9 index8 alt2"><code class="cpp spaces">        </code><code class="cpp plain">c = 0;</code></div><div class="line number10 index9 alt1"><code class="cpp spaces">    </code><code class="cpp plain">}</code></div><div class="line number11 index10 alt2"> </div><div class="line number12 index11 alt1"><code class="cpp spaces">    </code><code class="cpp keyword bold">template</code> <code class="cpp plain">&lt;</code><code class="cpp keyword bold">typename</code> <code class="cpp plain">stream</code><code class="cpp string"></code><code class="cpp plain">&gt; </code><code class="cpp color1 bold">bool</code> <code class="cpp plain">Serialize( Stream &amp; stream )</code></div><div class="line number13 index12 alt2"><code class="cpp spaces">    </code><code class="cpp plain">{ </code></div><div class="line number14 index13 alt1"><code class="cpp spaces">        </code><code class="cpp plain">serialize_bits( stream, a, 32 );</code></div><div class="line number15 index14 alt2"><code class="cpp spaces">        </code><code class="cpp plain">serialize_bits( stream, b, 32 );</code></div><div class="line number16 index15 alt1"><code class="cpp spaces">        </code><code class="cpp plain">serialize_bits( stream, c, 32 );</code></div><div class="line number17 index16 alt2"><code class="cpp spaces">        </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">true</code><code class="cpp plain">;</code></div><div class="line number18 index17 alt1"><code class="cpp spaces">    </code><code class="cpp plain">}</code></div><div class="line number19 index18 alt2"> </div><div class="line number20 index19 alt1"><code class="cpp spaces">    </code><code class="cpp keyword bold">virtual</code> <code class="cpp plain">SerializeInternal( WriteStream &amp; stream )</code></div><div class="line number21 index20 alt2"><code class="cpp spaces">    </code><code class="cpp plain">{</code></div><div class="line number22 index21 alt1"><code class="cpp spaces">        </code><code class="cpp keyword bold">return</code> <code class="cpp plain">Serialize( stream );</code></div><div class="line number23 index22 alt2"><code class="cpp spaces">    </code><code class="cpp plain">}</code></div><div class="line number24 index23 alt1"> </div><div class="line number25 index24 alt2"><code class="cpp spaces">    </code><code class="cpp keyword bold">virtual</code> <code class="cpp plain">SerializeInternal( ReadStream &amp; stream )</code></div><div class="line number26 index25 alt1"><code class="cpp spaces">    </code><code class="cpp plain">{</code></div><div class="line number27 index26 alt2"><code class="cpp spaces">        </code><code class="cpp keyword bold">return</code> <code class="cpp plain">Serialize( stream );</code></div><div class="line number28 index27 alt1"><code class="cpp spaces">    </code><code class="cpp plain">}</code></div><div class="line number29 index28 alt2"> </div><div class="line number30 index29 alt1"><code class="cpp spaces">    </code><code class="cpp keyword bold">virtual</code> <code class="cpp plain">SerializeInternal( MeasureStream &amp; stream )</code></div><div class="line number31 index30 alt2"><code class="cpp spaces">    </code><code class="cpp plain">{</code></div><div class="line number32 index31 alt1"><code class="cpp spaces">        </code><code class="cpp keyword bold">return</code> <code class="cpp plain">Serialize( stream );        </code></div><div class="line number33 index32 alt2"><code class="cpp spaces">    </code><code class="cpp plain">}</code></div><div class="line number34 index33 alt1"><code class="cpp plain">};</code><code class="cpp keyword bold"></code><code class="cpp plain"></code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left" style="vertical-align: baseline;"><br></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">这里的技巧是桥接统一模板的序列化函数（所以你只需要写一次）与虚拟序列化方法，这通过从虚函数每个流类型中调入它。我通常用一个宏来打包这个引用，但它在上文的代码中这个宏已经被展开，所以你可以看到发生了什么。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">现在，假设你有一个基于消息的指针可以让你做到这样并且它只是通过重载来工作：</span></p><div><div id="highlighter_300994" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">Message <em> message = CreateSomeMessage();</em></code></div><div class="line number2 index1 alt1"><code class="cpp plain">message-&gt;SerializeInternal( stream );</code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">另外一个就是如果你在编译时间知道了消息的完整组合，就可以为每个类型在被调入序列化函数之前实现一个关于消息类型转换为确切消息类型的大的<span>switch</span>语句。我在过去已经在控制台平台实现的这个消息系统这么做了（如<span>PS3 SPUs</span>），但对于现在（<span>2016</span>）的应用程序，虚函数的总开销是忽略不计的。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">消息从一个基类派生，这个基类提供一个通用的接口例如序列化、消息的查询类型还有引用计数。引用计数是必要的，因为消息是通过指针传递的并且在应答之前不只是存储在消息发送队列，而且也存储在外发的数据包中，包本身是<span>C++</span>结构体。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">这是一个策略，就是避免通过指针传递消息和数据包来复制数据。别的一些场景（理想的情况是在一个单独的线程）它们里面的数据包和消息会序列化到一个缓冲区。最终，当不再有对存在消息发送队列的消息的引用时（消息已经被应答）并且没有数据包包含保留在数据包发送队列里的消息，消息即是被销毁的。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">我们也需要一种方式来创建消息。我用一个消息的工厂类来做这件事情，它有一个被复写的虚函数来根据类型创建一个消息。如果这个数据包工厂还知道消息类型的总数量就好了，那样我们就可以在网络上序列化一个消息类型，因为有严格的界限和在有效范围之外的消息类型值的包的恶意丢弃：</span></p><div><div id="highlighter_935705" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div><div class="line number15 index14 alt2">15</div><div class="line number16 index15 alt1">16</div><div class="line number17 index16 alt2">17</div><div class="line number18 index17 alt1">18</div><div class="line number19 index18 alt2">19</div><div class="line number20 index19 alt1">20</div><div class="line number21 index20 alt2">21</div><div class="line number22 index21 alt1">22</div><div class="line number23 index22 alt2">23</div><div class="line number24 index23 alt1">24</div><div class="line number25 index24 alt2">25</div><div class="line number26 index25 alt1">26</div><div class="line number27 index26 alt2">27</div><div class="line number28 index27 alt1">28</div><div class="line number29 index28 alt2">29</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">enum</code> <code class="cpp plain">TestMessageTypes</code></div><div class="line number2 index1 alt1"><code class="cpp plain">{</code></div><div class="line number3 index2 alt2"><code class="cpp spaces">    </code><code class="cpp plain">TEST_MESSAGE_A,</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">    </code><code class="cpp plain">TEST_MESSAGE_B,</code></div><div class="line number5 index4 alt2"><code class="cpp spaces">    </code><code class="cpp plain">TEST_MESSAGE_C,</code></div><div class="line number6 index5 alt1"><code class="cpp spaces">    </code><code class="cpp plain">TEST_MESSAGE_NUM_TYPES</code></div><div class="line number7 index6 alt2"><code class="cpp plain">};</code></div><div class="line number8 index7 alt1"> </div><div class="line number9 index8 alt2"><code class="cpp comments">// message definitions omitted</code></div><div class="line number10 index9 alt1"> </div><div class="line number11 index10 alt2"><code class="cpp keyword bold">class</code> <code class="cpp plain">TestMessageFactory : </code><code class="cpp keyword bold">public</code> <code class="cpp plain">MessageFactory</code></div><div class="line number12 index11 alt1"><code class="cpp plain">{ </code></div><div class="line number13 index12 alt2"><code class="cpp keyword bold">public</code><code class="cpp plain">:</code></div><div class="line number14 index13 alt1"> </div><div class="line number15 index14 alt2"><code class="cpp spaces">    </code><code class="cpp plain">Message  Create( </code><code class="cpp color1 bold">int</code> <code class="cpp plain">type )</code></div><div class="line number16 index15 alt1"><code class="cpp spaces">    </code><code class="cpp plain">{</code></div><div class="line number17 index16 alt2"><code class="cpp spaces">        </code><code class="cpp keyword bold">switch</code> <code class="cpp plain">( type )</code></div><div class="line number18 index17 alt1"><code class="cpp spaces">        </code><code class="cpp plain">{</code></div><div class="line number19 index18 alt2"><code class="cpp spaces">            </code><code class="cpp keyword bold">case</code> <code class="cpp plain">TEST_MESSAGE_A: </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">new</code> <code class="cpp plain">TestMessageA();</code></div><div class="line number20 index19 alt1"><code class="cpp spaces">            </code><code class="cpp keyword bold">case</code> <code class="cpp plain">TEST_MESSAGE_B: </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">new</code> <code class="cpp plain">TestMessageB();</code></div><div class="line number21 index20 alt2"><code class="cpp spaces">            </code><code class="cpp keyword bold">case</code> <code class="cpp plain">TEST_MESSAGE_C: </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">new</code> <code class="cpp plain">TestMessageC();</code></div><div class="line number22 index21 alt1"><code class="cpp spaces">        </code><code class="cpp plain">}</code></div><div class="line number23 index22 alt2"><code class="cpp spaces">    </code><code class="cpp plain">}</code></div><div class="line number24 index23 alt1"> </div><div class="line number25 index24 alt2"><code class="cpp spaces">    </code><code class="cpp keyword bold">virtual</code> <code class="cpp color1 bold">int</code> <code class="cpp plain">GetNumTypes() </code><code class="cpp keyword bold">const</code></div><div class="line number26 index25 alt1"><code class="cpp spaces">    </code><code class="cpp plain">{</code></div><div class="line number27 index26 alt2"><code class="cpp spaces">        </code><code class="cpp keyword bold">return</code> <code class="cpp plain">TEST_MESSAGE_NUM_TYPES;</code></div><div class="line number28 index27 alt1"><code class="cpp spaces">    </code><code class="cpp plain">}</code></div><div class="line number29 index28 alt2"><code class="cpp plain">};</code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left" style="vertical-align: baseline;"><br></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">再次重申，这是一个引用并且通常是被包裹在宏里面的，但下面要说明的就是它具体是怎么回事了。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"><br></span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"><br></span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"></p><h2 id="可靠的有序消息算法"><span style="font-size:18.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">可靠的有序消息算法</span></h2> <p></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">现在让我们来着手于如何在应答系统中实现可靠有序消息的细节。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">发送可靠有序消息的算法如下：</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><b><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm">对于消息发送：</span></b> </p><ol type="1"><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">使用测量流测量消息序列化后的大小</span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">插入消息指针和它序列化的位数到一个序列缓冲区，它以消息<span>id</span>为索引。设置消息最后被发送的时间为<span>-1</span></span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">递增发送的消息的<span>id</span></span> </li></ol><p class="MsoNormal" align="left" style="vertical-align: baseline;"><b><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm">对于数据包发送：</span></b> </p><ol type="1"><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">从左<span>-&gt;</span>右（递增的消息<span>id</span>顺序）遍历在最早的未应答消息<span>id</span>和最新插入的消息<span>id</span>之间的发送消息序列缓冲区的这组消息。</span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><b><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;border:none windowtext 1.0pt;     padding:0cm">超级重要的：</span></b><span style="font-size:12.0pt;     font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;"> </span><span style="font-size:12.0pt;     font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">不要发送一个接收方不能缓冲的消息<span>id</span>，不然你会破坏消息的应答（由于这个消息不能被缓冲，但包含它的数据包会被应答，发送方就会认为这个消息已经被接收了，就不再重新发送它了）。这意味着你必须不能发送一个消息<span>id</span>等于或比最早的未应答消息的<span>id</span>加上消息接收缓冲区大小要新。</span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">对于那些在最后<span>0.1</span>秒没有被发送的消息<u><span style="border:none windowtext 1.0pt;     padding:0cm">并且</span></u>适合我们留在数据包的有效空间，就把它追加到消息列表去发送。根据迭代顺序得到优先级。</span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">包括在外发数据包中的消息，并且要为每个消息添加一个引用。确保每个数据包的析构函数中减了引用计数。</span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">在数据包<b><span style="border:none windowtext 1.0pt;padding:0cm">n</span></b>存储消息的数量并且消息的标识数组包含在一个序列缓冲区的数据包中，以外发数据包的序列号为索引。</span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">把数据包添加到数据包发送队列。</span> </li></ol><p class="MsoNormal" align="left" style="vertical-align: baseline;"><b><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm">对于数据包接收：</span></b> </p><ol type="1"><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">遍历包含在数据包中的消息组合并且把它们插入到消息接收队列缓冲区，以它们的消息<span>id</span>为索引。</span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">前面的应答系统自动地应答我们刚刚收到的数据包序列号。</span> </li></ol><p class="MsoNormal" align="left" style="vertical-align: baseline;"><b><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm">对于数据包应答：</span></b> </p><ol type="1"><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">用序列号查找包含在数据包中消息组合的标识部分。</span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">从消息发送队列中移除那些已经存在的消息，并减少它们的引用计数。</span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">通过从发送消息队列缓冲区中之前未应答消息的<span>id</span>的转寄来更新最后一个未应答的消息的<span>id</span>，直到发现一个有效的消息条目，或者你会到达当前发送消息的<span>id</span>。以先到者为准。 </span> </li></ol><p class="MsoNormal" align="left" style="vertical-align: baseline;"><b><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm">对于消息接收：</span></b> </p><ol type="1"><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">检查接受消息缓冲区确保当前收到消息的<span>id</span>对应的消息是否存在。</span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">如果消息存在，将它从消息队列缓冲区中移除，递增接收消息的<span>id</span>并给这个消息返回一个指针。</span> </li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;">如果否，就是没有有效的消息可接收。返回<b><span style="border:none windowtext 1.0pt;padding:0cm">NULL</span></b>。</span> </li></ol><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">总之，消息要保持被包含在数据包中直到这个数据包包含的消息得到应答。我们在发送者方使用一个数据结构来给消息标识的组合映射数据包序列号以便应答。当消息被应答时，要从发送队列中移除。对于接收方，以乱序到达的消息会被存储在一个序列缓冲区，并以消息<span>id</span>为索引，这个<span>id</span>会让我们以它们被发送的顺序接收它们。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"><br></span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"></p><h2 id="最终的结果"><span style="font-size:18.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">最终的结果</span></h2> <p></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">在发送方，这为用户提供了一个像这样的接口：</span></p><div><div id="highlighter_731637" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">TestMessage <em> message = (TestMessage</em>) factory.Create( TEST_MESSAGE );</code></div><div class="line number2 index1 alt1"><code class="cpp keyword bold">if</code> <code class="cpp plain">( message )</code></div><div class="line number3 index2 alt2"><code class="cpp plain">{</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">    </code><code class="cpp plain">message-&gt;a = 1;</code></div><div class="line number5 index4 alt2"><code class="cpp spaces">    </code><code class="cpp plain">message-&gt;b = 2;</code></div><div class="line number6 index5 alt1"><code class="cpp spaces">    </code><code class="cpp plain">message-&gt;c = 3;</code></div><div class="line number7 index6 alt2"><code class="cpp spaces">    </code><code class="cpp plain">connection.SendMessage( message );</code></div><div class="line number8 index7 alt1"><code class="cpp plain">}</code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left" style="vertical-align: baseline;"><br></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">还有在接收方：</span></p><div><div id="highlighter_315020" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">while</code> <code class="cpp plain">( </code><code class="cpp keyword bold">true</code> <code class="cpp plain">)</code></div><div class="line number2 index1 alt1"><code class="cpp plain">{</code></div><div class="line number3 index2 alt2"><code class="cpp spaces">    </code><code class="cpp plain">Message <em> message = connection.ReceiveMessage();</em></code></div><div class="line number4 index3 alt1"><code class="cpp spaces">    </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( !message )</code></div><div class="line number5 index4 alt2"><code class="cpp spaces">        </code><code class="cpp keyword bold">break</code><code class="cpp plain">;</code></div><div class="line number6 index5 alt1"> </div><div class="line number7 index6 alt2"><code class="cpp spaces">    </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( message-&gt;GetType() == TEST_MESSAGE )</code></div><div class="line number8 index7 alt1"><code class="cpp spaces">    </code><code class="cpp plain">{</code></div><div class="line number9 index8 alt2"><code class="cpp spaces">        </code><code class="cpp plain">TestMessage  testMessage = (TestMessage*) message;</code></div><div class="line number10 index9 alt1"><code class="cpp spaces">        </code><code class="cpp comments">// process test message</code></div><div class="line number11 index10 alt2"><code class="cpp spaces">    </code><code class="cpp plain">}</code></div><div class="line number12 index11 alt1"> </div><div class="line number13 index12 alt2"><code class="cpp spaces">    </code><code class="cpp plain">factory.Release( message );</code></div><div class="line number14 index13 alt1"><code class="cpp plain">}</code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left" style="vertical-align: baseline;"><br></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">正如你所看到的，它已经是简单得不能再简单了。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">如果这几个接口有引起你的兴趣，请看看我的新开源库<span> <a rel="noopener" href="https://github.com/networkprotocol/libyojimbo" target="_blank"><span style="color:#DD3333">libyojimbo</span></a></span>。</span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">我希望你到现在为止对这个系列的文章是享受的<span><a rel="noopener" href="http://www.patreon.com/gafferongames" target="_blank"><span style="color:#DD3333"><span>请在 patreon</span></span><span style="color:#DD3333"><span>上支持我的写作</span></span></a></span>，并且我将更快写新的文章，再者你会在加州大学伯克利分校软件的开源许可证下获得这篇文章的示例源代码。<b><u><span style="border:none windowtext 1.0pt;padding:0cm">谢谢你的支持！</span></u></b></span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;Lucida Sans Unicode&quot;,&quot;sans-serif&quot;;color:#222222"> </span> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><b><span style="font-size:18.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222;border:none windowtext 1.0pt;padding:0cm">即将到来：</span></b><b><span style="font-size:18.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222"><a rel="noopener" href="http://gafferongames.com/building-a-game-network-protocol/client-server-connection/" target="_blank"><span style="color:#DD3333"><span>客户端与服务器的连接</span></span></a></span></b> </p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">在<span>“</span>创建一个游戏网络协议<span>”</span>的下一篇文章会展示你如何在<span>UDP</span>之上创建你自己的客户端<span>/</span>服务器连接层，它会实现挑战<span>/</span>响应，会在服务器上分配客户端插槽，当服务器爆满或检测超时就拒绝客户端的连接。</span> </p><p class="MsoNormal"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;"> </span> </p><p class="MsoNormal"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;"> </span> </p><p class="MsoNormal"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">【版权声明】</span> </p><p class="MsoNormal"><span style="font-size:12.0pt;font-family:&quot;微软雅黑&quot;,&quot;sans-serif&quot;;color:#222222">原文作者未做权利声明，视为共享知识产权进入公共领域，自动获得授权；</span> </p><p class="MsoNormal"><span> </span> </p></div>                    <br>                

          
        
      


      

    
      <footer class="post-footer">
        

        

        

        
        
          <div class="post-eof"></div>
        
      </footer>
      
    </div>
    
    
    

    

    

    

  </div>
  
  
  
  </article>


      
    
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hulinhong.com/2017/03/12/ssl_tls_illustrated/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="no5ix">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="烫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/12/ssl_tls_illustrated/" itemprop="url">SSL/TLS详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-12T06:00:54+00:00">
                2017-03-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NP/" itemprop="url" rel="index">
                    <span itemprop="name">NP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    




    
    
    
    <div class="post-body" itemprop="articleBody">
      
      

      

      
      
        <div class="post-eof"></div>
      

      
      

      
        
          <p>互联网的通信安全，建立在 SSL/TLS 协议之上。</p>
<p>本文简要介绍 SSL/TLS 协议的运行机制。文章的重点是设计思想和运行过程，不涉及具体的实现细节。如果想了解这方面的内容，请参阅 <a href="http://tools.ietf.org/html/rfc5246" target="_blank" rel="noopener">RFC 文档</a>。</p>
<p><strong>. . .</strong>
          <!--noindex-->
          
          <!--/noindex-->
        
      


      

    
      <footer class="post-footer">
        

        

        

        
        
          <div class="post-eof"></div>
        
      </footer>
      
    </p></div>
    
    
    

    

    

    

  </div>
  
  
  
  </article>


      
    
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hulinhong.com/2017/03/11/kbe_ue4_demo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="no5ix">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="烫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/11/kbe_ue4_demo/" itemprop="url">KBE的UE4的demo大体解读</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-11T11:41:58+00:00">
                2017-03-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/UE4/" itemprop="url" rel="index">
                    <span itemprop="name">UE4</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    




    
    
    
    <div class="post-body" itemprop="articleBody">
      
      

      

      
      
        <div class="post-eof"></div>
      

      
      

      
        
          
            <p>写到一半发现论坛的热门帖子里官方写了个u3d的demo源码解析,  内容几乎重复, u3d跟ue4的demo框架流程几乎都是差不多的, 直接给出官方帖子的链接好了, 尴尬:<br><a href="http://bbs.kbengine.org/forum.php?mod=viewthread&amp;tid=166" target="_blank" rel="noopener">http://bbs.kbengine.org/forum.php?mod=viewthread&amp;tid=166</a></p>

          
        
      


      

    
      <footer class="post-footer">
        

        

        

        
        
          <div class="post-eof"></div>
        
      </footer>
      
    </div>
    
    
    

    

    

    

  </div>
  
  
  
  </article>


      
    
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hulinhong.com/2017/02/28/sending_large_blocks_of_data/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="no5ix">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="烫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/28/sending_large_blocks_of_data/" itemprop="url">构建游戏网络协议四之发送大块数据</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-28T15:13:35+00:00">
                2017-02-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/GS/" itemprop="url" rel="index">
                    <span itemprop="name">GS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    




    
    
    
    <div class="post-body" itemprop="articleBody">
      
      

      

      
      
        <div class="post-eof"></div>
      

      
      

      
        
          
            <h1 id="本篇自我总结"><a href="#本篇自我总结" class="headerlink" title="本篇自我总结"></a>本篇自我总结</h1><p>有了本系列上篇文章中的分包和重组系统为何还要这个发送大块数据系统?是否是多余的?是雷同的吗?<br>请看总结概要理清思路, 再细看文章.</p>
<h2 id="为什么需要做这个发送大块数据系统"><a href="#为什么需要做这个发送大块数据系统" class="headerlink" title="为什么需要做这个发送大块数据系统"></a>为什么需要做这个发送大块数据系统</h2><p>第一眼看上去，这种替代性的技术似乎非常类似于数据包的分包和重组，但是它的实现是完全不同的。这种实现上的差异的目的是为了解决数据包分包和重组的一个关键弱点 : 一个片段的丢失就会导致整个数据包都要被丢弃掉然后重新分包重发。</p>
<p>你可能需要这样做的一些常见的例子包括：客户端在首次加入的时候，服务器需要下发一个大的数据块给客户端(可能是世界的初始状态)、一开始用来做增量编码的基线或者是在一个多人在线网络游戏里面客户端在加载界面所等待的大块数据。</p>
<p>在这些情况下非常重要的是不仅要优雅地处理数据包的丢失，还要尽可能的利用可用的带宽并尽可能快的发送大块数据。</p>
<p>这个发送大块数据系统大致可以理解为是一个在原来分包和重组系统的基础上增加了分包确认功能, 也就是说增加了可靠性的部分.</p>
<h2 id="本篇基本术语"><a href="#本篇基本术语" class="headerlink" title="本篇基本术语"></a>本篇基本术语</h2><p>In this new system blocks of data are called chunks. Chunks are split up into slices. This name change keeps the chunk system terminology (chunks/slices) distinct from packet fragmentation and reassembly (packets/fragments).</p>
<ul>
<li>块 : 在这个新系统中，大块的数据被称为”块”(chunks)</li>
<li>片段 : 而块被分成的分包被称为”片段”(slices)</li>
</ul>
<h2 id="数据包的结构设计"><a href="#数据包的结构设计" class="headerlink" title="数据包的结构设计"></a>数据包的结构设计</h2><p>这个系统在网络上发送的数据包类型一共有两种类型：</p>
<ul>
<li><p>Slice packet片段数据包 : 这包括了一个块的片段，最多大小为1k。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SliceSize = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxSlicesPerChunk = <span class="number">256</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxChunkSize = SliceSize  MaxSlicesPerChunk;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SlicePacket</span> :</span> <span class="keyword">public</span> protocol2::Packet</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> chunkId;</span><br><span class="line">    <span class="keyword">int</span> sliceId;</span><br><span class="line">    <span class="keyword">int</span> numSlices;</span><br><span class="line">    <span class="keyword">int</span> sliceBytes;</span><br><span class="line">    <span class="keyword">uint8_t</span> data[SliceSize];</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> stream&gt; <span class="function"><span class="keyword">bool</span> <span class="title">Serialize</span><span class="params">( Stream &amp; stream )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        serialize_bits( stream, chunkId, <span class="number">16</span> );</span><br><span class="line">        serialize_int( stream, sliceId, <span class="number">0</span>, MaxSlicesPerChunk - <span class="number">1</span> );</span><br><span class="line">        serialize_int( stream, numSlices, <span class="number">1</span>, MaxSlicesPerChunk );</span><br><span class="line">        <span class="keyword">if</span> ( sliceId == numSlices - <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            serialize_int( stream, sliceBytes, <span class="number">1</span>, SliceSize );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( Stream::IsReading )</span><br><span class="line">        &#123;</span><br><span class="line">            sliceBytes = SliceSize;</span><br><span class="line">        &#125;</span><br><span class="line">        serialize_bytes( stream, data, sliceBytes );</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Ack packet确认数据包 : 一个位域bitfield指示哪些片段已经收到, we just send the entire state of all acked slices in each ack packet. When the ack packet is received (including the slice that was just received).</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AckPacket</span> :</span> <span class="keyword">public</span> protocol2::Packet </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">uint16_t</span> chunkId; </span><br><span class="line">    <span class="keyword">int</span> numSlices; </span><br><span class="line">    <span class="keyword">bool</span> acked[MaxSlicesPerChunk]; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Serialize</span><span class="params">( Stream &amp; stream )</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        serialize_bits( stream, chunkId, <span class="number">16</span> ); </span><br><span class="line">        serialize_int( stream, numSlices, <span class="number">1</span>, MaxSlicesPerChunk ); </span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numSlices; ++i ) </span><br><span class="line">            serialize_bool( stream, acked[i] ); <span class="keyword">return</span> <span class="literal">true</span>; &#125; &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="发送方的实现"><a href="#发送方的实现" class="headerlink" title="发送方的实现"></a>发送方的实现</h2><p>与之前文章介绍的数据包的分包和重组系统不同，块系统在同一时间只能由一个块正在传输。<br>发送方的策略是：</p>
<ul>
<li>持续的发送片段数据包，直到所有的片段数据包都被确认。</li>
<li>不再对已经确认过的片段数据包进行发送。</li>
</ul>
<p>对于发送方而言有一点比较微妙，实现一个片段数据包重新发送的最小延迟是一个很棒的主意，如果不这么做的话，就可能会出现这种一样情况，对于很小的块数据或者一个块的最后几个片段数据包，很容易不停的发送它们把整个网络都塞满。正是因为这一原因，我们使用了一个数组来记录每个片段数据包的上一次发送时间。重新发送延迟的一个选择是使用一个估计的网络往返时延，或者只有在超过上一次发送时间网络往返时延*1.25还没有收到确认数据包的情况才会重新发送。或者，你可以说“这根本就无所谓”，只要超过上一次发送时间100毫秒了就重新发送。我只是列举适合我自己的方案！</p>
<p>我们使用以下的数据结构来描述发送方：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChunkSender</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> sending;</span><br><span class="line">    <span class="keyword">uint16_t</span> chunkId;</span><br><span class="line">    <span class="keyword">int</span> chunkSize;</span><br><span class="line">    <span class="keyword">int</span> numSlices;</span><br><span class="line">    <span class="keyword">int</span> numAckedSlices;</span><br><span class="line">    <span class="keyword">int</span> currentSliceId;</span><br><span class="line">    <span class="keyword">bool</span> acked[MaxSlicesPerChunk];</span><br><span class="line">    <span class="keyword">uint8_t</span> chunkData[MaxChunkSize];</span><br><span class="line">    <span class="keyword">double</span> timeLastSent[MaxSlicesPerChunk];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="接收方的实现思路"><a href="#接收方的实现思路" class="headerlink" title="接收方的实现思路"></a>接收方的实现思路</h2><p>首先，接收方的设置会从块0开始。当一个片段数据包从网络上传递过来，并且能够匹配这个块id的话，“receiving”状态会从false翻转为true，第一个片段数据包的数据会插入” chunkData“变量的合适位置，片段数据包的数量会根据第一个片段数据包里面的数据进行正确的设置，已经接收到的片段数据包的数量会加一，也就是从0到1，针对每个片段数据包的接收标记里面对应这个片段数据包的项会变为true。</p>
<p>随着这个块数据的其他片段数据包的到来，会对每一个片段数据包进行检测，判断它们的id是否与当前块的id相同，如果不相同的话就会被丢弃。如果这个片段数据包已经收到过的话，那么这个包也会被丢弃。否则，这个片段数据包的数据会插入” chunkData“变量的合适位置、已经接收到的片段数据包的数量会加一、针对每个片段数据包的接收标记里面对应这个片段数据包的项会变为true。</p>
<p>这一过程会持续进行，直到接收到所有的片段数据包。一旦接收到所有的片段数据包（也就是已经接收到的片段数据包的数量等于片段数据包的数量的时候），接收方会把“receiving “状态改为false，而把”readyToRead“状态改为true。当”readyToRead”状态为true的时候，所有收到的片段数据包都会被丢弃。在这一点上，这个处理过程通常非常的短，会在收到片段数据包的同一帧进行处理，调用者会检查”我有一块数据要读取么？“并处理块数据。然后会重置数据块接收器的所有数据为默认值，除了块数据的id从0增加到1，这样我们就准备好接收下一个块了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChunkReceiver</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> receiving;</span><br><span class="line">    <span class="keyword">bool</span> readyToRead;</span><br><span class="line">    <span class="keyword">uint16_t</span> chunkId;</span><br><span class="line">    <span class="keyword">int</span> chunkSize;</span><br><span class="line">    <span class="keyword">int</span> numSlices;</span><br><span class="line">    <span class="keyword">int</span> numReceivedSlices;</span><br><span class="line">    <span class="keyword">bool</span> received[MaxSlicesPerChunk];</span><br><span class="line">    <span class="keyword">uint8_t</span> chunkData[MaxChunkSize];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="防DDos"><a href="#防DDos" class="headerlink" title="防DDos"></a>防DDos</h2><p>如果你对每个收到的片段数据包都会回复一个确认数据包的话，那么发送方能够构造一个很小的片段数据包发送给你，而你会回复一个比发送给你的片段数据包还大的确认数据包，这样你的服务器就变成了一个可以被人利用来进行DDos放大攻击的工具。</p>
<p>永远不要设计一个包含对接收到的数据包进行一对一的映射响应的协议。让我们举个简单例子来说明一下这个问题。如果有人给你发送1000个片段数据包，永远不要给他回复1000个确认数据包。相反只发一个确认数据包，而且最多每50毫秒或者100毫秒才发送一个确认数据包。如果你是这样设计的话，那么DDos攻击完全不可能的。</p>
<h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><p><a href="https://gafferongames.com/post/sending_large_blocks_of_data/" target="_blank" rel="noopener">原文出处</a></p>
<p>原文标题 : <strong>Sending Large Blocks of Data</strong> (<em>How to send blocks quickly and reliably over UDP</em>)</p>
<hr>
<p></p><h2 id="introduction">Introduction</h2><p></p>
<p>Hi, I’m <a href="https://gafferongames.com/about" target="_blank" rel="noopener">Glenn Fiedler</a> and welcome to <strong><a href="https://gafferongames.com/categories/building-a-game-network-protocol/" target="_blank" rel="noopener">Building a Game Network Protocol</a></strong>.</p><br><p>In the <a href="https://gafferongames.com/post/packet_fragmentation_and_reassembly/" target="_blank" rel="noopener">previous article</a> we implemented packet fragmentation and reassembly so we can send packets larger than MTU.</p><br><p>This approach works great when the data block you&rsquo;re sending is time critical and can be dropped, but in other cases you need to send large blocks of quickly and reliably over packet loss, and you need the data to get through.</p><br><p>In this situation, a different technique gives much better results.</p><br><h2 id="background">Background</h2><br><p>It&rsquo;s common for servers to send large block of data to the client on connect, for example, the initial state of the game world for late join.</p><br><p>Let&rsquo;s assume this data is 256k in size and the client needs to receive it before they can join the game. The client is stuck behind a load screen waiting for the data, so obviously we want it to be transmitted as quickly as possible.</p><br><p>If we send the data with the technique from the previous article, we get <em>packet loss amplification</em> because a single dropped fragment results in the whole packet being lost. The effect of this is actually quite severe. Our example block split into 256 fragments and sent over 1% packet loss now has a whopping 92.4% chance of being dropped!</p><br><p>Since we just need the data to get across, we have no choice but to keep sending it until it gets through. On average, we have to send the block 10 times before it&rsquo;s received. You may laugh but this actually happened on a AAA game I worked on!</p><br><p>To fix this, I implemented a new system for sending large blocks, one that handles packet loss by resends fragments until they are acked. Then I took the problematic large blocks and piped them through this system, fixing a bunch of players stalling out on connect, while continuing to send time critical data (snapshots) via packet fragmentation and reassembly.</p><br><h2 id="chunks-and-slices">Chunks and Slices</h2><br><p>In this new system blocks of data are called <em>chunks</em>. Chunks are split up into <em>slices</em>. This name change keeps the chunk system terminology (chunks/slices) distinct from packet fragmentation and reassembly (packets/fragments).</p><br><p>The basic idea is that slices are sent over the network repeatedly until they all get through. Since we are implementing this over UDP, simple in concept becomes a little more complicated in implementation because have to build in our own basic reliability system so the sender knows which slices have been received.</p><br><p>This reliability gets quite tricky if we have a bunch of different chunks in flight, so we&rsquo;re going to make a simplifying assumption up front: we&rsquo;re only going to send one chunk over the network at a time. This doesn&rsquo;t mean the sender can&rsquo;t have a local send queue for chunks, just that in terms of network traffic there&rsquo;s only ever one chunk <em>in flight</em> at any time.</p><br><p>This makes intuitive sense because the whole point of the chunk system is to send chunks reliably and in-order. If you are for some reason sending chunk 0 and chunk 1 at the same time, what&rsquo;s the point? You can&rsquo;t process chunk 1 until chunk 0 comes through, because otherwise it wouldn&rsquo;t be reliable-ordered.</p><br><p>That said, if you dig a bit deeper you&rsquo;ll see that sending one chunk at a time does introduce a small trade-off, and that is that it adds a delay of RTT between chunk n being received and the send starting for chunk n+1 from the receiver&rsquo;s point of view.</p><br><p>This trade-off is totally acceptable for the occasional sending of large chunks like data sent once on client connect, but it&rsquo;s definitely <em>not</em> acceptable for data sent 10 or 20 times per-second like snapshots. So remember, this system is useful for large, infrequently sent blocks of data, not for time critical data.</p><br><h2 id="packet-structure">Packet Structure</h2><br><p>There are two sides to the chunk system, the <strong>sender</strong> and the <strong>receiver</strong>.</p><br><p>The sender is the side that queues up the chunk and sends slices over the network. The receiver is what reads those slice packets and reassembles the chunk on the other side. The receiver is also responsible for communicating back to the sender which slices have been received via acks.</p><br><p>The netcode I work on is usually client/server, and in this case I usually want to be able to send blocks of data from the server to the client <em>and</em> from the client to the server. In that case, there are two senders and two receivers, a sender on the client corresponding to a receiver on the server and vice-versa.</p><br><p>Think of the sender and receiver as end points for this chunk transmission protocol that define the direction of flow. If you want to send chunks in a different direction, or even extend the chunk sender to support peer-to-peer, just add sender and receiver end points for each direction you need to send chunks.</p><br><p>Traffic over the network for this system is sent via two packet types:</p><br><ul><br><li><strong>Slice packet</strong> - contains a slice of a chunk up to 1k in size.</li><br><li><strong>Ack packet</strong> - a bitfield indicating which slices have been received so far.</li><br></ul><br><p>The slice packet is sent from the sender to the receiver. It is the payload packet that gets the chunk data across the network and is designed so each packet fits neatly under a conservative MTU of 1200 bytes. Each slice is a maximum of 1k and there is a maximum of 256 slices per-chunk, therefore the largest data you can send over the network with this system is 256k.</p><br><pre><code>const int SliceSize = 1024;<br>const int MaxSlicesPerChunk = 256;<br>const int MaxChunkSize = SliceSize <em> MaxSlicesPerChunk;<br><br>struct SlicePacket : public protocol2::Packet<br>{<br>    uint16_t chunkId;<br>    int sliceId;<br>    int numSlices;<br>    int sliceBytes;<br>    uint8_t data[SliceSize];<br><br>    template &amp;lt;typename Stream&amp;gt; bool Serialize( Stream &amp;amp; stream )<br>    {<br>        serialize_bits( stream, chunkId, 16 );<br>        serialize_int( stream, sliceId, 0, MaxSlicesPerChunk - 1 );<br>        serialize_int( stream, numSlices, 1, MaxSlicesPerChunk );<br>        if ( sliceId == numSlices - 1 )<br>        {<br>            serialize_int( stream, sliceBytes, 1, SliceSize );<br>        }<br>        else if ( Stream::IsReading )<br>        {<br>            sliceBytes = SliceSize;<br>        }<br>        serialize_bytes( stream, data, sliceBytes );<br>        return true;<br>    }<br>};<br></em></code></pre><br><p>There are two points I&rsquo;d like to make about the slice packet. The first is that even though there is only ever one chunk in flight over the network, it&rsquo;s still necessary to include the chunk id (0,1,2,3, etc&hellip;) because packets sent over UDP can be received out of order.</p><br><p>Second point. Due to the way chunks are sliced up we know that all slices except the last one must be SliceSize (1024 bytes). We take advantage of this to save a small bit of bandwidth sending the slice size only in the last slice, but there is a trade-off: the receiver doesn&rsquo;t know the exact size of a chunk until it receives the last slice.</p><br><p>The other packet sent by this system is the ack packet. This packet is sent in the opposite direction, from the receiver back to the sender. This is the reliability part of the chunk network protocol. Its purpose is to lets the sender know which slices have been received.</p><br><pre><code>struct AckPacket : public protocol2::Packet<br>{<br>    uint16_t chunkId;<br>    int numSlices;<br>    bool acked[MaxSlicesPerChunk];<br><br>    bool Serialize( Stream &amp;amp; stream )<br>    {<br>        serialize_bits( stream, chunkId, 16 );<br>        serialize_int( stream, numSlices, 1, MaxSlicesPerChunk );<br>        for ( int i = 0; i &amp;lt; numSlices; ++i )<br>        {<br>            serialize_bool( stream, acked[i] ); return true; } };<br>        }<br>    }<br>};<br></code></pre><br><p>Acks are short for &lsquo;acknowledgments&rsquo;. So an ack for slice 100 means the receiver is <em>acknowledging</em> that it has received slice 100. This is critical information for the sender because not only does it let the sender determine when all slices have been received so it knows when to stop, it also allows the sender to use bandwidth more efficiently by only sending slices that haven&rsquo;t been acked.</p><br><p>Looking a bit deeper into the ack packet, at first glance it seems a bit <em>redundant</em>. Why are we sending acks for all slices in every packet? Well, ack packets are sent over UDP so there is no guarantee that all ack packets are going to get through. You certainly don&rsquo;t want a desync between the sender and the receiver regarding which slices are acked.</p><br><p>So we need some reliability for acks, but we don&rsquo;t want to implement an <em>ack system for acks</em> because that would be a huge pain in the ass. Since the worst case ack bitfield is just 256 bits or 32 bytes, we just send the entire state of all acked slices in each ack packet. When the ack packet is received, we consider a slice to be acked the instant an ack packet comes in with that slice marked as acked and locally that slice is not seen as acked yet.</p><br><p>This last step, biasing in the direction of non-acked to ack, like a fuse getting blown, means we can handle out of order delivery of ack packets.</p><br><h2 id="sender-implementation">Sender Implementation</h2><br><p>Let&rsquo;s get started with the implementation of the sender.</p><br><p>The strategy for the sender is:</p><br><ul><br><li>Keep sending slices until all slices are acked</li><br><li>Don&rsquo;t resend slices that have already been acked</li><br></ul><br><p>We use the following data structure for the sender:</p><br><pre><code>class ChunkSender<br>{<br>    bool sending;<br>    uint16_t chunkId;<br>    int chunkSize;<br>    int numSlices;<br>    int numAckedSlices;<br>    int currentSliceId;<br>    bool acked[MaxSlicesPerChunk];<br>    uint8_t chunkData[MaxChunkSize];<br>    double timeLastSent[MaxSlicesPerChunk];<br>};<br></code></pre><br><p>As mentioned before, only one chunk is sent at a time, so there is a &lsquo;sending&rsquo; state which is true if we are currently sending a chunk, false if we are in an idle state ready for the user to send a chunk. In this implementation, you can&rsquo;t send another chunk while the current chunk is still being sent over the network. If you don&rsquo;t like this, stick a queue in front of the sender.</p><br><p>Next, we have the id of the chunk we are currently sending, or, if we are not sending a chunk, the id of the next chunk to be sent, followed by the size of the chunk and the number of slices it has been split into. We also track, per-slice, whether that slice has been acked, which lets us count the number of slices that have been acked so far while ignoring redundant acks. A chunk is considered fully received from the sender&rsquo;s point of view when numAckedSlices == numSlices.</p><br><p>We also keep track of the current slice id for the algorithm that determines which slices to send, which works like this. At the start of a chunk send, start at slice id 0 and work from left to right and wrap back around to 0 again when you go past the last slice. Eventually, you stop iterating across because you&rsquo;ve run out of bandwidth to send slices. At this point, remember our current slice index via current slice id so you can pick up from where you left off next time. This last part is important because it distributes sends across all slices, not just the first few.</p><br><p>Now let&rsquo;s discuss bandwidth limiting. Obviously you don&rsquo;t just blast slices out continuously as you&rsquo;d flood the connection in no time, so how do we limit the sender bandwidth? My implementation works something like this: as you walk across slices and consider each slice you want to send, estimate roughly how many bytes the slice packet will take eg: roughly slice bytes + some overhead for your protocol and UDP/IP header. Then compare the amount of bytes required vs. the available bytes you have to send in your bandwidth budget. If you don&rsquo;t have enough bytes accumulated, stop. Otherwise, subtract the bytes required to send the slice and repeat the process for the next slice.</p><br><p>Where does the available bytes in the send budget come from? Each frame before you update the chunk sender, take your target bandwidth (eg. 256kbps), convert it to bytes per-second, and add it multiplied by delta time (dt) to an accumulator.</p><br><p>A conservative send rate of 256kbps means you can send 32000 bytes per-second, so add 32000  dt to the accumulator. A middle ground of 512kbit/sec is 64000 bytes per-second. A more aggressive 1mbit is 125000 bytes per-second. This way each update you <em>accumulate</em> a number of bytes you are allowed to send, and when you&rsquo;ve sent all the slices you can given that budget, any bytes left over stick around for the next time you try to send a slice.</p><br><p>One subtle point with the chunk sender and is that it&rsquo;s a good idea to implement some minimum resend delay per-slice, otherwise you get situations where for small chunks, or the last few slices of a chunk that the same few slices get spammed over the network.</p><br><p>For this reason we maintain an array of last send time per-slice. One option for this resend delay is to maintain an estimate of RTT and to only resend a slice if it hasn&rsquo;t been acked within RTT * 1.25 of its last send time. Or, you could just resend the slice it if it hasn&rsquo;t been sent in the last 100ms. Works for me!</p><br><h2 id="kicking-it-up-a-notch">Kicking it up a notch</h2><br><p>Do the math you&rsquo;ll notice it still takes a long time for a 256k chunk to get across:</p><br><ul><br><li>1mbps = 2 seconds</li><br><li>512kbps = 4 seconds</li><br><li>256kbps = <strong>8 seconds :(</strong></li><br></ul><br><p>Which kinda sucks. The whole point here is quickly and reliably. Emphasis on <em>quickly</em>. Wouldn&rsquo;t it be nice to be able to get the chunk across faster? The typical use case of the chunk system supports this. For example, a large block of data sent down to the client immediately on connect or a block of data that has to get through before the client exits a load screen and starts to play. You want this to be over as quickly as possible and in both cases the user really doesn&rsquo;t have anything better to do with their bandwidth, so why not use as much of it as possible?</p><br><p>One thing I&rsquo;ve tried in the past with excellent results is an initial burst. Assuming your chunk size isn&rsquo;t so large, and your chunk sends are infrequent, I can see no reason why you can&rsquo;t just fire across the entire chunk, all slices of it, in separate packets in one glorious burst of bandwidth, wait 100ms, and then resume the regular bandwidth limited slice sending strategy.</p><br><p>Why does this work? In the case where the user has a good internet connection (some multiple of 10mbps or greater&hellip;), the slices get through very quickly indeed. In the situation where the connection is not so great, the burst gets buffered up and <em>most</em> slices will be delivered as quickly as possible limited only by the amount bandwidth available. After this point switching to the regular strategy at a lower rate picks up any slices that didn&rsquo;t get through the first time.</p><br><p>This seems a bit risky so let me explain. In the case where the user can&rsquo;t quite support this bandwidth what you&rsquo;re relying on here is that routers on the Internet <em>strongly prefer</em> to buffer packets rather than discard them at almost any cost. It&rsquo;s a TCP thing. Normally, I hate this because it induces latency in packet delivery and messes up your game packets which you want delivered as quickly as possible, but in this case it&rsquo;s good behavior because the player really has nothing else to do but wait for your chunk to get through.</p><br><p>Just don&rsquo;t go too overboard with the spam or the congestion will persist after your chunk send completes and it will affect your game for the first few seconds. Also, make sure you increase the size of your OS socket buffers on both ends so they are larger than your maximum chunk size (I recommend at least double), otherwise you&rsquo;ll be dropping slices packets before they even hit the wire.</p><br><p>Finally, I want to be a responsible network citizen here so although I recommend sending all slices once in an initial burst, it&rsquo;s important for me to mention that I think this really is only appropriate, and only really <em>borderline appropriate</em> behavior for small chunks in the few 100s of k range in 2016, and only when your game isn&rsquo;t sending anything else that is time-critical.</p><br><p>Please don&rsquo;t use this burst strategy if your chunk is really large, eg: megabytes of data, because that&rsquo;s way too big to be relying on the kindness of strangers, AKA. the buffers in the routers between you and your packet&rsquo;s destination. For this it&rsquo;s necessary to implement something much smarter. Something adaptive that tries to send data as quickly as it can, but backs off when it detects too much latency and/or packet loss as a result of flooding the connection. Such a system is outside of the scope of this article.</p><br><h2 id="receiver-implementation">Receiver Implementation</h2><br><p>Now that we have the sender all sorted out let&rsquo;s move on to the reciever. </p><br><p>As mentioned previously, unlike the packet fragmentation and reassembly system from the previous article, the chunk system only ever has one chunk in flight.</p><br><p>This makes the reciever side of the chunk system much simpler:</p><br><pre><code>class ChunkReceiver<br>{<br>    bool receiving;<br>    bool readyToRead;<br>    uint16_t chunkId;<br>    int chunkSize;<br>    int numSlices;<br>    int numReceivedSlices;<br>    bool received[MaxSlicesPerChunk];<br>    uint8_t chunkData[MaxChunkSize];<br>};<br></code></pre><br><p>We have a state whether we are currently &lsquo;receiving&rsquo; a chunk over the network, plus a &rsquo;readyToRead&rsquo; state which indicates that a chunk has received all slices and is ready to be popped off by the user. This is effectively a minimal receive queue of length 1. If you don&rsquo;t like this, of course you are free to add a queue.</p><br><p>In this data structure we also keep track of chunk size (although it is not known with complete accuracy until the last slice arrives), num slices and num received slices, as well as a received flag per-slice. This per-slice received flag lets us discard packets containing slices we have already received, and count the number of slices received so far (since we may receive the slice multiple times, we only increase this count the first time we receive a particular slice). It&rsquo;s also used when generating ack packets. The chunk receive is completed from the receiver&rsquo;s point of view when numReceivedSlices == numSlices.</p><br><p>So what does it look like end-to-end receiving a chunk?</p><br><p>First, the receiver sets up set to start at chunk 0. When the a slice packet comes in over the network matching the chunk id 0, &lsquo;receiving&rsquo; flips from false to true, data for that first slice is inserted into &lsquo;chunkData&rsquo; at the correct position, numSlices is set to the value in that packet, numReceivedSlices is incremented from 0 -&gt; 1, and the received flag in the array entry corresponding to that slice is set to true.</p><br><p>As the remaining slice packets for the chunk come in, each of them are checked that they match the current chunk id and numSlices that are being received and are ignored if they don&rsquo;t match. Packets are also ignored if they contain a slice that has already been received. Otherwise, the slice data is copied into the correct place in the chunkData array, numReceivedSlices is incremented and received flag for that slice is set to true.</p><br><p>This process continues until all slices of the chunk are received, at which point the receiver sets receiving to &lsquo;false&rsquo; and &lsquo;readyToRead&rsquo; to true. While &lsquo;readyToRead&rsquo; is true, incoming slice packets are discarded. At this point, the chunk receive packet processing is performed, typically on the same frame. The caller checks &lsquo;do I have a chunk to read?&rsquo; and processes the chunk data. All chunk receive data is cleared back to defaults, except chunk id which is incremented from 0 -&gt; 1, and we are ready to receive the next chunk.</p><br><h2 id="conclusion">Conclusion</h2><br><p>The chunk system is simple in concept, but the implementation is certainly not. I encourage you to take a close look at the <a href="http://www.patreon.com/gafferongames" target="_blank" rel="noopener">source code</a> for this article for further details.</p>


<h1 id="译文">译文</h1>


<p><a href="http://gad.qq.com/program/translateview/7165598" target="_blank" rel="noopener">译文出处</a></p>
<div class="WordSection1"><p class="MsoNormal" align="left"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">翻译：张华栋<span> (wcby)     </span>审校：王磊<span>(</span>未来的未来<span>)</span></span> </span></p><p class="MsoNormal" align="left"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span><span style="font-family:微软雅黑;"><br></span></span></span></p><p class="MsoNormal" align="left"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">大家好，我是格伦·菲德勒。欢迎大家阅读系列教程《构建游戏网络协议》的第四篇文章。</span></span><span style="color: rgb(34, 34, 34); font-size: 12pt; font-family: 微软雅黑;">在之前的文章中，我们讨论了如何在游戏协议这一层实现对数据包的分包和重组。</span></p><p class="MsoNormal" align="left"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">现在在这篇文章里面，我们将继续通过探索在<span>UDP</span>协议上发送大块数据的替代方案来继续我们构建一个专业级别的游戏网络协议的征程。</span> </span></p><p class="MsoNormal" align="left"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">第一眼看上去，这种替代性的技术似乎非常类似于数据包的分包和重组，但是它的实现是完全不同的。这种实现上的差异的目的是为了解决数据包分包和重组的一个关键弱点<span>-</span>一个片段的丢失就会导致整个数据包都要被丢弃掉。这种行为是非常不好的，因为它会随着分包数量的增加而放大数据包丢失的概率。当你遇到大块数据包的时候，这种放大是如此的明显，加入<span>256 k</span>大小的分包丢失率是<span>1%</span>的话，那么原始数据包就有<span>92.4%</span>的概率被丢弃。平均来说，你需要发送原始数据包<span>10</span>次，它才能顺利的到达网络的另外一端！</span> </span></p><p class="MsoNormal" align="left"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">如果你需要在一个可能会有数据包丢失的网络上比如说互联网，快速和可靠地发送大量的数据，很明显，这样的方法是完全不可接受的。你可能需要这样做的一些常见的例子包括：客户端在首次加入的时候，服务器需要下发一个大的数据块给客户端<span>(</span>可能是世界的初始状态<span>)</span>、一开始用来做增量编码的基线或者是在一个多人在线网络游戏里面客户端在加载界面所等待的大块数据。</span> </span></p><p class="MsoNormal" align="left"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">在这些情况下非常重要的是不仅要优雅地处理数据包的丢失，还要尽可能的利用可用的带宽并尽可能快的发送大块数据。</span></span><span style="color: rgb(34, 34, 34); font-size: 12pt; font-family: 微软雅黑;">这正是我要在这篇文章里面告诉你该如何做的内容。</span></p><p class="MsoNormal" align="left"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-family:微软雅黑;"><h2 id="块和片段"><span style="color: rgb(34, 34, 34);"><span style="font-size:x-large;">块和片段</span></span></h2> </span></p><p class="MsoNormal" align="left"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">让我们开始使用基本术语。在这个新系统中，大块的数据被称为<span>”</span>块<span>“</span>，而它们被分成的分包被称为<span>”</span>片段<span>”</span>。 这个名字上的改变使的块系统的术语<span>(</span>块和片段<span>)</span>不同于数据包分包和重组的术语<span>(</span>数据包和分包<span>)</span>。这是我认为很重要的一个事情，因为这些系统是在解决不同的问题，没有理由你不能在相同的网络协议中同时这两个系统。事实上，我经常把这两个结合起来，在时间比较关键的增量数据包里面使用数据包的分包和重组，当客户端加入游戏的时候，使用块系统来下发整个游戏世界的初始状态下<span>(</span>非常大的数据包<span>)</span>。</span> </span></p><p class="MsoNormal" align="left"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">块系统的基本思想，真是一点都不复杂，是把块分成很多片段，然后通过网络多次发送片段，直到他们都顺利的到达网络的另外一端。当然，因为我们正在<span>UDP</span>协议上实现这个功能，同时还有可能数据包会丢失、数据包乱序到达以及数据包重复到达的情况，简单的概念在实现中也会变得非常复杂，因为我们必须在<span>UDP</span>协议上建立我们自己的具有基本可靠性的系统，这样发送方才能知道这个片段已经被网络的另外一端成功收到。</span> </span></p><p class="MsoNormal" align="left"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">如果我们有一组不同的块正在传输过程中<span>(</span>就像我们在数据包的分包和重组中所做的那样<span>)</span>，那么可靠性的问题就会变得非常棘手，所以我们要做一个简化的假设。我们一次只会通过网络发送一个块的数据。这并不意味着发送者不能在本地有一个块的发送队列，这只是意味着在实际的网络传输中只有一个块的数据会正在传递。</span> </span></p><p class="MsoNormal" align="left"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">这么做之所以有意义，是因为有了这一点假设以后就能保证块系统能够可靠有序的发送块。如果你因为某些原因在同一时间发送块<span>0</span>和块<span>1</span>，这会发生什么？你不能在块<span>0</span>到来之前处理块<span>1</span>，否则这个传输过程就不是有序可靠了。也就是说，如果你挖得深一些的话，你会发现一次只能发送一个块确实引入了一个小的权衡，它给正在接收的块Ｎ增加了一个网络往返延迟，以及从接收方的角度看块Ｎ＋１的发送开始时间也被延迟了一个网络往返延迟。</span> </span></p><p class="MsoNormal" align="left"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">这个代价是完全可以接受的，因为发送大块数据是一个非常偶然的事情（举些简单的例子来说，当客户端连接上来的时候会发送大块数据，当新的关卡需要进行加载的时候才会发送大块数据。。。），但是如果<span>1</span>秒钟内<span>10</span>次或者<span>20</span>次发送块数据的话这就是绝对不能被接受的了。所以我希望你能看到这个系统是专为什么目的设计的以及不是为什么目的设计的。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-family:微软雅黑;"><h2 id="数据包的结构"><span style="font-size: 18pt; color: rgb(34, 34, 34);">数据包的结构</span></h2> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">在块系统中有两方会参与，分别是发送方和接收方。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">发送方是负责将块压入队列并通过网络发送片段。接收方是负责在网络的另外一端读取这些片段并进行重组。接收方还负责通过发送<span>“</span>确认<span>”</span>数据包给发送方来与发送方交流表明这个片段已经收到。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">我工作过的网络模式通常是客户端与服务端之间的通信，在这种情况下，我通常希望能够从服务器往客户端发送大块数据，以及从客户端到服务器发送大块数据。所以在这种情况下，有两个发送方和两个接收方，一个发送方在客户端对应着在服务器那边有一个接收方，反过来也是如此。可以把发送方和接收方认为是块传输协议的终点，这样也就定义了网络流的方向。如果你想在不同的方向发送块，甚至是扩展块的发送方来支持点对点的发送，只需要在你需要发送块的每个方向添加一个发送方和一个接收方作为终点。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">这个系统在网络上发送的数据包类型一共有两种类型：</span> </span></p><p class="MsoListParagraph" align="left" style="margin-left: 21pt; text-indent: -21pt; line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">1）片段数据包<span>-</span>这包括了一个块的片段，最多大小为<span>1k</span>。</span> </span></p><p class="MsoListParagraph" align="left" style="margin-left: 21pt; text-indent: -21pt; line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">2）确认数据包<span>-</span>一个位域指示哪些片段已经收到。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">片段数据包是从发送方发送到接收器的。这是通过网络对块数据进行传递的有效载荷数据包，在设计的时候每个片段数据包的大小都贴近一个保守的最大传输单元的大小，也就是<span> 1200</span>字节。每个片段数据包最大是<span>1 k</span>，每个块最多有<span>256</span>个片段数据包，所以通过这个系统可以通过网络发送的最大的数据是<span>256k</span>（如果你愿意的话，你可以增加这个片段的最大数目）。我建议保持片段的大小为<span>1k</span>，这主要是基于最大传输单元方面的考虑。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="color: rgb(43, 43, 43); background: rgb(248, 248, 248);"> </span></span></p><div><div id="highlighter_653417" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div><div class="line number15 index14 alt2">15</div><div class="line number16 index15 alt1">16</div><div class="line number17 index16 alt2">17</div><div class="line number18 index17 alt1">18</div><div class="line number19 index18 alt2">19</div><div class="line number20 index19 alt1">20</div><div class="line number21 index20 alt2">21</div><div class="line number22 index21 alt1">22</div><div class="line number23 index22 alt2">23</div><div class="line number24 index23 alt1">24</div><div class="line number25 index24 alt2">25</div><div class="line number26 index25 alt1">26</div><div class="line number27 index26 alt2">27</div><div class="line number28 index27 alt1">28</div><div class="line number29 index28 alt2">29</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">const</code> <code class="cpp color1 bold">int</code> <code class="cpp plain">SliceSize = 1024;</code></div><div class="line number2 index1 alt1"><code class="cpp keyword bold">const</code> <code class="cpp color1 bold">int</code> <code class="cpp plain">MaxSlicesPerChunk = 256;</code></div><div class="line number3 index2 alt2"><code class="cpp keyword bold">const</code> <code class="cpp color1 bold">int</code> <code class="cpp plain">MaxChunkSize = SliceSize <em> MaxSlicesPerChunk;</em></code></div><div class="line number4 index3 alt1"> </div><div class="line number5 index4 alt2"><code class="cpp keyword bold">struct</code> <code class="cpp plain">SlicePacket : </code><code class="cpp keyword bold">public</code> <code class="cpp plain">protocol2::Packet</code></div><div class="line number6 index5 alt1"><code class="cpp plain">{</code></div><div class="line number7 index6 alt2"><code class="cpp spaces">    </code><code class="cpp plain">uint16_t chunkId;</code></div><div class="line number8 index7 alt1"><code class="cpp spaces">    </code><code class="cpp color1 bold">int</code> <code class="cpp plain">sliceId;</code></div><div class="line number9 index8 alt2"><code class="cpp spaces">    </code><code class="cpp color1 bold">int</code> <code class="cpp plain">numSlices;</code></div><div class="line number10 index9 alt1"><code class="cpp spaces">    </code><code class="cpp color1 bold">int</code> <code class="cpp plain">sliceBytes;</code></div><div class="line number11 index10 alt2"><code class="cpp spaces">    </code><code class="cpp plain">uint8_t data[SliceSize];</code></div><div class="line number12 index11 alt1"><code class="cpp spaces"> </code> </div><div class="line number13 index12 alt2"><code class="cpp spaces">    </code><code class="cpp keyword bold">template</code> <code class="cpp plain">&lt;</code><code class="cpp keyword bold">typename</code> <code class="cpp plain">stream</code><code class="cpp string"></code><code class="cpp plain">&gt; </code><code class="cpp color1 bold">bool</code> <code class="cpp plain">Serialize( Stream &amp; stream )</code></div><div class="line number14 index13 alt1"><code class="cpp spaces">    </code><code class="cpp plain">{</code></div><div class="line number15 index14 alt2"><code class="cpp spaces">        </code><code class="cpp plain">serialize_bits( stream, chunkId, 16 );</code></div><div class="line number16 index15 alt1"><code class="cpp spaces">        </code><code class="cpp plain">serialize_int( stream, sliceId, 0, MaxSlicesPerChunk - 1 );</code></div><div class="line number17 index16 alt2"><code class="cpp spaces">        </code><code class="cpp plain">serialize_int( stream, numSlices, 1, MaxSlicesPerChunk );</code></div><div class="line number18 index17 alt1"><code class="cpp spaces">        </code><code class="cpp keyword bold">if</code> <code class="cpp plain">( sliceId == numSlices - 1 )</code></div><div class="line number19 index18 alt2"><code class="cpp spaces">        </code><code class="cpp plain">{</code></div><div class="line number20 index19 alt1"><code class="cpp spaces">            </code><code class="cpp plain">serialize_int( stream, sliceBytes, 1, SliceSize );</code></div><div class="line number21 index20 alt2"><code class="cpp spaces">        </code><code class="cpp plain">}</code></div><div class="line number22 index21 alt1"><code class="cpp spaces">        </code><code class="cpp keyword bold">else</code> <code class="cpp keyword bold">if</code> <code class="cpp plain">( Stream::IsReading )</code></div><div class="line number23 index22 alt2"><code class="cpp spaces">        </code><code class="cpp plain">{</code></div><div class="line number24 index23 alt1"><code class="cpp spaces">            </code><code class="cpp plain">sliceBytes = SliceSize;</code></div><div class="line number25 index24 alt2"><code class="cpp spaces">        </code><code class="cpp plain">}</code></div><div class="line number26 index25 alt1"><code class="cpp spaces">        </code><code class="cpp plain">serialize_bytes( stream, data, sliceBytes );</code></div><div class="line number27 index26 alt2"><code class="cpp spaces">        </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">true</code><code class="cpp plain">;</code></div><div class="line number28 index27 alt1"><code class="cpp spaces">    </code><code class="cpp plain">}</code></div><div class="line number29 index28 alt2"><code class="cpp plain">};</code><code class="cpp keyword bold"></code><code class="cpp plain"></code></div></div></td></tr></table></div></div><br><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">在这里我想对片段数据包进行两点说明。第一点是即使只有一个块在网络上进行传输，仍然是有必要在数据包里面包含一个块的<span>id(</span>比如说，<span>0</span>、<span>1</span>、<span>2</span>、<span>3</span>、等等等<span>)</span>，这是<span>,</span>因为通过<span>UDP</span>协议发送的数据包可以是乱序到达的。通过这种方式的话，如果一个片段数据包到达的时候对应着一个已经接受过的块，举个简单的例子来说明，你正在接受块<span>2</span>的数据，但是块<span>1</span>的一个片段数据包现在到达了，你可以直接拒绝这个数据包，而不是接受它的数据包并把它的数据插入到块<span>2</span>从而把块<span>2</span>的数据给弄混了。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">第二点。由于我们知道块分成片段的方法会把所有的片段除了最后一个以外都弄成必须<span>SliceSize</span>的大小<span>(</span>也就是<span>1024</span>字节<span>)</span>。我们利用这一点来节省一点带宽，我们只在最后一个片段里面发送片段的大小，但这是一种权衡<span>:</span>接收方不知道块的确切大小到底是多少字节，直到它接收到最后一个片段才能知道。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">可以让这个系统继续往后发送新的数据包的机制是确认数据包。这个数据包是沿着另外一个方向进行发送的，也就是从接收方发回给发送方，这也是块网络协议中负责可靠性的部分。它存在的目的是让发送方知道这个片段已经被发送方收到。</span></span></p><div><div id="highlighter_476828" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">struct</code> <code class="cpp plain">AckPacket : </code><code class="cpp keyword bold">public</code> <code class="cpp plain">protocol2::Packet </code></div><div class="line number2 index1 alt1"><code class="cpp plain">{ </code></div><div class="line number3 index2 alt2"><code class="cpp spaces">    </code><code class="cpp plain">uint16_t chunkId; </code></div><div class="line number4 index3 alt1"><code class="cpp spaces">    </code><code class="cpp color1 bold">int</code> <code class="cpp plain">numSlices; </code></div><div class="line number5 index4 alt2"><code class="cpp spaces">    </code><code class="cpp color1 bold">bool</code> <code class="cpp plain">acked[MaxSlicesPerChunk]; </code></div><div class="line number6 index5 alt1"> </div><div class="line number7 index6 alt2"><code class="cpp spaces">    </code><code class="cpp color1 bold">bool</code> <code class="cpp plain">Serialize( Stream &amp; stream )</code></div><div class="line number8 index7 alt1"><code class="cpp spaces">    </code><code class="cpp plain">{ </code></div><div class="line number9 index8 alt2"><code class="cpp spaces">        </code><code class="cpp plain">serialize_bits( stream, chunkId, 16 ); </code></div><div class="line number10 index9 alt1"><code class="cpp spaces">        </code><code class="cpp plain">serialize_int( stream, numSlices, 1, MaxSlicesPerChunk ); </code></div><div class="line number11 index10 alt2"><code class="cpp spaces">        </code><code class="cpp keyword bold">for</code> <code class="cpp plain">( </code><code class="cpp color1 bold">int</code> <code class="cpp plain">i = 0; i &lt; numSlices; ++i ) </code></div><div class="line number12 index11 alt1"><code class="cpp spaces">            </code><code class="cpp plain">serialize_bool( stream, acked[i] ); </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">true</code><code class="cpp plain">; } };</code></div><div class="line number13 index12 alt2"><code class="cpp spaces">    </code><code class="cpp plain">}</code></div><div class="line number14 index13 alt1"><code class="cpp plain">};</code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><br></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">ack</span><span style="font-size: 12pt; color: rgb(34, 34, 34);">是<span>“</span>确认<span>”</span>的缩写。所以一个对片段<span>100</span>的确认数据包意味着接收方确认它已经接收到了片段<span>100</span>。这对于发送方来说是一条关键信息，因为它不仅让发送方知道什么时候所有的片段都已经被成功接收，这样发送方就可以停止发送了，它还允许发送方只重发那些还没有被确认的片段，这样就能让发送方更有效率的利用带宽。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">让我们对确认数据包再深入一点思考，似乎在一开始看上去对于每个数据包的所有分片都发送确认包似乎有点多余。我们为什么要这么做<span>?</span>是的，这是因为确认数据包是通过<span>UDP</span>协议发送的，所以没有办法保证所有的确认数据包都会成功的到达网络的另外一端，你当然不会希望发送方和接收方之间对于目前确认到那个片段的信息都是不同步的。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">所以我们需要一些确认数据包传输的可靠性，但是我们不希望实现一个确认数据包的确认系统，因为这将会是一个非常痛苦和麻烦的过程。因为在最坏的情况下，确认数据包的大小是<span>256</span>位或<span>32</span>字节，最简单的方法是也是最好的。we just send the entire state of all acked slices in each ack packet. When the ack packet is received, we consider a slice to be acked the instant an ack packet comes in with that slice marked as acked and locally that slice is not seen as acked yet.</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"></span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-family:微软雅黑;"><h2 id="基本的发送方实现"><span style="font-size: 18pt; color: rgb(34, 34, 34);">基本的发送方实现</span></h2> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">现在我们已经了解了这个系统背后的基本概念，让我们从发送方的实现开始实现整个系统。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">发送方的策略是：</span> </span></p><p class="MsoListParagraph" align="left" style="margin-left: 21pt; text-indent: -21pt; line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">1）持续的发送片段数据包，直到所有的片段数据包都被确认。</span> </span></p><p class="MsoListParagraph" align="left" style="margin-left: 21pt; text-indent: -21pt; line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="color: rgb(34, 34, 34);">2）</span><span style="font-size: 12pt; color: rgb(34, 34, 34);">不再对已经确认过的片段数据包进行发送。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">我们使用以下的数据结构来描述发送方：</span></span></p><div><div id="highlighter_252465" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">class</code> <code class="cpp plain">ChunkSender</code></div><div class="line number2 index1 alt1"><code class="cpp plain">{</code></div><div class="line number3 index2 alt2"><code class="cpp spaces">    </code><code class="cpp color1 bold">bool</code> <code class="cpp plain">sending;</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">    </code><code class="cpp plain">uint16_t chunkId;</code></div><div class="line number5 index4 alt2"><code class="cpp spaces">    </code><code class="cpp color1 bold">int</code> <code class="cpp plain">chunkSize;</code></div><div class="line number6 index5 alt1"><code class="cpp spaces">    </code><code class="cpp color1 bold">int</code> <code class="cpp plain">numSlices;</code></div><div class="line number7 index6 alt2"><code class="cpp spaces">    </code><code class="cpp color1 bold">int</code> <code class="cpp plain">numAckedSlices;</code></div><div class="line number8 index7 alt1"><code class="cpp spaces">    </code><code class="cpp color1 bold">int</code> <code class="cpp plain">currentSliceId;</code></div><div class="line number9 index8 alt2"><code class="cpp spaces">    </code><code class="cpp color1 bold">bool</code> <code class="cpp plain">acked[MaxSlicesPerChunk];</code></div><div class="line number10 index9 alt1"><code class="cpp spaces">    </code><code class="cpp plain">uint8_t chunkData[MaxChunkSize];</code></div><div class="line number11 index10 alt2"><code class="cpp spaces">    </code><code class="cpp color1 bold">double</code> <code class="cpp plain">timeLastSent[MaxSlicesPerChunk];</code></div><div class="line number12 index11 alt1"><code class="cpp plain">};</code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><br></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">正如之前提到的那样，一次只会发送一个块的数据，如果我们正在发送一个块的数据的时候，那么关于<span>“</span>发送<span>”</span>的状态是<span>true</span>，假如我们处于闲置状态、正在准备发送一个块的数据的时候，那么关于<span>“</span>发送<span>”</span>的状态是<span>false</span>。在这个实现中，如果当前有一个块的数据仍在通过网络进行发送的话，你不能发送另外一个块的数据。你必须等待当前块的数据发送完毕之后才可以发送另外一个块的数据。如果你不喜欢的话，在块的发送器的前端按照你的意愿可以放置一个发送队列。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">接下来，我们有我们正在发送的块数据的<span>id</span>，或者如果我们没有在发送块数据的话，那么我们有要发送的下一个块数据的<span>id</span>、以及这个块所分成的片段数据包的数量。我们也会跟踪每个片段数据包，来记录这个片段数据包是否已经被确认，这可以让我们避免重发那些已经收到的片段数据包，并且我们还会记录迄今为止已经确认收到的片段数据包的数量，这个数量会去掉冗余的确认，也就是每个片段数据包的确认只算一次。从发送方的观点来看，只有当确认的片段数据包的数量等于这个块所分成的片段数据包的数量的时候才会这个块数据已经被完全收到了。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">我们还需要为这个算法记录当前发送的片段数据包的<span>id</span>，因为这将决定了哪些片段数据包将被发送。它的工作机制大致是这样：一个块数据开始发送的时候，是从<span>id</span>为<span>0</span>的片段数据包开始发送的，然后依次从左到右开始发送直到经过最后一个片段数据包<span>(</span>也就是<span>id</span>为分包数量的大小<span>-1)</span>的时候会回头从<span>id</span>为<span>0</span>的片段数据包继续发送。最终，你会停止这个迭代因为发送的片段数据包已经耗尽了带宽。在这一点上，我们通过记录当前发送的片段数据包的<span>id</span>就能记住我们当前遍历的片段数据包的索引，这样在下一次开始遍历的时候你就可以继续从这个位置开始发送片段数据包。最后一部分是非常重要的，这是因为它可以把发送一个块数据所有的片段数据包这个事情是分散开，而不是在一起就全部发出去。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">现在让我们讨论下带宽限制。显然你不能把所有的片段数据包一次全部发完，因为如果这么做的话，会把整个链接堵住，那么，我们该如何限制发送方所使用的带宽<span>?</span>我的实现机制大概是这样的：当你对全部的片段数据包进行遍历并且考虑你想要发送的每个片段数据包的时候，大概估计下这个片段数据包会需要占据多少字节，比如可以用这种估计算法：大概这个片段的字节数<span>+</span>一些协议的开销和<span>UDP / IP</span>的报头。然后用所需的字节数和你带宽预算里面可用来进行发送的字节数进行比较。如果带宽预算里面没有足够可用的字节数，那么就停止发送。否则的话，从带宽预算里面减去发送这个片段数据包所需的字节数，然后对于下个片段数据包重复整个过程。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">带宽预算里面可用的字节发送预算是从哪里计算得来的？在每一帧更新块的发送方之前，把你的目标带宽（比如说每秒<span>256KB</span>）转换成每秒可以发送的字节数，然后用它乘以更新时间来把记过放到一个累加器里面。每秒<span>256KB</span>是一个比较保守的发送速率，这意味你可以每秒发送<span>32000</span>个字节，所以把<span>32000  dt</span>这个值添加到累加器里面。每秒<span>512KB</span>是一个比较适中的估计，意味你可以每秒发送<span>64000</span>个字节。每秒<span>1MB</span>是一个比较激进的估计，意味你可以每秒发送<span>125000</span>个字节。通过这种方法，在每次更新的时候你就可以累加你被允许发送的字节数了，这样当你可以按照预算来发送最大数量的片段数据包，如果还有数据没有发完的话，会等到下一帧的时候再尝试发送。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">对于发送方而言有一点比较微妙，实现一个片段数据包重新发送的最小延迟是一个很棒的主意，如果不这么做的话，就可能会出现这种一样情况，对于很小的块数据或者一个块的最后几个片段数据包，很容易不停的发送它们把整个网络都塞满。正是因为这一原因，我们使用了一个数组来记录每个片段数据包的上一次发送时间。重新发送延迟的一个选择是使用一个估计的网络往返时延，或者只有在超过上一次发送时间网络往返时延<span>*1.25</span>还没有收到确认数据包的情况才会重新发送。或者，你可以说<span>“</span>这根本就无所谓<span>”</span>，只要超过上一次发送时间<span>100</span>毫秒了就重新发送。我只是列举适合我自己的方案！</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="color: rgb(34, 34, 34);"> </span> </span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-family:微软雅黑;"><h2 id="把发送方实现的更完美一点"><span style="font-size: 18pt; color: rgb(34, 34, 34);">把发送方实现的更完美一点</span></h2> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">如果你仔细用数学计算一下的话，你会注意到对于一个<span>256K </span>的数据块而言，它要在网络上发送完毕仍然需要发送很长的时间：</span> </span></p><ul type="disc"><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-family:微软雅黑;"><span style="font-size: 12pt;">如果网络速率是每秒<span>1M</span>的话，就需要<span>2</span>秒钟的时间。</span> </span></li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-family:微软雅黑;"><span style="font-size: 12pt;">如果网络速率是每秒<span>512KB</span>的话，就需要<span>4</span>秒钟的时间。</span> </span></li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-family:微软雅黑;"><span style="font-size: 12pt;">如果网络速率是每秒<span>256KB</span>的话，就需要<span>8</span>秒钟的时间。</span> </span></li></ul><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">这可有点糟糕。我们实现系统的重点是快速和可靠性。再次强调下需要能够快速传递。如果块系统的传输不能做到快速的话，这是不是会不太好？块系统的一些典型用例会支持这一点。举个简单的例子来说明，当客户端第一次连接上服务器的时候，一大块数据需要立刻发送给客户端，或者在客户端退出加载界面开始游戏的时候需要能够大量数据快速下发给客户端。你想要尽快的传递完需要的数据，而且在这两种情况下，用户对于自己的带宽并没有什么太多其他的用途，那么为什么不使用尽可能多的带宽<span>?</span></span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span><br></span></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">在过去我曾经尝试过一个方法，就是在一开始的时候尽量传递，这取得了很好的效果。假设你的块大小并不是那么大，而且你的块发送频率并不那么频繁，我没找到什么理由为什么你不能在一开始就把所有的片段数据包都发送出去，填充满贷款，然后等待<span>100</span>毫秒，在恢复成正常的带宽受限的片段数据包发送策略。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">为什么这样会取得良好的效果？如果用户有一个良好的网络连接（可以每秒发送超过<span>10MB</span>的数据甚至更多。。。），事实上，片段数据包在网络上的传输非常的快速。如果是连接的情况并不是那么好的情况下，大部分的片段数据包会得到缓冲，大部分的片段数据包受限于带宽但是会尽可能快的发送出去。处理完这些数据包之后，就会切换到常规的策略，从那些第一次没有发送出去的片段数据包选择合适的进行发送。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">这似乎有点冒险，所以让我来解释一下。如果出现大量数据需要传输但是已经超过带宽限制的情况，互联网上的路由器会倾向于缓冲这些数据包，而不是不惜代价的抛弃它们。这就是<span>TCP</span>协议会做的事情。通常情况下，我讨厌这个机制因为它会诱发延迟而且会弄乱那些你想要尽快交付的游戏数据包，但在这种情况下它是一个非常好的行为，这是因为玩家真的没有其他事情可以做，智能等待你的块数据赶紧传输完毕。只是在你的块数据传输完毕以后，会有一些垃圾数据或者交通拥堵，它会影响你的游戏开始的几秒钟。另外，请确保你增加了网络两端的加操作系统的套接字缓冲区的大小，这样它们才可以比你最大的块数据的大小要大<span>(</span>我建议至少增加一倍<span>)</span>，否则在超过网络带宽的限制之前你就会出现丢弃段数据包的情况。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">最后，我想成为一个负责任的网络公民，虽然在这里我推荐在最开始连接的时候一次发送所有的片段数据包，所以对我来说介绍下我认为这真的是适当的是非常非常重要的，在<span>2016</span>年的网络环境下，发送几百个<span>KB</span>量级的数据包是没什么大不了的行为，而且只会发生在没有其他关键数据同时发送的情况下。让我们举个简单的例子来说明，如果用户正在玩你的游戏，那么当你发送大块数据的时候，使用保守的策略。如果不这么做的话，就会冒影响用户游戏体验的风险，这是因为你的发送行为可能会诱导额外的网络延迟或者出现数据包丢失的情况。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">同样，如果你的块数据非常大的情况下，比如说是十几<span>MB</span>的情况，那么请不要使用这种野蛮发送的策略，这是因为这种方法太过于依赖陌生人的仁慈，也就是在你和你的数据包目的地之间的路由器缓冲区。如果要持续发送非常大的数据块保持一个高吞吐量有必要实施一些更聪明的方法。这是某种自适应的方法，它会试图尽快发送数据，但是一旦检测到因为连接上有太多的数据在传输导致太多的延迟或者数据包的丢失，就能切换回一个低速的方式。这样一个系统超出了本文的范围。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-family:微软雅黑;"><h2 id="接收方的实现"><span style="font-size: 18pt; color: rgb(34, 34, 34);">接收方的实现</span></h2> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">现在我们已经解决了发送方实现的所有细节和小问题，那么让我们开始实现接收方。正如之前提到的那样，与之前文章介绍的数据包的分包和重组系统不同，块系统在同一时间只能由一个块正在传输。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">这使得块系统的接收方可以实现的更加简单，你可以看下面的实现<span>:</span></span> </span></p><div><div id="highlighter_415734" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">class</code> <code class="cpp plain">ChunkReceiver</code></div><div class="line number2 index1 alt1"><code class="cpp plain">{</code></div><div class="line number3 index2 alt2"><code class="cpp spaces">    </code><code class="cpp color1 bold">bool</code> <code class="cpp plain">receiving;</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">    </code><code class="cpp color1 bold">bool</code> <code class="cpp plain">readyToRead;</code></div><div class="line number5 index4 alt2"><code class="cpp spaces">    </code><code class="cpp plain">uint16_t chunkId;</code></div><div class="line number6 index5 alt1"><code class="cpp spaces">    </code><code class="cpp color1 bold">int</code> <code class="cpp plain">chunkSize;</code></div><div class="line number7 index6 alt2"><code class="cpp spaces">    </code><code class="cpp color1 bold">int</code> <code class="cpp plain">numSlices;</code></div><div class="line number8 index7 alt1"><code class="cpp spaces">    </code><code class="cpp color1 bold">int</code> <code class="cpp plain">numReceivedSlices;</code></div><div class="line number9 index8 alt2"><code class="cpp spaces">    </code><code class="cpp color1 bold">bool</code> <code class="cpp plain">received[MaxSlicesPerChunk];</code></div><div class="line number10 index9 alt1"><code class="cpp spaces">    </code><code class="cpp plain">uint8_t chunkData[MaxChunkSize];</code></div><div class="line number11 index10 alt2"><code class="cpp plain">};</code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><br></p><p class="MsoNormal" align="left" style="text-indent: 21pt; line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="color: rgb(34, 34, 34);"> </span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">我们有一个状态来记录我们是否正在网络上“接收”一个块数据，加上“<span>readyToRead’</span>”状态来表明是否已经有一个块的所有片段数据包都已经收到、已经准备好被用户弹出进行读取处理了。接收队列的最小长度是<span>1</span>，这是非常有效的。如果你不喜欢这个的话，你当然可以立即从块数据接收器里面将这个数据弹出并把它插入实际的接收队列。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">在这个数据结构中我们还记录了块数据的大小（尽管不是完全准确，直到收到最后一个片段数据包才能准确的计算块数据的大小）、片段数据包的数量、已经接收到的片段数据包的数量还有针对每个片段数据包的一个接收标记。针对每个片段数据包的接收标记可以让我们丢弃那些我们已经收到的片段数据包，并计算到目前为止我们已经收到的片段数据包的数量（因为我们可能会多次收到同一个片段数据包，但是我们只会在第一次收到这个片段数据包的才会增加计数器的值）。它也被用在生成确认数据包上。当已经接收到的片段数据包的数量等于片段数据包的数量的时候，从接收方的角度看这个块数据的接收才算完成。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-family:微软雅黑;"></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">首先，接收方的设置会从块<span>0</span>开始。当一个片段数据包从网络上传递过来，并且能够匹配这个块<span>id</span>的话，“<span>receiving”</span>状态会从<span>false</span>翻转为<span>true</span>，第一个片段数据包的数据会插入”<span> chunkData</span>“变量的合适位置，片段数据包的数量会根据第一个片段数据包里面的数据进行正确的设置，已经接收到的片段数据包的数量会加一，也就是从<span>0</span>到<span>1</span>，针对每个片段数据包的接收标记里面对应这个片段数据包的项会变为<span>true</span>。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">随着这个块数据的其他片段数据包的到来，会对每一个片段数据包进行检测，判断它们的<span>id</span>是否与当前块的<span>id</span>相同，如果不相同的话就会被丢弃。如果这个片段数据包已经收到过的话，那么这个包也会被丢弃。否则，这个片段数据包的数据会插入”<span> chunkData</span>“变量的合适位置、已经接收到的片段数据包的数量会加一、针对每个片段数据包的接收标记里面对应这个片段数据包的项会变为<span>true</span>。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">这一过程会持续进行，直到接收到所有的片段数据包。一旦接收到所有的片段数据包（也就是已经接收到的片段数据包的数量等于片段数据包的数量的时候），接收方会把“<span>receiving </span>“状态改为<span>false</span>，而把”<span>readyToRead</span>“状态改为<span>true</span>。当<span>”readyToRead”</span>状态为<span>true</span>的时候，所有收到的片段数据包都会被丢弃。在这一点上，这个处理过程通常非常的短，会在收到片段数据包的同一帧进行处理，调用者会检查<span>”</span>我有一块数据要读取么？<span>“</span>并处理块数据。然后会重置数据块接收器的所有数据为默认值，除了块数据的<span>id</span>从<span>0</span>增加到<span>1</span>，这样我们就准备好接收下一个块了。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-family:微软雅黑;"><h2 id="浸泡测试的重要性和确认数据包"><span style="font-size: 18pt; color: rgb(34, 34, 34);">浸泡测试的重要性和确认数据包</span></h2> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">第一眼看上去，确认数据包这个系统似乎很简单：</span> </span></p><p class="MsoListParagraph" align="left" style="margin-left: 21pt; text-indent: -21pt; line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">1）记录已经接收到的片段数据包。</span> </span></p><p class="MsoListParagraph" align="left" style="margin-left: 21pt; text-indent: -21pt; line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">2）当一个片段数据包收到以后，回复一个包含所有确认收到的片段数据包信息的确认数据包。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">这看上去实现起来似乎相当的简单，但是像大多数发生在<span>UDP</span>协议的事情一样，当涉及到数据包丢失的时候，就有一些微妙的点让它的处理有点棘手。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">一个对于确认数据包比较天真的实现可能是这样子的。每次收到片段数据包，就回复一个包含所有确认收到的片段数据包信息的确认数据包（也会包括刚收到的片段数据包的信息）。这看上去非常符合逻辑，但是这使得块协议给恶意发送者一个漏洞使得它们可以块协议作为一个DDos的工具。如何作为一个DDos的工具<span>?</span>如果你对每个收到的片段数据包都会回复一个确认数据包的话，那么发送方能够构造一个很小的片段数据包发送给你，而你会回复一个比发送给你的片段数据包还大的确认数据包，这样你的服务器就变成了一个可以被人利用来进行DDos放大攻击的工具。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">现在也许是因为我对DDos这个事情有一点偏执（我确实是有一点），但是一般来说你可以防止对DDos的放大，永远不要设计一个包含对接收到的数据包进行一对一的映射响应的协议。让我们举个简单例子来说明一下这个问题。如果有人给你发送<span>1000</span>个片段数据包，永远不要给他回复<span>1000</span>个确认数据包。相反只发一个确认数据包，而且最多每<span>50</span>毫秒或者<span>100</span>毫秒才发送一个确认数据包。如果你是这样设计的话，那么滥用你的<span>UDP</span>协议对DDos进行放大就是完全不可能的。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">还有其他的方法让这个确认系统容易出错，而这些都往往表现为<span>”</span>发送挂起<span>“</span>。换句话说，接收方已经知道这个块已经发送完毕了，但是由于程序员的错误，发送方错过了一个确认数据包<span>(</span>可能是针对最后一个片段数据包的确认数据包<span>)</span>并且卡入到一个状态，会不停的反复重发这个片段数据包而没有得到一个确认数据包的响应。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">在过去<span>10</span>年里，我可能至少<span>5</span>次从头开始实现这个块系统，每次我都找到新的和令人兴奋的方式来让发送方挂起。我开发和测试块系统的策略是首先进行编码确认它能够跑起来，然后设置一个测试工具在有大量的数据包丢失、数据包乱序和重复的情况下随机发送随机大小的块。这往往会清除任何挂起。我曾经实现过的块系统都至少有一个挂起存在，通常会有<span>2</span>到<span>3</span>个挂起。所以如果你是打算从头开始实现这个块系统的话，请不要轻敌。请设置一个浸泡测试。你会感谢我在这里的提醒的。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">我通常遇到的第一次挂起是由于对同一个片段数据包的多次收到不会回复一个确认数据包。它有点像这样：<span>” </span>哦，这个片段数据包已经收到过了么？已经收到过了就丢弃它<span>”</span>，然后忘记在确认数据包里面设置标记。这对于发送方来说是一个困扰，因为这样的话就不会有一个确认数据包，那么如果出现这种情况的话，又恰好遇到第一次收到这个片段数据包的时候发送的确认数据包出现丢包的情况，发送方根本就不知道这个他在反复发送的片段数据包其实已经被收到了。如果你就是这么不巧，遇上了第一次收到这个片段数据包的时候发送的确认数据包出现丢包的情况，那么就遇上了挂起的情况。如果你想在你的代码里面重现这个情况的话，可以在收到最后一个片段数据包的时候不发送确认数据包，那么出现的情况就是这种挂起了。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">下一个挂起会发生在接收方在发送方知道之前就已经知道块发送完毕并切换它的状态变量“<span>readyToRead”</span>来丢弃后续传入的片段数据包。在这种状态下，即使接收方认为块已经完全接收完毕，但是发送方还不知道这一点，所以有必要设置确认数据包对应的标志位，即使块已经完全接收完毕，这样发送方才能一直接收到提示块已经全部发送完毕的确认数据包。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">通常遇到的最后一个挂起情况是在读取完块数据以后的状态切换里面，那个时候状态变量“<span>readyToRead”</span>已经切回<span>false</span>而块的<span>id</span>也加一了。让我们举个简单例子来说明一下这个问题，块<span>0</span>已经完成接收，用户已经完成对块<span>0</span>的读取并且块<span>id</span>已经递增到<span>1</span>了，所以我们已经准备好接收块<span>1</span>的片段数据包了（我们会丢弃任何与我们当前正在接收块<span>ID</span>不同的片段数据包）。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">再一次出现这种情况，就是这里的发送方因为确认数据包的丢失导致信息有一点滞后，可能是因为没有收到第一个确认数据包。在这种情况下，有必要关注片段数据包，如果我们正处于这么一个状态：我们尚未收到第<span>n</span>个片段数据包，但是前面<span>n – 1</span>个片段数据包都已经收到了，我们必须设置一个特殊的标记位然后我们会发送一个包含所有前面<span>n – 1</span>个片段数据包都已经收到信息的确认数据包，否则发送方不会意识到块数据已经收到并且发送方已经准备挂起了。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">正如你所看到的那样，确认数据包的实现是有一点微妙的，这是一个有点奇怪的过程因为当片段数据包在网络的一端收到的时候，需要设置一个标记位来发送确认数据包直到发送方知道都有哪些发送的片段数据包被成功接收为止。如果你打破了片段数据包<span>-&gt;</span>确认数据包这个链接的话，那么整个系统就将挂起。我鼓励你仔细看看这篇文章的源代码搞清楚进一步的细节。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-family:微软雅黑;"><h2 id="总结"><span style="font-size: 18pt; color: rgb(34, 34, 34);">总结</span></h2> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">块系统在概念上是很简单的，但是它的具体实现肯定不是微不足道的。在我看来，实现发送者设计这一块是一个很好的学习经验，当你从头开始实现这样的系统的时候一定有很多东西需要学习。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">我希望你喜欢这个系统的设计，并试着自己动手从头开始实现它。这是一个很好的学习经历。此外，我鼓励你在<span>patreon</span>上支持我，作为回报，你会得到本文的示例源代码<span>(</span>以及本系列的其他文章的示例源代码<span>)</span>，还包括我在<span>GDC 2015</span>上关于网络物理的演讲的源代码。</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">如果你觉得这篇文章有价值的话，请在<span>patreon</span>上支持我的写作，这样我会写的更快。你可以在<span>BSD 3.0</span>许可下访问到这篇文章里面的代码。非常感谢你的支持！</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">【版权声明】</span> </span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">原文作者未做权利声明，视为共享知识产权进入公共领域，自动获得授权。</span> </span></p><p class="MsoNormal"><span style="font-family:微软雅黑;"><span> </span> </span></p><p class="MsoNormal"><span><span style="font-family:微软雅黑;"> </span></span> </p></div>                    <br>                

          
        
      


      

    
      <footer class="post-footer">
        

        

        

        
        
          <div class="post-eof"></div>
        
      </footer>
      
    </div>
    
    
    

    

    

    

  </div>
  
  
  
  </article>


      
    
      
        

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hulinhong.com/2017/02/26/packet_fragmentation_and_reassembly/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="no5ix">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="烫">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/26/packet_fragmentation_and_reassembly/" itemprop="url">构建游戏网络协议三之数据包的分包和重组</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-26T03:13:35+00:00">
                2017-02-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/GS/" itemprop="url" rel="index">
                    <span itemprop="name">GS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    




    
    
    
    <div class="post-body" itemprop="articleBody">
      
      

      

      
      
        <div class="post-eof"></div>
      

      
      

      
        
          
            <h1 id="本篇自我总结"><a href="#本篇自我总结" class="headerlink" title="本篇自我总结"></a>本篇自我总结</h1><p>本篇主要讲了数据包的分包和重组问题, 到底数据包多大才好呢?是不是越大越好呢?包太大了怎么办呢?<br>请看总结, 不明之处再看文中具体讲解.</p>
<h2 id="为什么需要做这个分包和重组系统"><a href="#为什么需要做这个分包和重组系统" class="headerlink" title="为什么需要做这个分包和重组系统"></a>为什么需要做这个分包和重组系统</h2><p>每台计算机(路由器)会沿着路由强制要求数据包的大小会有一个最大的上限，这个上限就是所谓的最大传输单元MTU。如果任意一个路由器收到一个数据包的大小超过这个最大传输单元的大小，它有这么两个选择，a)在IP层对这个数据包进行分包，并将分包后的数据包继续传递，b)丢弃这个数据包然后告诉你数据包被丢弃了，你自己负责摆平这个问题。</p>
<p><strong>实例</strong> : 这儿有一个我会经常遇到的情况。人们在编写多人在线游戏的时候，数据包的平均大小都会非常的小，让我们假设下，这些数据包的平均大小大概只有几百字节，但时不时会在他们的游戏中同时发生大量的事情并且发出去的数据包会出现丢失的情况，这个时候数据包会比通常的情况下要大。突然之间，游戏的数据包的大小就会超过最大传输单元的大小，这样就只有很少一部分玩家能够收到这个数据包，然后整个通信就崩溃了。</p>
<h2 id="本篇基本术语"><a href="#本篇基本术语" class="headerlink" title="本篇基本术语"></a>本篇基本术语</h2><ul>
<li>数据包packets</li>
<li>分包fragments</li>
</ul>
<h2 id="分包的数据结构"><a href="#分包的数据结构" class="headerlink" title="分包的数据结构"></a>分包的数据结构</h2><p>我们将允许一个数据包最多可以分成256个数据包，并且每个分包后的数据包的大小不会超过1024个字节。这样的话，我们就可以通过这样一个系统来发送大小最大为256k的数据包</p>
<pre><del>[protocol id] (32 bits)</del>   // not actually sent, but used to calc crc32
[crc32] (32 bits)  
[sequence] (16 bits)  // 数据包序号
[packet type = 0] (2 bits)
<strong>[fragment id] (8 bits) // 分包ID
[num fragments] (8 bits)
[pad zero bits to nearest byte index] // 用于字节对齐的bits
&lt;fragment data&gt;</strong>
</pre>

<h2 id="发送分包后的数据包"><a href="#发送分包后的数据包" class="headerlink" title="发送分包后的数据包"></a>发送分包后的数据包</h2><p>发送分包以后的数据包是一件非常容易的事情。如果数据包的大小小于保守估计的最大传输单元的大小。那么就按正常的方法进行发送。否则的话，就计算这个数据包到底该分成多少个1024字节的数据包分包，然后构建这些分包并按照之前发送正常数据包的方法进行发送。</p>
<p>发送出去以后也不记录发送的数据包的内容，这种发送以后不记录发送的数据包的内容的方法有一个后果，就是数据包的任意一个分包如果丢失的话，那么整个数据包就都要丢弃。随着分包数量的增加，整个数据包被丢弃的概率也随之增加.由此可见，当你需要发送要给256K的数据包的时候要发送256个分包，如果有一个分包丢失的话，你就要重新把这个256k的数据包再分一次包然后再发送出去。</p>
<h2 id="什么时候用这个分包和重组系统呢"><a href="#什么时候用这个分包和重组系统呢" class="headerlink" title="什么时候用这个分包和重组系统呢"></a>什么时候用这个分包和重组系统呢</h2><p>因为发送出去以后也不记录发送的数据包, 随着分包数量的增加，整个数据包被丢弃的概率也随之增加, 而一个片段的丢失就会导致整个数据包都要被丢弃掉.所以我建议你要小心分包以后的数量。</p>
<p><strong>这个分包和重组系统最好是只对2-4个分包的情况进行使用，而且最好是针对那种对时间不怎么敏感的数据使用或者是就算分包lost了也无所谓的情况。</strong>绝对不要只是为了省事就把一大堆依赖顺序的事件打到一个大数据包里面然后依赖数据包的分包和重组机制进行发送。这会让事情变得更加麻烦。</p>
<p>数据包分包和重组系统的关键弱点是一个片段的丢失就会导致整个数据包都要被丢弃掉, 想要解决这个弱点得使用大块数据发送策略, 见下一篇文章 <a href="/2017/02/28/sending_large_blocks_of_data/" title="构建游戏网络协议四之发送大块数据">构建游戏网络协议四之发送大块数据</a>.</p>
<h2 id="接收分包后的数据包"><a href="#接收分包后的数据包" class="headerlink" title="接收分包后的数据包"></a>接收分包后的数据包</h2><p>之所以对分包后的数据包进行接收很困难的原因是我们不仅需要给缓冲区建立一个数据结构还要把这些分包重组成原始的数据包，我们也要特别小心如果有人试图让我们的程序产生崩溃而给我们发送恶意的数据包。</p>
<p>要非常小心检查一切可能的情况。除此之外，还有一个非常简单的事情要注意：让分包保存在一个数据结构里面，当一个数据包的所有分包都到达以后（通过计数来判断是否全部到达），将这些分包重组成一个大的数据包，并把这个重组后的大数据包返回给接收方。</p>
<p>什么样的数据结构在这里是有意义的?这里并没有什么特别的数据结构!我使用的是一种我喜欢称之为序列缓冲区的东西。我想和你分享的最核心的技巧是如何让这个数据结构变得高效：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const int MaxEntries = 256;</span><br><span class="line"> </span><br><span class="line">struct SequenceBuffer</span><br><span class="line">&#123;</span><br><span class="line">    bool exists[MaxEntries];</span><br><span class="line">    uint16_t sequence[MaxEntries];</span><br><span class="line">    Entry entries[MaxEntries];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><p><a href="https://gafferongames.com/post/packet_fragmentation_and_reassembly/" target="_blank" rel="noopener">原文出处</a></p>
<p>原文标题 : <strong>Packet Fragmentation and Reassembly</strong> (<em>How to send and receive packets larger than MTU</em>)</p>
<hr>
<p></p><h2 id="introduction">Introduction</h2><p></p>
<p>Hi, I’m <a href="https://gafferongames.com/about" target="_blank" rel="noopener">Glenn Fiedler</a> and welcome to <strong><a href="https://gafferongames.com/categories/building-a-game-network-protocol/" target="_blank" rel="noopener">Building a Game Network Protocol</a></strong>.</p><br><p>In the <a href="https://gafferongames.com/post/serialization_strategies/" target="_blank" rel="noopener">previous article</a> we discussed how to unify packet read and write into a single serialize function and added a bunch of safety features to packet read.</p><br><p>Now we are ready to start putting interesting things in our packets and sending them over the network, but immediately we run into an interesting question: <em>how big should our packets be?</em></p><br><p>To answer this question properly we need a bit of background about how packets are actually sent over the Internet.</p><br><h2 id="background">Background</h2><br><p>Perhaps the most important thing to understand about the internet is that there&rsquo;s no direct connection between the source and destination IP address. What actually happens is that packets hop from one computer to another to reach their destination.</p><br><p>Each computer along this route enforces a maximum packet size called the maximum transmission unit, or MTU. According to the IP standard, if any computer recieves a packet larger than its MTU, it has the option of a) fragmenting that packet, or b) dropping the packet.</p><br><p>So here&rsquo;s how this usually goes down. People write a multiplayer game where the average packet size is quite small, lets say a few hundred bytes, but every now and then when a lot of stuff is happening in their game and a burst of packet loss occurs, packets get a lot larger than usual, going above MTU for the route, and suddenly all packets start getting dropped!</p><br><p>Just last year (2015) I was talking with Alex Austin at Indiecade about networking in his game <a href="http://subrosagame.com" target="_blank" rel="noopener">Sub Rosa</a>. He had this strange networking bug he couldn&rsquo;t reproduce. For some reason, players would randomly get disconnected from the game, but only when a bunch of stuff was going on. It was extremely rare and he was unable to reproduce it. Alex told me looking at the logs it seemed like <em>packets just stopped getting through</em>.</p><br><p>This sounded <em>exactly</em> like an MTU issue to me, and sure enough, when Alex limited his maximum packet size to a reasonable value the bug went away.</p><br><h2 id="mtu-in-the-real-world">MTU in the real world</h2><br><p>So what&rsquo;s a reasonable maximum packet size?</p><br><p>On the Internet today (2016, IPv4) the real-world MTU is 1500 bytes.</p><br><p>Give or take a few bytes for UDP/IP packet header and you&rsquo;ll find that the typical number before packets start to get dropped or fragmented is somewhere around 1472.</p><br><p>You can try this out for yourself by running this command on MacOS X:</p><br><pre>ping -g 56 -G 1500 -h 10 -D 8.8.4.4</pre><br><p>On my machine it conks out around just below 1500 bytes as expected:</p><br><pre>1404 bytes from 8.8.4.4: icmp_seq=134 ttl=56 time=11.945 ms<br>1414 bytes from 8.8.4.4: icmp_seq=135 ttl=56 time=11.964 ms<br>1424 bytes from 8.8.4.4: icmp_seq=136 ttl=56 time=13.492 ms<br>1434 bytes from 8.8.4.4: icmp_seq=137 ttl=56 time=13.652 ms<br>1444 bytes from 8.8.4.4: icmp_seq=138 ttl=56 time=133.241 ms<br>1454 bytes from 8.8.4.4: icmp_seq=139 ttl=56 time=17.463 ms<br>1464 bytes from 8.8.4.4: icmp_seq=140 ttl=56 time=12.307 ms<br>1474 bytes from 8.8.4.4: icmp_seq=141 ttl=56 time=11.987 ms<br>ping: sendto: Message too long<br>ping: sendto: Message too long<br>Request timeout for icmp_seq 142</pre><br><p>Why 1500? That&rsquo;s the default MTU for MacOS X. It&rsquo;s also the default MTU on Windows. So now we have an upper bound for your packet size assuming you actually care about packets getting through to Windows and Mac boxes without IP level fragmentation or a chance of being dropped: <strong>1472 bytes</strong>.</p><br><p>So what&rsquo;s the lower bound? Unfortunately for the routers in between your computer and the destination the IPv4 standard says <strong>576</strong>. Does this mean we have to limit our packets to 400 bytes or less? In practice, not really.</p><br><p>MacOS X lets me set MTU values in range 1280 to 1500 so considering packet header overhead, my first guess for a conservative lower bound on the IPv4 Internet today would be <strong>1200 bytes</strong>. Moving forward, in IPv6 this is also a good value, as any packet of 1280 bytes or less is guaranteed to get passed on without IP level fragmentation.</p><br><p>This lines up with numbers that I&rsquo;ve seen throughout my career. In my experience games rarely try anything complicated like attempting to discover path MTU, they just assume a reasonably conservative MTU and roll with that, something like 1000 to 1200 bytes of payload data. If a packet larger than this needs to be sent, it&rsquo;s split up into fragments by the game protocol and re-assembled on the other side.</p><br><p>And that&rsquo;s <em>exactly</em> what I&rsquo;m going to show you how to do in this article.</p><br><h2 id="fragment-packet-structure">Fragment Packet Structure</h2><br><p>Let&rsquo;s get started with implementation.</p><br><p>The first thing we need to decide is how we&rsquo;re going to represent fragment packets over the network so they are distinct from non-fragmented packets.</p><br><p>Ideally, we would like fragmented and non-fragmented packets to be compatible with the existing packet structure we&rsquo;ve already built, with as little overhead as possible in the common case when we are sending packets smaller than MTU.</p><br><p>Here&rsquo;s the packet structure from the previous article:</p><br><pre><del>[protocol id] (64 bits)</del> // not actually sent, but used to calc crc32<br>[crc32] (32 bits)<br>[packet type] (2 bits for 3 distinct packet types)<br>(variable length packet data according to packet type)<br>[end of packet serialize check] (32 bits)<br></pre><br><p>In our protocol we have three packet types: A, B and C.</p><br><p>Let&rsquo;s make one of these packet types generate really large packets:</p><br><pre>static const int MaxItems = 4096 * 4;<br><br>struct TestPacketB : public Packet<br>{<br>    int numItems;<br>    int items[MaxItems];<br><br>    TestPacketB() : Packet( TEST_PACKET_B )<br>    {<br>        numItems = random_int( 0, MaxItems );<br>        for ( int i = 0; i &lt; numItems; ++i )<br>            items[i] = random_int( -100, +100 );<br>    }<br><br>    template &lt;typename Stream&gt; bool Serialize( Stream &amp; stream )<br>    {<br>        serialize_int( stream, numItems, 0, MaxItems );<br>        for ( int i = 0; i &lt; numItems; ++i )<br>        {<br>            serialize_int( stream, items[i], -100, +100 );<br>        }<br>        return true;<br>    }<br>};<br></pre><br><p>This may seem somewhat contrived but these situations really do occur. For example, if you have a strategy where you send all un-acked events from server to client and you hit a burst of packet loss, you can easily end up with packets larger than MTU, even though your average packet size is quite small.</p><br><p>Another common case is delta encoded snapshots in a first person shooter. Here packet size is proportional to the amount of state changed between the baseline and current snapshots for each client. If there are a lot of differences between the snapshots the delta packet is large and there&rsquo;s nothing you can do about it except break it up into fragments and re-assemble them on the other side.</p><br><p>Getting back to packet structure. It&rsquo;s fairly common to add a sequence number at the header of each packet. This is just a packet number that increases with each packet sent. I like to use 16 bits for sequence numbers even though they wrap around in about 15 minutes @ 60 packets-per-second, because it&rsquo;s extremely unlikely that a packet will be delivered 15 minutes late.</p><br><p>Sequence numbers are useful for a bunch of things like acks, reliability and detecting and discarding out of order packets. In our case, we&rsquo;re going to use the sequence number to identify which packet a fragment belongs to:</p><br><pre><del>[protocol id] (64 bits)</del>   // not actually sent, but used to calc crc32<br>[crc32] (32 bits)<br><strong>[sequence] (16 bits)</strong><br>[packet type] (2 bits)<br>(variable length packet data according to packet type)<br>[end of packet serialize check] (32 bits)<br></pre><br><p>Here&rsquo;s the interesting part. Sure we could just add a bit <strong>is_fragment</strong> to the header, but then in the common case of non-fragmented packets you&rsquo;re wasting one bit that is always set to zero.</p><br><p>What I do instead is add a special fragment packet type:</p><br><pre>enum TestPacketTypes<br>{<br>    PACKET_FRAGMENT = 0,     // RESERVED<br>    TEST_PACKET_A,<br>    TEST_PACKET_B,<br>    TEST_PACKET_C,<br>    TEST_PACKET_NUM_TYPES<br>};<br></pre><br><p>And it just happens to be <em>free</em> because four packet types fit into 2 bits. Now when a packet is read, if the packet type is zero we know it&rsquo;s a fragment packet, otherwise we run through the ordinary, non-fragmented read packet codepath.</p><br><p>Lets design what this fragment packet looks like. We&rsquo;ll allow a maximum of 256 fragments per-packet and have a fragment size of 1024 bytes. This gives a maximum packet size of 256k that we can send through this system, which should be enough for anybody, but please don&rsquo;t quote me on this.</p><br><p>With a small fixed size header, UDP header and IP header a fragment packet be well under the conservative MTU value of 1200. Plus, with 256 max fragments per-packet we can represent a fragment id in the range [0,255] and the total number of fragments per-packet [1,256] with 8 bits.</p><br><pre><del>[protocol id] (32 bits)</del>   // not actually sent, but used to calc crc32<br>[crc32] (32 bits)<br>[sequence] (16 bits)<br>[packet type = 0] (2 bits)<br><strong>[fragment id] (8 bits)<br>[num fragments] (8 bits)<br>[pad zero bits to nearest byte index]<br>&lt;fragment data&gt;</strong><br></pre><br><p>Notice that we pad bits up to the next byte before writing out the fragment data. Why do this? Two reasons: 1) it&rsquo;s faster to copy fragment data into the packet via memcpy than bitpacking each byte, and 2) we can now save a small amount of bandwidth by inferring the fragment size by subtracting the start of the fragment data from the total size of the packet.</p><br><h2 id="sending-packet-fragments">Sending Packet Fragments</h2><br><p>Sending packet fragments is <em>easy</em>. For any packet larger than conservative MTU, simply calculate how many 1024 byte fragments it needs to be split into, and send those fragment packets over the network. Fire and forget!</p><br><p>One consequence of this is that if <em>any</em> fragment of that packet is lost then the entire packet is lost. It follows that if you have packet loss then sending a 256k packet as 256 fragments is not a very good idea, because the probability of dropping a packet increases significantly as the number of fragments increases. Not quite linearly, but in an interesting way that you can read more about <a href="https://www.fourmilab.ch/rpkp/experiments/statistics.html" target="_blank" rel="noopener">here</a>.</p><br><p>In short, to calculate the probability of losing a packet, you must calculate the probability of all fragments being delivered successfully and subtract that from one, giving you the probability that at least one fragment was dropped.</p><br><pre>1 - probability_of_fragment_being_delivered ^ num_fragments<br></pre><br><p>For example, if we send a non-fragmented packet over the network with 1% packet loss, there is naturally a <sup>1</sup>&frasl;<sub>100</sub> chance the packet will be dropped.</p><br><p>As the number of fragments increase, packet loss is amplified:<br><ul><br><li>Two fragments: 1 - (<sup>99</sup>&frasl;<sub>100</sub>) ^ 2 = <strong>2%</strong></li><br><li>Ten fragments: 1 - (<sup>99</sup>&frasl;<sub>100</sub>) ^ 10 = <strong>9.5%</strong></li><br><li>100 fragments: 1 - (<sup>99</sup>&frasl;<sub>100</sub>) ^ 100 = <strong>63.4%</strong></li><br><li>256 fragments: 1 - (<sup>99</sup>&frasl;<sub>100</sub>) ^ 256 = <strong>92.4%</strong></li><br></ul></p><br><p>So I recommend you take it easy with the number of fragments. It&rsquo;s best to use this strategy only for packets in the 2-4 fragment range, and only for time critical data that doesn&rsquo;t matter too much if it gets dropped. It&rsquo;s <em>definitely not</em> a good idea to fire down a bunch of reliable-ordered events in a huge packet and rely on packet fragmentation and reassembly to save your ass.</p><br><p>Another typical use case for large packets is when a client initially joins a game. Here you usually want to send a large block of data down reliably to that client, for example, representing the initial state of the world for late join. Whatever you do, don&rsquo;t send that block of data down using the fragmentation and re-assembly technique in this article.</p><br><p>Instead, check out the technique in <a href="https://gafferongames.com/post/sending-large-blocks-of-data.html" target="_blank" rel="noopener">next article</a> which handles packet loss by resending fragments until they are all received.</p><br><h2 id="receiving-packet-fragments">Receiving Packet Fragments</h2><br><p>It&rsquo;s time to implement the code that receives and processed packet fragments. This is a bit tricky because we have to be particularly careful of somebody trying to attack us with malicious packets.</p><br><p>Here&rsquo;s a list of all the ways I can think of to attack the protocol:</p><br><ul><br><li><p>Try to send out of bound fragments ids trying to get you to crash memory. eg: send fragments [0,255] in a packet that has just two fragments.</p></li><br><li><p>Send packet n with some maximum fragment count of say 2, and then send more fragment packets belonging to the same packet n but with maximum fragments of 256 hoping that you didn&rsquo;t realize I widened the maximum number of fragments in the packet after the first one you received, and you trash memory.</p></li><br><li><p>Send really large fragment packets with fragment data larger than 1k hoping to get you to trash memory as you try to copy that fragment data into the data structure, or blow memory budget trying to allocate fragments</p></li><br><li><p>Continually send fragments of maximum size (<sup>256</sup>&frasl;<sub>256</sub> fragments) in hope that it I could make you allocate a bunch of memory and crash you out. Lets say you have a sliding window of 256 packets, 256 fragments per-packet max, and each fragment is 1k. That&rsquo;s 64 mb per-client.</p></li><br><li><p>Can I fragment the heap with a bunch of funny sized fragment packets sent over and over? Perhaps the server shares a common allocator across clients and I can make allocations fail for other clients in the game because the heap becomes fragmented.</p></li><br></ul><br><p>Aside from these concerns, implementation is reasonably straightforward: store received fragments somewhere and when all fragments arrive for a packet, reassemble them into the original packet and return that to the user.</p><br><h2 id="data-structure-on-receiver-side">Data Structure on Receiver Side</h2><br><p>The first thing we need is some way to store fragments before they are reassembled. My favorite data structure is something I call a <em>sequence buffer</em>:</p><br><pre>const int MaxEntries = 256;<br><br>struct SequenceBuffer<br>{<br>    uint32_t sequence[MaxEntries];<br>    Entry entries[MaxEntries];<br>};<br></pre><br><p>Indexing into the arrays is performed with modulo arithmetic, giving us a fast O(1) lookup of entries by sequence number:</p><br><pre>const int index = sequence % MaxEntries;<br></pre><br><p>A sentinel value of 0xFFFFFFFF is used to represent empty entries. This value cannot possibly occur with 16 bit sequence numbers, thus providing us with a fast test to see if an entry exists for a given sequence number, without an additional branch to test if that entry exists.</p><br><p>This data structure is used as follows. When the first fragment of a new packet comes in, the sequence number is mapped to an entry in the sequence buffer. If an entry doesn&rsquo;t exist, it&rsquo;s added and the fragment data is stored in there, along with information about the fragment, eg. how many fragments there are, how many fragments have been received so far, and so on.</p><br><p>Each time a new fragment arrives, it looks up the entry by the packet sequence number. When an entry already exists, the fragment data is stored and number of fragments received is incremented. Eventually, once the number of fragments received matches the number of fragments in the packet, the packet is reassembled and delivered to the user.</p><br><p>Since it&rsquo;s possible for old entries to stick around (potentially with allocated blocks), great care must be taken to clean up any stale entries when inserting new entries in the sequence buffer. These stale entries correspond to packets that didn&rsquo;t receive all fragments.</p><br><p>And that&rsquo;s basically it at a high level. For further details on this approach please refer to the example source code for this article. </p><br><p><a href="https://www.patreon.com/gafferongames" target="_blank" rel="noopener">Click here to get the example source code for this article series</a>.</p><br><h2 id="test-driven-development">Test Driven Development</h2><br><p>One thing I&rsquo;d like to close this article out on.</p><br><p>Writing a custom UDP network protocol is <em>hard</em>. It&rsquo;s so hard that even though I&rsquo;ve done this from scratch at least 10 times, each time I still manage to fuck it up in a new and exciting ways. You&rsquo;d think eventually I&rsquo;d learn, but this stuff is complicated. You can&rsquo;t just write low-level netcode and expect it to just work.</p><br><p>You have to test it!</p><br><p>My strategy when testing low-level netcode is as follows:</p><br><ul><br><li><p>Code defensively. Assert everywhere. These asserts will fire and they&rsquo;ll be important clues you need when something goes wrong.</p></li><br><li><p>Add functional tests and make sure stuff is working as you are writing it. Put your code through its paces at a basic level as you write it and make sure it&rsquo;s working as you build it up. Think hard about the essential cases that need to be property handled and add tests that cover them.</p></li><br><li><p>But just adding a bunch of functional tests is not enough. There are of course cases you didn&rsquo;t think of! Now you have to get really mean. I call this soak testing and I&rsquo;ve never, not even once, have coded a network protocol that hasn&rsquo;t subsequently had problems found in it by soak testing.</p></li><br><li><p>When soak testing just loop forever and just do a mix of random stuff that puts your system through its paces, eg. random length packets in this case with a huge amount of packet loss, out of order and duplicates through a packet simulator. Your soak test passes when it runs overnight and doesn&rsquo;t hang or assert.</p></li><br><li><p>If you find anything wrong with soak testing. You may need to go back and add detailed logs to the soak test to work out how you got to the failure case. Once you know what&rsquo;s going on, stop. Don&rsquo;t fix it immediately and just run the soak test again.</p></li><br><li><p>Instead, add a unit test that reproduces that problem you are trying to fix, verify your test reproduces the problem, and that it problem goes away with your fix. Only after this, go back to the soak test and make sure they run overnight. This way the unit tests document the correct behavior of your system and can quickly be run in future to make sure you don&rsquo;t break this thing moving forward when you make other changes.</p></li><br><li><p>Add a bunch of logs. High level errors, info asserts showing an overview of what is going on, but also low-level warnings and debug logs that show what went wrong after the fact. You&rsquo;re going to need these logs to diagnose issues that don&rsquo;t occur on your machine. Make sure the log level can be adjusted dynamically.</p></li><br><li><p>Implement network simulators and make sure code handles the worst possible network conditions imaginable. 99% packet loss, 10 seconds of latency and +/- several seconds of jitter. Again, you&rsquo;ll be surprised how much this uncovers. Testing is the time where you want to uncover and fix issues with bad network conditions, not the night before your open beta.</p></li><br><li><p>Implement fuzz tests where appropriate to make sure your protocol doesn&rsquo;t crash when processing random packets. Leave fuzz tests running overnight to feel confident that your code is reasonably secure against malicious packets and doesn&rsquo;t crash.</p></li><br><li><p>Surprisingly, I&rsquo;ve consistently found issues that only show up when I loop the set of unit tests over and over, perhaps these issues are caused by different random numbers in tests, especially with the network simulator being driven by random numbers. This is a great way to take a rare test that fails once every few days and make it fail every time. So before you congratulate yourself on your tests passing 100%, add a mode where your unit tests can be looped easily, to uncover such errors.</p></li><br><li><p>Test simultaneously on multiple platforms. I&rsquo;ve never written a low-level library that worked first time on MacOS, Windows and Linux. There are always interesting compiler specific issues and crashes. Test on multiple platforms as you develop, otherwise it&rsquo;s pretty painful fixing all these at the end.</p></li><br><li><p>This about how people can attack the protocol. Implement code to defend against these attacks. Add functional tests that mimic these attacks and make sure that your code handles them correctly.</p></li><br></ul><br><p>This is my process and it seems to work pretty well. If you are writing a low-level network protocol, the rest of your game depends on this code working correctly. You need to be absolutely sure it works before you build on it, otherwise it&rsquo;s basically a stack of cards.</p><br><p>In my experience, game neworking is hard enough without having suspicions that that your low-level network protocol has bugs that only show up under extreme network conditions. That&rsquo;s exactly where you need to be able to trust your code works correctly. <strong>So test it!</strong></p>



<h1 id="译文">译文</h1>


<p><a href="http://gad.qq.com/program/translateview/7164496" target="_blank" rel="noopener">译文出处</a></p>
<div class="WordSection1"><b><span style="font-family:微软雅黑;"><span style="color: rgb(34, 34, 34); font-size: 12pt;">译者：崔嘉艺</span><span style="color: rgb(34, 34, 34); font-size: 12pt;">(milan21) </span><span style="color: rgb(34, 34, 34); font-size: 12pt;">审校：崔国军（星际迷航）</span></span></b><div><span style="color: rgb(34, 34, 34); font-size: 12pt;"><span style="font-family:微软雅黑;"><br></span></span></div><p class="MsoNormal" align="left"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">大家好，我是格伦·菲德勒。欢迎大家阅读系列教程《构建游戏网络协议》的第三篇文章。</span><span style="color: rgb(34, 34, 34); font-size: 12pt;">在之前的文章中，我们讨论了如何将数据包的读取和写入用一个单独的序列化函数来实现。</span></span></p><p class="MsoNormal" align="left"><span style="color: rgb(34, 34, 34); font-size: 12pt;"><span style="font-family:微软雅黑;"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">现在我们要开始把一些有趣的事情放到这些数据包中，<span>,</span>但正如你即将开始编码的令人惊叹的多人在线动作、第一人称射击、大型多人在线角色扮演游戏、多人在线战术竞技游戏会发生的那样，当你以每秒<span>120</span>次的频率发送<span>8k</span>大小的数据包，游戏网络中会传来一个声音呼喊着你<span>:</span></span><span style="font-size: 12pt; color: rgb(34, 34, 34);">“</span><span style="font-size: 12pt; color: rgb(34, 34, 34);">不要发送超过<span>1200</span>字节大小的数据包<span>!”</span></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">但是都已经<span>2016</span>年了，你真的要注意最大传输单元这个东西么<span>?</span></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">不幸的是，答案是是的！</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><br></span></span></p><h2 id="最大传输单元MTU"><span style="font-family:微软雅黑;">最大传输单元MTU</span></h2><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">你可能已经听说过最大传输单元了。在网络程序员中流传着大量有关最大传输单元问题的故事。那么这到底是怎么回事呢？究竟什么是最大传输单元<span>?</span>为什么你要在乎最大传输单元这个事情？</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">当你通过互联网来发送数据包的时候到底背后发生了什么？这些数据包要从一台计算机<span>(</span>路由器<span>)</span>跳到另一个计算机<span>(</span>路由器<span>)</span>上，如此往复多次才能到达自己的目的地。这是一个分组交换网络具体如何运作的方式。在大部分时间里，它的工作方式不像是在源和目的地之间存在一条直接的连接。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">但意外的是：每台计算机<span>(</span>路由器<span>)</span>会沿着路由强制要求数据包的大小会有一个最大的上限，这个上限就是所谓的最大传输单元。如果任意一个路由器收到一个数据包的大小超过这个最大传输单元的大小，它有这么两个选择，<span>a)</span>在<span>IP</span>层对这个数据包进行分包，并将分包后的数据包继续传递，<span>b)</span>丢弃这个数据包然后告诉你数据包被丢弃了，你自己负责摆平这个问题。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">这儿有一个我会经常遇到的情况。人们在编写多人在线游戏的时候，数据包的平均大小都会非常的小，让我们假设下，这些数据包的平均大小大概只有几百字节，但时不时会在他们的游戏中同时发生大量的事情并且发出去的数据包会出现丢失的情况，这个时候数据包会比通常的情况下要大。突然之间，游戏的数据包的大小就会超过最大传输单元的大小，这样就只有很少一部分玩家能够收到这个数据包，然后整个通信就崩溃了。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span><br></span>就在去年<span>(2015</span>年<span>)</span>，我与亚历克斯<span>·</span>奥斯汀在<span>Indiecade</span>谈论他的游戏<span>” </span></span><span><a rel="noopener" href="http://subrosagame.com/" target="_blank"><span style="font-size: 12pt; color: rgb(34, 34, 34); text-decoration: none;">Sub Rosa</span></a></span><span style="font-size: 12pt; color: rgb(34, 34, 34);"> “</span><span style="font-size: 12pt; color: rgb(34, 34, 34);">中的网络部分。他遇到了一些奇怪的无法重现的网络<span>bug</span>。出于某种原因，一些客户端（在所有玩家里面总是有那么一个或者两个）会随机的从游戏中断开连接并且其他人都能够正常游戏。查看日志的话，亚历克斯又觉得一切都是正常的，只是看上去好像数据包突然停止进行传递了。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><span><br></span>对我来说，这听上去就像是一个最大传输单元所引起的问题，并且我非常确信。当亚历克斯把他最大的数据包大小限制在一个合理的值之内，这个<span>bug</span>就再也没有出现了。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><br></span></span></p><h2 id="真实世界中的最大传输单元MTU"><span style="font-family:微软雅黑;">真实世界中的最大传输单元MTU</span></h2><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">所以什么是“一个合理的数据包的大小”？</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">在今天的互联网上<span>(2016</span>年，还是基于<span>IPv4)</span>，典型的最大传输单元的大小是<span>1500</span>字节。在<span>UDP/IP</span>数据包的包头添加或者去掉几个字节，你会发现在数据包开始出现被丢弃或者被分包情况的一个典型的边界值是<span>1472</span>。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">你可以自己在<span>MacOS X</span>尝试运行下下面这个命令：</span></span></p><div style="border:solid #F0F0F0 1.0pt;border-left:solid #E0E0E0 2.25pt;padding:0cm 0cm 0cm 0cm;background:whitesmoke"><p class="MsoNormal" align="left" style="line-height: 16.8pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; vertical-align: baseline; border: none; padding: 0cm;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">ping-g 56 -G 1500 -h 10 -D 8.8.4.4</span></span></p></div><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"> </span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">在我的机器上，这个结果在略微低于<span>1500</span>字节的大小上下浮动，符合预期：</span></span></p><div style="border:solid #F0F0F0 1.0pt;border-left:solid #E0E0E0 2.25pt;padding:0cm 0cm 0cm 0cm;background:whitesmoke"><p class="MsoNormal" align="left" style="line-height: 16.8pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; vertical-align: baseline; border: none; padding: 0cm;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">1404bytes from 8.8.4.4: icmp_seq=134 ttl=56 time=11.945 ms</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; vertical-align: baseline; border: none; padding: 0cm;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">1414bytes from 8.8.4.4: icmp_seq=135 ttl=56 time=11.964 ms</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; vertical-align: baseline; border: none; padding: 0cm;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">1424bytes from 8.8.4.4: icmp_seq=136 ttl=56 time=13.492 ms</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; vertical-align: baseline; border: none; padding: 0cm;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">1434bytes from 8.8.4.4: icmp_seq=137 ttl=56 time=13.652 ms</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; vertical-align: baseline; border: none; padding: 0cm;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">1444bytes from 8.8.4.4: icmp_seq=138 ttl=56 time=133.241 ms</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; vertical-align: baseline; border: none; padding: 0cm;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">1454bytes from 8.8.4.4: icmp_seq=139 ttl=56 time=17.463 ms</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; vertical-align: baseline; border: none; padding: 0cm;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">1464bytes from 8.8.4.4: icmp_seq=140 ttl=56 time=12.307 ms</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; vertical-align: baseline; border: none; padding: 0cm;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">1474bytes from 8.8.4.4: icmp_seq=141 ttl=56 time=11.987 ms</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; vertical-align: baseline; border: none; padding: 0cm;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">ping:sendto: Message too long</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; vertical-align: baseline; border: none; padding: 0cm;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">ping:sendto: Message too long</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; vertical-align: baseline; border: none; padding: 0cm;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">Requesttimeout for icmp_seq 142</span></span></p></div><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"> </span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">为什么是<span>1500</span>字节？这是<span>MacOS X</span>上默认的最大传输单元的大小。这也是<span>Windows</span>平台上默认的最大传输单元的大小。所以现在我们对数据包的大小有了一个上限（也就是不能超过这个默认的最大传输单元的大小），假如你真的关心数据包通过<span>Windows</span>平台或者<span>Mac</span>平台进行传播而不希望数据包在<span>IP</span>层进行分包或者有被丢弃的可能的话，那么就要保证数据包的大小不能超过这个上限：<span>1472</span>个字节。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">那么这个最大传输单元的大小的下限是多少呢？<span>MacOS X</span>允许设置的最大传输单元的大小的值是在<span>1280</span>到<span>1500</span>，所以我对现在互联网上通过<span>IPv4</span>进行传播的数据包的最大传输单元的大小的下限有一个比较保守的估计，就是<span>1200</span>字节。如果是在通过<span>IPv4</span>进行传播的情况下这个比较保守的大传输单元的大小的下限也会是一个很好的估计值，任意数据包只要大小小于<span>1280</span>字节都能保证在没有<span>IP</span>层分包的情况下顺利的传播。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">这个估计与我在职业生涯中感受到的情况是比较一致的。以我的经验来看，很少有游戏会试图做这些复杂的事情，诸如尝试发现路径上的最大传输单元的大小之类的，它们一般都是假定一个合理又保守的最大传输单元的大小然后一直遵循这个值。如果出现一个要发送的数据包比这个保守的最大传输单元的大小要大的情况，游戏协议会将这个数据包分成几个包然后在网络的另外一侧进行重组。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">而这正是我要在这篇文章里面要向你传授的内容。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><br></span></span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"></p><h2 id="分包后的数据包的结构"><span style="color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;font-size:x-large;">分包后的数据包的结构</span></span></h2><p></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">让我们从决定该对网络上传输的数据分包后采用什么的结构进行表示来开始构建我们的数据包分包和重组机制。在理想状态下，我们希望分包以后的数据包和未分包的数据包兼容我们现在已经建立好的数据包结构，这样当我们发送小于最大传输单元的大小的数据包的时候，网络协议没有任何多余的负载。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">下面是在前一篇文章结束的时候得到的数据包的结构：</span></span></p><br><br><pre><del>[protocol id] (64 bits)</del> // not actually sent, but used to calc crc32<br>[crc32] (32 bits)<br>[packet type] (2 bits for 3 distinct packet types)<br>(variable length packet data according to packet type)<br>[end of packet serialize check] (32 bits)<br></pre><br><br><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">在我们这个例子之中，我们一共有三个数据包的类型，分别是Ａ、Ｂ和Ｃ。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">让我们用这三个数据包类型中的一个制造一个比最大传输单元的大小还要大一些的数据包：</span></span></p><div><div id="highlighter_44479" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2"><span style="font-family:微软雅黑;">1</span></div><div class="line number2 index1 alt1"><span style="font-family:微软雅黑;">2</span></div><div class="line number3 index2 alt2"><span style="font-family:微软雅黑;">3</span></div><div class="line number4 index3 alt1"><span style="font-family:微软雅黑;">4</span></div><div class="line number5 index4 alt2"><span style="font-family:微软雅黑;">5</span></div><div class="line number6 index5 alt1"><span style="font-family:微软雅黑;">6</span></div><div class="line number7 index6 alt2"><span style="font-family:微软雅黑;">7</span></div><div class="line number8 index7 alt1"><span style="font-family:微软雅黑;">8</span></div><div class="line number9 index8 alt2"><span style="font-family:微软雅黑;">9</span></div><div class="line number10 index9 alt1"><span style="font-family:微软雅黑;">10</span></div><div class="line number11 index10 alt2"><span style="font-family:微软雅黑;">11</span></div><div class="line number12 index11 alt1"><span style="font-family:微软雅黑;">12</span></div><div class="line number13 index12 alt2"><span style="font-family:微软雅黑;">13</span></div><div class="line number14 index13 alt1"><span style="font-family:微软雅黑;">14</span></div><div class="line number15 index14 alt2"><span style="font-family:微软雅黑;">15</span></div><div class="line number16 index15 alt1"><span style="font-family:微软雅黑;">16</span></div><div class="line number17 index16 alt2"><span style="font-family:微软雅黑;">17</span></div><div class="line number18 index17 alt1"><span style="font-family:微软雅黑;">18</span></div><div class="line number19 index18 alt2"><span style="font-family:微软雅黑;">19</span></div><div class="line number20 index19 alt1"><span style="font-family:微软雅黑;">20</span></div><div class="line number21 index20 alt2"><span style="font-family:微软雅黑;">21</span></div><div class="line number22 index21 alt1"><span style="font-family:微软雅黑;">22</span></div><div class="line number23 index22 alt2"><span style="font-family:微软雅黑;">23</span></div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><span style="font-family:微软雅黑;"><code class="cpp keyword bold">static</code> <code class="cpp keyword bold">const</code> <code class="cpp color1 bold">int</code> <code class="cpp plain">MaxItems = 4096 * 4;</code></span></div><div class="line number2 index1 alt1"><span style="font-family:微软雅黑;"> </span></div><div class="line number3 index2 alt2"><span style="font-family:微软雅黑;"><code class="cpp keyword bold">struct</code> <code class="cpp plain">TestPacketB : </code><code class="cpp keyword bold">public</code> <code class="cpp plain">protocol2::Packet</code></span></div><div class="line number4 index3 alt1"><code class="cpp plain"><span style="font-family:微软雅黑;">{</span></code></div><div class="line number5 index4 alt2"><span style="font-family:微软雅黑;"><code class="cpp spaces">    </code><code class="cpp color1 bold">int</code> <code class="cpp plain">numItems;</code></span></div><div class="line number6 index5 alt1"><span style="font-family:微软雅黑;"><code class="cpp spaces">    </code><code class="cpp color1 bold">int</code> <code class="cpp plain">items[MaxItems];</code></span></div><div class="line number7 index6 alt2"><span style="font-family:微软雅黑;"> </span></div><div class="line number8 index7 alt1"><span style="font-family:微软雅黑;"><code class="cpp spaces">    </code><code class="cpp plain">TestPacketB() : Packet( TEST_PACKET_B )</code></span></div><div class="line number9 index8 alt2"><span style="font-family:微软雅黑;"><code class="cpp spaces">    </code><code class="cpp plain">{</code></span></div><div class="line number10 index9 alt1"><span style="font-family:微软雅黑;"><code class="cpp spaces">        </code><code class="cpp plain">numItems = random_int( 0, MaxItems );</code></span></div><div class="line number11 index10 alt2"><span style="font-family:微软雅黑;"><code class="cpp spaces">        </code><code class="cpp keyword bold">for</code> <code class="cpp plain">( </code><code class="cpp color1 bold">int</code> <code class="cpp plain">i = 0; i &lt; numItems; ++i )</code></span></div><div class="line number12 index11 alt1"><span style="font-family:微软雅黑;"><code class="cpp spaces">            </code><code class="cpp plain">items[i] = random_int( -100, +100 );</code></span></div><div class="line number13 index12 alt2"><span style="font-family:微软雅黑;"><code class="cpp spaces">    </code><code class="cpp plain">}</code></span></div><div class="line number14 index13 alt1"><span style="font-family:微软雅黑;"> </span></div><div class="line number15 index14 alt2"><span style="font-family:微软雅黑;"><code class="cpp spaces">    </code><code class="cpp keyword bold">template</code> <code class="cpp plain">&lt;</code><code class="cpp keyword bold">typename</code> <code class="cpp plain">stream</code><code class="cpp string"></code><code class="cpp plain">&gt; </code><code class="cpp color1 bold">bool</code> <code class="cpp plain">Serialize( Stream &amp; stream )</code></span></div><div class="line number16 index15 alt1"><span style="font-family:微软雅黑;"><code class="cpp spaces">    </code><code class="cpp plain">{</code></span></div><div class="line number17 index16 alt2"><span style="font-family:微软雅黑;"><code class="cpp spaces">        </code><code class="cpp plain">serialize_int( stream, numItems, 0, MaxItems );</code></span></div><div class="line number18 index17 alt1"><span style="font-family:微软雅黑;"><code class="cpp spaces">        </code><code class="cpp keyword bold">for</code> <code class="cpp plain">( </code><code class="cpp color1 bold">int</code> <code class="cpp plain">i = 0; i &lt; numItems; ++i )</code></span></div><div class="line number19 index18 alt2"><span style="font-family:微软雅黑;"><code class="cpp spaces">            </code><code class="cpp plain">serialize_int( stream, items[i], -100, +100 );</code></span></div><div class="line number20 index19 alt1"><span style="font-family:微软雅黑;"> </span></div><div class="line number21 index20 alt2"><span style="font-family:微软雅黑;"><code class="cpp spaces">        </code><code class="cpp keyword bold">return</code> <code class="cpp keyword bold">true</code><code class="cpp plain">;</code></span></div><div class="line number22 index21 alt1"><span style="font-family:微软雅黑;"><code class="cpp spaces">    </code><code class="cpp plain">}</code></span></div><div class="line number23 index22 alt2"><span style="font-family:微软雅黑;"><code class="cpp plain">};</code><code class="cpp keyword bold"></code><code class="cpp plain"></code></span></div></div></td></tr></table></div></div><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><br></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">这可能看起来不怎么自然，但在现实世界中这些情况真的会发生。举个简单的例子来说，如果你有一个策略，这个策略是从服务器往客户端发送所有的未确认的事件，你会得到一组可信赖也有序的事件，但是也会遇到大量数据包的丢失的情况，你会轻易的遇到数据包比最大传输单元的大小还要大的情况，即使你的数据包的平均大小非常小。（译注：这是由于丢包重传导致的不停重发，而重发的数据包在<span>UDP</span>或者<span>TCP</span>上会进行合并。所以即使数据包的平均大小远小于最大传输单元的大小，但是由于大量这样的数据包的合并，还是很容易出现超过最大传输单元的大小的情况）。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">在大多数的情况下，通过实现这么一个策略：在一个数据包里面只包含很少一组事件或者状态更新来避免数据包的大小超过最大传输单元的大小，采用这种策略以后可以有效的规避上面的那种情况。这种规划在很多情况下都工作的很棒。。。但是有一种情况下这种策略也是存在问题的，这种情况就是增量编码。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">由一个增量编码器创建的数据包的大小是与当前状态与之前状态之间所发生的状态变化的数量成正比的。如果这两个状态之间有大量的不同的话，那么增量也将很大并且你对这种情况其实是没有什么办法的。如果出现一个增量恰好比最大传输单元的大小要大的情况，当然这是一个坏运气下才会出现的情况，但是你仍然要发送这个超过最大传输单元的大小的数据包！所以你可以看到，在增量编码的情况下，你真的不能限制数据包的最大大小一定小于最大传输单元的大小，在这种情况下，数据包的分包和重组策略就有了用武之地。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">让我们回到数据包的结构上面来。在每个数据包的包头的地方添加一个序号是一种非常常见的做法。这并没有什么复杂的。这只是一个数据包的序号，会在每个数据包进行发送的时候依次加一。举个例子来说，就是<span>0</span>、<span>1</span>、<span>2</span>、<span>3</span>这么简单。我喜欢用<span>16</span>比特来表示这个序号，即使在每秒发送<span>60</span>个数据包的情况下，只要<span>15</span>分钟序号就会被用完一遍，需要再次从头开始重用，但是这么做也没有什么关系，主要是因为你在网络上收到一个<span>15</span>分钟之前发送出去的数据包是一个非常罕见的事情，所以你很少会有机会困惑这到底是一个新的数据包还是一个旧的数据包（因为<span>IP</span>层在包头的地方有个跳转计数，超出一定跳转次数的数据包会被丢弃掉，所以基本不用担心这种情况）。如果你确实关心这个问题的话，请使用<span>32</span>比特的序号进行代替。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">无论你选择用多少比特来表示这个序号，它们对于很多事情都是有用的，比如说可依赖性、检测和丢弃乱序的数据包等等。除此之外，我们需要一个数据包序号的原因是在对数据包进行分包的时候，我们需要某个方法来确定这个数据包的分包到底是属于哪个数据包的。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">所以，让我们在我们的数据包的结构里面加上序号这个东西：</span></span></p><br><br><pre><del>[protocol id] (64 bits)</del>   // not actually sent, but used to calc crc32<br>[crc32] (32 bits)<br><strong>[sequence] (16 bits)</strong><br>[packet type] (2 bits)<br>(variable length packet data according to packet type)<br>[end of packet serialize check] (32 bits)<br></pre><br><br><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">这是最有趣的部分。我们可以在数据包的头部只添加一个比特的标识<span> is_fragment</span>，但是对于通常情况下根本不需要分包的数据包来说，你就浪费了一个比特，因为它总是要被置为<span>0</span>。这不是很好。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">相反，我的选择是在数据包的结构里面添加了一个特殊的<span>”</span>分包后的数据包<span>“</span>的类型：</span></span></p><div><div id="highlighter_815496" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2"><span style="font-family:微软雅黑;">1</span></div><div class="line number2 index1 alt1"><span style="font-family:微软雅黑;">2</span></div><div class="line number3 index2 alt2"><span style="font-family:微软雅黑;">3</span></div><div class="line number4 index3 alt1"><span style="font-family:微软雅黑;">4</span></div><div class="line number5 index4 alt2"><span style="font-family:微软雅黑;">5</span></div><div class="line number6 index5 alt1"><span style="font-family:微软雅黑;">6</span></div><div class="line number7 index6 alt2"><span style="font-family:微软雅黑;">7</span></div><div class="line number8 index7 alt1"><span style="font-family:微软雅黑;">8</span></div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><span style="font-family:微软雅黑;"><code class="cpp keyword bold">enum</code> <code class="cpp plain">TestPacketTypes</code></span></div><div class="line number2 index1 alt1"><code class="cpp plain"><span style="font-family:微软雅黑;">{</span></code></div><div class="line number3 index2 alt2"><span style="font-family:微软雅黑;"><code class="cpp spaces">    </code><code class="cpp plain">PACKET_FRAGMENT = 0,     </code><code class="cpp comments">// RESERVED</code></span></div><div class="line number4 index3 alt1"><span style="font-family:微软雅黑;"><code class="cpp spaces">    </code><code class="cpp plain">TEST_PACKET_A,</code></span></div><div class="line number5 index4 alt2"><span style="font-family:微软雅黑;"><code class="cpp spaces">    </code><code class="cpp plain">TEST_PACKET_B,</code></span></div><div class="line number6 index5 alt1"><span style="font-family:微软雅黑;"><code class="cpp spaces">    </code><code class="cpp plain">TEST_PACKET_C,</code></span></div><div class="line number7 index6 alt2"><span style="font-family:微软雅黑;"><code class="cpp spaces">    </code><code class="cpp plain">TEST_PACKET_NUM_TYPES</code></span></div><div class="line number8 index7 alt1"><code class="cpp plain"><span style="font-family:微软雅黑;">};</span></code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left" style="margin-bottom: 12pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;"><span style="color: rgb(34, 34, 34); font-size: 12pt;"><span style="font-family:微软雅黑;"> </span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">这恰好不需要占据任何的空间，是因为四个数据包类型正好可以用两个比特来表示，而这两个比特的空间已经用于表示数据包类型了，我们只是在原来的枚举上新加了一个类型。这么处理以后，每次当我们读取一个数据包的时候，如果这个数据包的类型是<span>0</span>的话，我们就知道这个数据包是一个特殊的分包以后的数据包，它的内存布局可以通过数据包的类型得知，否则的话，我们就走回原来的通用的对非分包的数据包进行读取和处理的方法。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">让我们设计下这个分包后的数据包看起来应该是什么样子的。我们将允许一个数据包最多可以分成<span>256</span>个数据包，并且每个分包后的数据包的大小不会超过<span>1024</span>个字节。这样的话，我们就可以通过这样一个系统来发送大小最大为<span>256k</span>的数据包，这对于任意系统任意情况来说都应该是足够的，但是这只是我个人的一个看法，如果有特殊的情况，还请结合实际情况进行具体分析。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">有了这么一个不大的固定大小的数据包包头结构，再加上<span>UDP</span>的包头结构以及<span>IP</span>的包头结构，一个分包以后的数据包会小于之前我们保守估计的最大传输单元的大小：<span>1200</span>字节。除此之外，因为一个数据包最多可以分包成<span>256</span>个数据包，我们可以用【<span>0</span>，<span>255</span>】这个范围来表示分包的<span>id</span>和序号，这样每个分包里面还需要有<span>8</span>比特来表示这个序号。</span></span></p><br><br><pre><del>[protocol id] (32 bits)</del>   // not actually sent, but used to calc crc32<br>[crc32] (32 bits)<br>[sequence] (16 bits)<br>[packet type = 0] (2 bits)<br><strong>[fragment id] (8 bits)<br>[num fragments] (8 bits)<br>[pad zero bits to nearest byte index]<br>&lt;fragment data&gt;</strong><br></pre><br><br><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">请注意，我们把这几个比特对齐到了下一个字节，然后才把对齐以后的数据写入到数据包里面。我们为什么要这么做？这么做其实是有两个原因的<span>: 1) </span>这么处理以后可以通过<span>memcpy</span>函数更快的把分包的数据拷贝到数据包里面而不需要使用位打包器来对每个字节进行处理。<span>2) </span>我们通过不发送分包数据的大小节省了一小部分带宽。我们可以通过从数据包的整体大小减去分包数据起始位置的字节序号来推断出这个分包的大小。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><br></span></span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"></p><h2 id="发送分包以后的数据包"><span style="color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;font-size:x-large;">发送分包以后的数据包</span></span></h2><p></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">发送分包以后的数据包是一件非常容易的事情。如果数据包的大小小于保守估计的最大传输单元的大小。那么就按正常的方法进行发送。否则的话，就计算这个数据包到底该分成多少个<span>1024</span>字节的数据包分包，然后构建这些分包并按照之前发送正常数据包的方法进行发送。发送出去以后也不记录发送的数据包的内容，这没什么困难的！</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">这种发送以后不记录发送的数据包的内容的方法有一个后果，就是数据包的任意一个分包如果丢失的话，那么整个数据包就都要丢弃。由此可见，当你需要发送要给<span>256K</span>的数据包的时候要发送<span>256</span>个分包，如果有一个分包丢失的话，你就要重新把这个<span>256k</span>的数据包再分一次包然后再发送出去。这绝对不是一个好主意。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-family:微软雅黑;"><span style="font-size: 12pt; color: rgb(34, 34, 34);">这显然是一个很糟糕的办法，因为随着分包数目的增多，发生丢失的概率肯定是显著的增大。这种增长关系不是线性的，而是一种相当复杂的关系，如果你对这个计算感兴趣的话，你可以读下<a rel="noopener" href="http://www.fourmilab.ch/rpkp/experiments/statistics.html" target="_blank">这篇文章</a></span><span style="font-size: 12pt; color: rgb(34, 34, 34);">。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">简而言之，如果你要计算一个数据包会被丢弃的概率，你必须要计算所有分包被成功发送到目的地的概率，然后从<span>1</span>中减去这个概率，得到的结果就是至少有一个分包丢失的概率。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">下面这个公式可以用来计算因为分包丢失导致整个数据包被丢弃的概率：</span></span></p><p class="MsoNormal" align="left" style="margin-bottom: 12pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;"><span style="font-size: 10pt; color: rgb(40, 40, 40);"><span style="font-family:微软雅黑;">＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼</span></span></p><div style="border:solid #F0F0F0 1.0pt;border-left:solid #E0E0E0 2.25pt;padding:0cm 0cm 0cm 0cm;background:whitesmoke"><p class="MsoNormal" align="left" style="line-height: 16.8pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; vertical-align: baseline; border: none; padding: 0cm;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">1- ( probability of fragment being delivered ) ^ num_fragments</span></span></p></div><p class="MsoNormal" align="left" style="margin-bottom: 12pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;"><span style="font-size: 10pt; color: rgb(40, 40, 40);"><span style="font-family:微软雅黑;">＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼＼</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"> </span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">让我们举个简单的例子对上面这个公式进行说明，如果我们发送的一个不需要分包的数据包，如果它在网络上传说的时候丢失的概率是<span>1%</span>，那么只有百分之一的概率会出现这个数据包被丢弃的情况，或者我们不要嫌麻烦，把这些数据代入到上面这个公式里面<span>: 1 – (99/100) ^ 1 = 1/100 = 1%</span>。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">随着分包数量的增加，整个数据包被丢弃的概率也随之增加：</span></span></p><ul type="disc"><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size: 12pt;"><span style="font-family:微软雅黑;">两个分包的情况：<span> 1 – (99/100) ^ 2 = <b><span style="border:none windowtext 1.0pt;     padding:0cm">2%</span></b></span><b><span style="border:none windowtext 1.0pt;     padding:0cm">。</span></b></span></span></li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size: 12pt;"><span style="font-family:微软雅黑;">十个分包的情况：<span> 1 – (99/100) ^ 10 = <b><span style="border:none windowtext 1.0pt;     padding:0cm">9.5%</span></b></span><b><span style="border:none windowtext 1.0pt;     padding:0cm">。</span></b></span></span></li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size: 12pt;"><span style="font-family:微软雅黑;">一百个分包的情况：<span> 1 – (99/100) ^ 100 = <b><span style="border:none windowtext 1.0pt;     padding:0cm">63.4%</span></b></span><b><span style="border:none windowtext 1.0pt;     padding:0cm">。</span></b></span></span></li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size: 12pt;"><span style="font-family:微软雅黑;">二百五十六个分包的情况：<span> 1 – (99/100) ^ 256 = <b><span style="border:none windowtext 1.0pt;     padding:0cm">92.4%</span></b></span><b><span style="border:none windowtext 1.0pt;     padding:0cm">。</span></b></span></span></li></ul><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">所以我建议你要小心分包以后的数量。这个策略最好是只对<span>2-4</span>个分包的情况进行使用，而且最好是针对那种对时间不怎么敏感的数据使用或者是就算分包lost了也无所谓的情况。绝对不要只是为了省事就把一大堆依赖顺序的事件打到一个大数据包里面然后依赖数据包的分包和重组机制进行发送。这会让事情变得更加麻烦。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">大数据包的另外一种典型的用途是当客户端新连入一个游戏服务器的时候。游戏服务器通常会把大块的数据以一种可靠的方式下发给客户端。对于后期才加入的客户端而言，这些大块的数据也许代表了世界的初始状态。无论这些数据包含了怎么样的信息，请不要使用本篇文章的分包技巧来给客户端下发大块的数据。相反，请查阅这个系列教程的下篇文章，在那篇文章里面将讲解如何在有数据包可能发生丢失的情况下，快速可靠的发送大块的数据直到这些大块的数据完全被确认接收。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><br></span></span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"></p><h2 id="对分包后的数据包的接收"><span style="color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;font-size:x-large;">对分包后的数据包的接收</span></span></h2><p></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">尽管发送分包以后的数据包是一件相同简单的事情，但是对分包后的数据包进行接收就相对需要技巧了。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">之所以对分包后的数据包进行接收很困难的原因是我们不仅需要给缓冲区建立一个数据结构还要把这些分包重组成原始的数据包，我们也要特别小心如果有人试图让我们的程序产生崩溃而给我们发送恶意的数据包。</span></span></p><br><br><pre><del>[protocol id] (32 bits)</del>   // not actually sent, but used to calc crc32<br>[crc32] (32 bits)<br>[sequence] (16 bits)<br>[packet type = 0] (2 bits)<br><strong>[fragment id] (8 bits)<br>[num fragments] (8 bits)<br>[pad zero bits to nearest byte index]<br>&lt;fragment data&gt;</strong><br></pre><br><br><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">下面列出的是我能想到的如何攻击你的协议以便让你的服务器崩溃的所有方法：</span></span></p><ul type="disc"><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size: 12pt;"><span style="font-family:微软雅黑;">尝试发送分包<span>ID</span>在一个限制范围内的分包，看看能不能让你的程序崩溃。举个例子来说，也许这个数据包只有两个分包，但是我会发送多个分包<span>ID</span>在【０，２５５】之内的分包。</span></span></li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size: 12pt;"><span style="font-family:微软雅黑;">发送一个数据包，让我们假设这个书包的最大分包数量是<span>2</span>，然后发送多个属于这个数据包的分包，但是在分包的数据包报头里面把最大分包的数量改为<span>256</span>，来希望你在接收完第一个分包以后，不会发现分包的最大数量信息被改变了，这样就有可能造成你的内存崩溃。</span></span></li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size: 12pt;"><span style="font-family:微软雅黑;">发送非常大的分包，让分包里面的数据超过<span>1k</span>，测试下你在试图把分包数据拷贝到数据结构的时候是否有良好的判断，如果没有良好的判断的话，这也许会让你的内存崩溃，或者占用大量的内容让你在分配新的分包的时候没有空间。 </span></span></li><li class="MsoNormal" style="color:#222222;text-align:left;vertical-align:baseline"><span style="font-size: 12pt;"><span style="font-family:微软雅黑;">持续的给你的程序发送最大分包数目的分包（也就是如果最大分包数目是<span>256</span>的话，就持续不断的发送分包<span>ID</span>是<span>256</span>的数据包），希望你会分配大量的内容来容纳这些分包然后让你的内存崩溃。让我们假设你的程序中有一个滑动窗口，这个滑动窗口有<span>256</span>个数据包，每个数据包最多可以有<span>256</span>个分包，每个分包预留的空间是<span>1k</span>。那么也就是会给每个客户端预留<span>67,108,864</span>字节或者<span>64mb</span>的空间。我可以通过这种方法让服务器崩溃么？我能用一堆大小有趣的分包来耗尽的你地址空间的<span>heap</span>空间么？因为服务器的程序是你来设计实现的，所以只有你才知道这个问题的确切答案。它取决于你的内存预算以及如何分配内存来存储分包。如果你考虑过了觉得这会是一个问题，那么就限制下缓冲区中分包的数目或考虑减少每个数据包的分包的最大数目。考虑给每个分包静态分配数据结果或者使用一个内存池来减少内存碎片。</span></span></li></ul><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">所以你可以看到，在接收端代码是非常脆弱的，要非常小心检查一切可能的情况。除此之外，还有一个非常简单的事情要注意：让分包保存在一个数据结构里面，当一个数据包的所有分包都到达以后（通过计数来判断是否全部到达），将这些分包重组成一个大的数据包，并把这个重组后的大数据包返回给接收方。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">什么样的数据结构在这里是有意义的<span>?</span>这里并没有什么特别的数据结构<span>!</span>我使用的是一种我喜欢称之为序列缓冲区的东西。我想和你分享的最核心的技巧是如何让这个数据结构变得高效：</span></span></p><div><div id="highlighter_81070" class="syntaxhighlighter  cpp"><div class="toolbar"><a class="toolbar_item command_help help">?</a></div><table cellpadding="0" cellspacing="0"><tr><td class="gutter"><div class="line number1 index0 alt2"><span style="font-family:微软雅黑;">1</span></div><div class="line number2 index1 alt1"><span style="font-family:微软雅黑;">2</span></div><div class="line number3 index2 alt2"><span style="font-family:微软雅黑;">3</span></div><div class="line number4 index3 alt1"><span style="font-family:微软雅黑;">4</span></div><div class="line number5 index4 alt2"><span style="font-family:微软雅黑;">5</span></div><div class="line number6 index5 alt1"><span style="font-family:微软雅黑;">6</span></div><div class="line number7 index6 alt2"><span style="font-family:微软雅黑;">7</span></div><div class="line number8 index7 alt1"><span style="font-family:微软雅黑;">8</span></div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><span style="font-family:微软雅黑;"><code class="cpp keyword bold">const</code> <code class="cpp color1 bold">int</code> <code class="cpp plain">MaxEntries = 256;</code></span></div><div class="line number2 index1 alt1"><span style="font-family:微软雅黑;"> </span></div><div class="line number3 index2 alt2"><span style="font-family:微软雅黑;"><code class="cpp keyword bold">struct</code> <code class="cpp plain">SequenceBuffer</code></span></div><div class="line number4 index3 alt1"><code class="cpp plain"><span style="font-family:微软雅黑;">{</span></code></div><div class="line number5 index4 alt2"><span style="font-family:微软雅黑;"><code class="cpp spaces">    </code><code class="cpp color1 bold">bool</code> <code class="cpp plain">exists[MaxEntries];</code></span></div><div class="line number6 index5 alt1"><span style="font-family:微软雅黑;"><code class="cpp spaces">    </code><code class="cpp plain">uint16_t sequence[MaxEntries];</code></span></div><div class="line number7 index6 alt2"><span style="font-family:微软雅黑;"><code class="cpp spaces">    </code><code class="cpp plain">Entry entries[MaxEntries];</code></span></div><div class="line number8 index7 alt1"><code class="cpp plain"><span style="font-family:微软雅黑;">};</span></code></div></div></td></tr></table></div></div><p class="MsoNormal" align="left" style="margin-bottom: 12pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;"><span style="font-family:微软雅黑;"><br></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">这里面有几件事情值得注意。首先，使用类似数组的结构可以允许对给定条目是否存在于一个序列缓冲区的存在性进行快速测试并且将测试结果进行缓存，即使每个数据包的条目结构是非常大的（而且这种结构对于数据包的分包和重组来说是非常棒的）。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">那么我们该如何使用这个数据结构？当你接收到一个分包以后的数据包以后，这个数据包会携带一个序号指定它是属于哪个数据包的分包。这个序号会随着发送而不停的增大<span>(</span>所有序号全部用完导致发生环绕除外<span>)</span>， 所以最关键的技巧是你要对序号进行散列让散列后的序号进入一个数组中某个给定的位置，具体处理过程如下所示：</span></span></p><div style="border:solid #F0F0F0 1.0pt;border-left:solid #E0E0E0 2.25pt;padding:0cm 0cm 0cm 0cm;background:whitesmoke"><p class="MsoNormal" align="left" style="line-height: 16.8pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; vertical-align: baseline; border: none; padding: 0cm;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">int index = sequence % MaxEntries;</span></span></p></div><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"> </span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">现在你可以用<span>O(1)</span>的时间复杂度进行一个快速测试，来通过序号看下一个给定的条目是否存在，并且判断下这个条目是否和你想要读取或者写入的数据包序号相匹配。也就是说，你既需要测试存在性又需要测试序号是否是预期的序号，这是因为所有的序号都是有效的数字<span>(</span>比如说是<span>0)</span>，还有就是因为根据一个特定的数据包序号查找到的条目可能是存在的，但是它属于过去的一个序号（比如说，这是某个其他的序号，但是恰巧通过取模的计算得到相同的序号）。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">所以当一个新的数据包的第一个分包到达的时候，你需要把数据包的序号散列成一个索引，如果发现这个索引对应的内容还不存在的话，你需要设置<span>exists[index] = 1</span>，并设置<span>sequence[index]</span>来匹配你正在处理的数据包，并把这个分包储存在序号缓冲区对应的条目里面。这样当下一次有分包实际到达的时候，你会得到相同的序号，然后得到一个相当的索引，在查找的时候会发现对应这个索引的内容已经存在了，并且这个条目的序号正好能和刚刚接收到的数据包的序号匹配，所以你就可以把这个分包累加到这个条目上，这个过程会一直重复直到这个数据包的所有分包都被接收到为止。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">如果从比较抽象的层次来解释这个事情的话，基本原理大概就是这样的。这种方法的一个更完整的解释请参阅本文的示例源代码。在地址<span><a href="https://www.patreon.com/gafferongames" target="_blank" rel="noopener">https://www.patreon.com/gafferongames</a></span>可以获取本系列文章示例的源代码。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><br></span></span></p><p class="MsoNormal" align="left" style="vertical-align: baseline;"></p><h2 id="网络协议的测试驱动开发"><span style="color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;font-size:x-large;">网络协议的测试驱动开发</span></span></h2><p></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">还有一件事情我想在文章的末尾进行补充说明。我感觉如果我不向我的读者提及这个方法的话，就是对他们的一个伤害。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">编写一个定制的网络协议是非常困难的。这个过程是如此的苦难以至于我从头开始至少编写了<span>10</span>次网络协议，但是每次我都觉得我在用一种全新的有趣的方法在做这个事情。也许你会认为是我在挑战自己，用一些新奇的方法来实现这个过程，但其实是这个过程太复杂了，完全没有办法按照预期的那样写完代码就期待它们能够正确的工作。你需要对写出来的代码进行测试！</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">当编写底层网络协议层的代码的时候，我的策略是<span>:</span></span></span></p><p style=" margin: 6pt 0cm 6pt 21pt ; ; ; ; "><span style="font-family:微软雅黑;font-size:medium;"><span style="color: rgb(34, 34, 34);">1、</span><span style="color: rgb(34, 34, 34);">防御性编程。在一切可能的地方进行断言。当某些地方出现错误的时候这些断言会起作用，并且将成为查找问题的重要线索。</span></span></p><p style=" margin: 6pt 0cm 6pt 21pt ; ; ; ; "><span style="font-family:微软雅黑;font-size:medium;"><span style="color: rgb(34, 34, 34);">2、</span><span style="color: rgb(34, 34, 34);">添加函数的功能测试，确保它们是如你的预期那样工作的。把你的代码放到一个可以运行和测试的环境下，这样可以不时地对它们进行测试以便可以确保它一直会像你起初创建它们时候那样良好的工作。仔细考虑有哪些情况需要正确的处理并给这些情况添加测试。</span></span></p><p style=" margin: 6pt 0cm 6pt 21pt ; ; ; ; "><span style="font-family:微软雅黑;font-size:medium;"><span style="color: rgb(34, 34, 34);">3、</span><span style="color: rgb(34, 34, 34);">虽然函数测试非常有必要，但是只是添加一些函数测试是远远不够的。无论如何都有遇到你没有预料到的情况<span>! </span>现在你必须把它们放到一个真实的环境下看看到底会发生什么。我把这个称之为浸泡测试，并且在我之前编写网络协议的过程中还从来没有过在浸泡测试的过程中没有发现问题的情况。浸泡测试只是在不停的循环，并会随机的做一些事情让你的系统在它的空间中处理一些情况，让我们举些简单的例子对它进行一些简单的说明，比如说构造出随机长度的数据包，而且这些数据包有一个非常高的丢失率，通过数据包模拟器发出的大量乱序并且重复的数据包等等。如果你的程序能够在一晚上的时间里面不挂起或者遇到断言，那么就算你的程序通过了浸泡测试。</span></span></p><p style=" margin: 6pt 0cm 6pt 21pt ; ; ; ; "><span style="font-family:微软雅黑;font-size:medium;"><span style="color: rgb(34, 34, 34);">4、</span><span style="color: rgb(34, 34, 34);">如果你的程序在浸泡测试的过程中发现了某些问题。你可能需要在代码里面添加一些详细的日志以便下次在浸泡测试的时候如果遇到了同样的问题你可以找到出现问题的原因。一旦你知道发生了什么，就可以停止了。不要立即的修复这个问题并且再次运行浸泡测试。这种做法非常的愚蠢。相反，利用单元测试来不停的重现你需要修复的问题，确保单元测试能够重现问题，而且这个问题因为你的修复已经彻底修好了。只有在这样的处理流程之后，才能回到浸泡测试并确保程序在浸泡测试能正常运转一整夜。通过这种方式，单元测试能够记录你的系统的正确的行为并且在以后需要的时候可以快速的运行起来，确保当你做其他改变的时候不会导致一些原来修过的问题重复的出现。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">这就是我的数据包分包和重组的处理流程了，它似乎工作的不错。如果你在进行一些底层的网络协议的设计，你的游戏的其他的部分将依赖于底层的网络协议的设计。在你继续构建其他的功能之前，你需要绝对的确认底层的网络协议是否能够正常的工作，否则就像一堆胡乱堆积的卡片，很容易就散架了。多人在线游戏的网络部分是非常困难的，如果不小心设计的话，很容易就会出现底层网络协议可能无法正常的工作或者存在缺陷。所以请确保你是知道你的底层网络协议是如何工作的！</span></span></p><b><span style="font-size: 12pt; line-height: 156%; font-weight: normal;"><span style="font-family:微软雅黑;">即将到来的文章的预告</span></span></b><div><span style="font-size: 12pt; line-height: 156%; font-weight: normal;"><span style="font-family:微软雅黑;"><br></span></span></div><p class="MsoNormal" align="left" style="vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">下一篇文章是<span>: </span>《发送大块的数据》</span></span></p><p class="MsoNormal" align="left" style="line-height: 18pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">请继续阅读本系列的下一篇文章，在哪篇文章里面我将向你展示如何通过数据包快速可信赖的发送大块的数据，如果其中一块数据丢失了也不需要丢弃整个数据包！</span></span></p><p class="MsoNormal" align="left" style="line-height: 18pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">如果你觉得这篇文章有价值的话，请在<span>patreon</span>上支持我的写作，这样我会写的更快。你可以在<span>BSD 3.0</span>许可下访问到这篇文章里面的代码。非常感谢你的支持！</span></span></p><p class="MsoNormal" align="left" style="line-height: 18pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"><br></span></span></p><p class="MsoNormal" align="left" style="line-height: 18pt; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">【版权声明】</span></span></p><p class="MsoNormal"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;">原文作者未做权利声明，视为共享知识产权进入公共领域，自动获得授权。</span></span></p><p class="MsoNormal" align="left" style="line-height: 16.8pt; vertical-align: baseline;"><span style="font-size: 12pt; color: rgb(34, 34, 34);"><span style="font-family:微软雅黑;"> </span></span></p><p class="MsoNormal"><span style="font-size: 12pt;"><span style="font-family:微软雅黑;"> </span></span></p></div>                    <br>                

          
        
      


      

    
      <footer class="post-footer">
        

        

        

        
        
          <div class="post-eof"></div>
        
      </footer>
      
    </div>
    
    
    

    

    

    

  </div>
  
  
  
  </article>


      
    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/26/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/26/">26</a><span class="page-number current">27</span><a class="page-number" href="/page/28/">28</a><span class="space">&hellip;</span><a class="page-number" href="/page/53/">53</a><a class="extend next" rel="next" href="/page/28/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  

  <aside id="sidebar" class="sidebar">

    
      
        <div id="sidebar-dimmer"></div>
      
    

    <div class="sidebar-inner">
    
      <div class="sidebar-toggle-inside motion-element">
        <div class="sidebar-toggle-line-wrap">
          <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
          <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
          <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
        </div>
      </div>

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <a href="/" class="site-author-image" rel="start" style="border:none">
            <img class="site-author-image" itemprop="image" src="/uploads/avatar.png" alt="no5ix">
          </a>
          <p class="site-author-name" itemprop="name">no5ix</p>
           
              <p class="site-description motion-element" itemprop="description">推荐使用Chrome/Firefox/Safari阅读本博客. 以前的老笔记将会一篇一篇慢慢整理为博客, 这既启发了他人, 也锻炼了自己的描述交流能力.</p>
          
        </div>

        <nav class="site-state motion-element">

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">262</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">97</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

          <div class="site-state-item site-state-about">
            <a href="/about/">
              <span class="site-state-item-about fa fa-fw fa-user"></span>
              <span class="site-state-item-name">关于</span>
            </a>
          </div>
          
        </nav>

        

        <div class="links-of-author motion-element">
          
          
          <!-- 网易云音乐 -->
            <!-- <div class="netease-cloud-music"> -->
              <!-- <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=280 height=110 src="//music.163.com/outchain/player?type=0&id=992743594&auto=0&height=90"></iframe> -->
            <!-- </div> -->
          <!-- 网易云音乐 -->

        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-block">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://119.23.17.57" title="ksun的博客" target="_blank">ksun的博客</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://mp.weixin.qq.com/mp/homepage?__biz=MzU3MTUyNzg0NQ==&hid=1&sn=7a3ae61b7af714f75d68e7ae826a2d2c&scene=18#wechat_redirect" title="你有图么我有故事" target="_blank">你有图么我有故事</a>
                </li>
              
            </ul>
          </div>
        

        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2013 - 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">no5ix</span>
</div>



        

        
      </div>
    </footer>

    <!--
    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
      
        <span id="scrollpercent"><span>0</span>%</span>
      
    </div>
    -->

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/dist/jquery.fancybox.js?v=3.2.10"></script>


  




  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>


  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  

  <script type="text/javascript">

    var is_load_xml_finished = 0;

    var searchFunc = function (path, search_id, content_id) {
      // 0x00. environment initialization
      'use strict';

      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      // var datas = [];

      /* loading css1 : Dot Css Loader*/
      var DotLoader = "<div class='loader'>Loading...</div>";

      /* loading css2 : Pure Css Loader - Square */
      var SquareLoader = 
        "<div class='loader'>" +
          "<div class='square' ></div>" +
          "<div class='square'></div>" +
          "<div class='square last'></div>" +
          "<div class='square clear'></div>" +
          "<div class='square'></div>" +
          "<div class='square last'></div>" +
          "<div class='square clear'></div>" +
          "<div class='square '></div>" +
          "<div class='square last'></div>" +
        "</div>";

      var ProgressBar = 
          "<div class='progress-bar'>" +
            "<div class='progress-bar-charge'></div>" +
          "</div>";

      var str = "";
      var keywords = [];
      var temp_keyword = "";

      // 是否为第一个字母被键入的标志位
      var first_char_flag = 0;

      // 因为在移动设备上, 点击搜索之后会 scroll 到页面顶部, 所以需要记录之前的页面x, y坐标值, 以便于搜索完点击 close 按钮之后 scroll 回原来的页面坐标值.
      var last_page_x = 0;
      var last_page_y = 0;

      var local_search_tips = 
            "<span class='local-search-empty'>" + "第一次搜索可能较慢, 先思考一个经典算法问题, 跳台阶:" + "</span>" +
            "<span class='local-search-empty'>" + "一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个6级的台阶总共有多少种跳法?n级呢?" + "</span>";

      function CloseLocalSearch()
      {
        first_char_flag = 0;

        $('#local-search-input').val('');
        $('#local-search-close').hide();

        // $('.local-search-result-cls ul li').velocity('stop').velocity('transition.slideDownOut', 200);

        $('#' + content_id).attr("headroom_special_attr","true"); 
        
        if (isMobile())
        {
          // $('body').scrollTop(last_page_y);  // scrollTop 有兼容性问题
          scrollTo(last_page_x, last_page_y);

          $('#' + content_id).hide();
        }
        else
        {
          $('#' + content_id).velocity('stop').velocity( 'transition.bounceUpOut', 200 );
        }

        // $('#' + content_id).velocity('stop').velocity( isMobile() ? 'transition.fadeOut' : 'transition.bounceUpOut', {
        //   // delay: isMobile() ? 50 : 0,
        //   duration: isMobile() ? 500 : 200,
        //   // begin: function() { 
        //   //   if (isMobile())
        //   //   {
        //   //     $('body').scrollTop(last_page_y);
        //   //   } 
        //   // }
        //   complete: function () {
        //     if (isMobile())
        //     {
        //       if (last_page_y < 20000)
        //       {
        //         $('body').velocity('scroll', { offset: last_page_y+"px", duration: last_page_y < 10000 ? 1000 : 2000 });
        //       }
        //       else
        //       {
        //         $('body').scrollTop(last_page_y);
        //       }
        //       // $('body').velocity('scroll');

        //       // $('html,body').animate({
        //       //   scrollTop: last_page_y
        //       // },400);
        //       // $('body').velocity('transition.slideDownIn', 1000);
        //       // $('body').velocity('scroll', { offset: last_page_y+"px", duration: document.body.scrollHeight < 20000 ? 1500 : 3000 });
        //     }
        //   }
        // });
      }

      function handleSearch()
      {
        if (keywords.length <= 0) {
          return;
        }
        $resultContent.innerHTML = "";
        $('#local-search-close').show();

        // 0x04. perform local searching
        if (is_load_xml_finished == 0)
        {
          $resultContent.innerHTML = 
            "<ul class='local-search-empty-ul'>" + 
            local_search_tips +
            ProgressBar;
        }
        else
        {
          // Retrieve the object from local storage
          var xml_resp = retrieve_search_xml()

          xml_resp.forEach(function (data) {
          // datas.forEach(function (data) {
            var isMatch = true;
            var content_index = [];
            if (!data.title || data.title.trim() === '') {
              data.title = "Untitled";
            }
            var is_encrypted = data.encrypted.trim() == '1'
            var is_sensitive = CONFIG.local_search.sensitive_word && data_content.indexOf(CONFIG.local_search.sensitive_word) >= 0
            var orig_data_title = data.title.trim();
            var data_title = orig_data_title.toLowerCase();
            var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
            var data_content = orig_data_content.toLowerCase();
            var data_url = decodeURIComponent(data.url);
            var index_title = -1;
            var index_content = -1;
            var first_occur = -1;
            // only match artiles with not empty contents
            if (data_content !== '') {
              keywords.forEach(function (keyword, i) {
                index_title = data_title.indexOf(keyword);
                index_content = (is_sensitive || is_encrypted) ? -1 : data_content.indexOf(keyword);

                if (index_title < 0 && index_content < 0) {
                  isMatch = false;
                } else {
                  if (index_content < 0) {
                    index_content = 0;
                  }
                  if (i == 0) {
                    first_occur = index_content;
                  }
                  // content_index.push({index_content:index_content, keyword_len:keyword_len});
                }
              });
            } else {
              isMatch = false;
            }
            // 0x05. show search results
            if (isMatch) {
              var content = orig_data_content;
              if (first_occur >= 0) {
                var match_content = "";
                if (!is_sensitive && !is_encrypted)
                {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  match_content = content.substr(start, end);
                }

                // highlight all keywords
                var regS = "";
                if (match_content != "")
                {
                  keywords.forEach(function (keyword) {
                    regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<b class=\"search-keyword\">" + keyword + "</b>");
                    orig_data_title = orig_data_title.replace(regS, "<b class=\"search-keyword\">" + keyword + "</b>");
                  });
                }
                else
                {
                  keywords.forEach(function (keyword) {
                    regS = new RegExp(keyword, "gi");
                    orig_data_title = orig_data_title.replace(regS, "<b class=\"search-keyword\">" + keyword + "</b>");
                  });
                }
                str += "<li><a href='" + data_url + "' class='search-result-title' target='_blank'>" + orig_data_title + "</a>";
                str += "<p class=\"search-result\">" + match_content + "...</p>"
              }
              str += "</li>";
            }
          });

          str += "</ul>";
          if (str.indexOf('<li>') === -1) {
            return $resultContent.innerHTML = 
              "<ul class='local-search-empty-ul'><span class='local-search-empty'>找不到, 换个搜索关键字试一哈.<span></ul>";
          }
          $resultContent.innerHTML = str;
        }
      }

      $input.addEventListener('input', function () {
        // 0x03. parse query to keywords list
        str = '<ul class=\"search-result-list\">';
        temp_keyword = this.value.trim();
        if (temp_keyword.length <= 0) {
          CloseLocalSearch();
          return;
        }

        keywords = temp_keyword.toLowerCase().split(/[\s\-]+/);
        handleSearch();

        // 当用户键入第一个字母的时候的动画处理逻辑 : 
        // 当 first_char_flag 为 0 的时候, 
        // 要播放一个动画
        if (first_char_flag == 0)
        {
            // $('body').scrollTop(0);
          if (isMobile())
          {
            last_page_x = window.pageXOffset;
            last_page_y = window.pageYOffset;
            // $('body').scrollTop(0);
            scrollTo(0,0);

          }
          first_char_flag = 1;
          $('#' + content_id).removeAttr("headroom_special_attr");
          
          $('#' + content_id).velocity('stop').velocity('transition.slideDownIn', 300);

          $('.local-search-result-cls ul li').velocity('stop').velocity('transition.slideDownIn', 1000);
        }
      });


      var local_search_xml_data = localStorage.getItem('local_search_xml_data');
      if (!local_search_xml_data) {
        $.ajax({
          // 0x01. load xml file
          url: path,
          dataType: "xml",
          success: function (xmlResponse) {
            store_search_xml(xmlResponse);

            // setTimeout(function(){
            //   is_load_xml_finished = 1;

            //   handleSearch();
            //   $('.local-search-result-cls ul li').velocity('stop').velocity('transition.slideDownIn', 800);
            // }, 2000);
            
            // is_load_xml_finished = 1;

            handleSearch();
            $('.local-search-result-cls ul li').velocity('stop').velocity('transition.slideDownIn', 800);
          }
        });
      }

      $(document).on('click', '#local-search-close', function() {
        CloseLocalSearch();
      });

      $(document).keyup(function(event){
        switch(event.keyCode) {
          case 27:
            // alert("ESC");
            CloseLocalSearch();
        }
      });

      // $(document).on('blur', '#local-search-input', function(e) {
      //   // console.log(document.activeElement.getAttribute('class'));
        
      //   if (isMobile() == false)
      //   {
      //     CloseLocalSearch();
      //   }
      // });
    }

    function isMobile() {
      // console.log(document.body.clientWidth);
      return document.body.clientWidth < 768

      // var userAgent = window.navigator.userAgent;

      // var isiPad = userAgent.match(/iPad/i) !== null;
      // var mobileUA = [
      //   'iphone', 'android', 'phone', 'mobile',
      //   'wap', 'netfront', 'x11', 'java', 'opera mobi',
      //   'opera mini', 'ucweb', 'windows ce', 'symbian',
      //   'symbianos', 'series', 'webos', 'sony',
      //   'blackberry', 'dopod', 'nokia', 'samsung',
      //   'palmsource', 'xda', 'pieplus', 'meizu',
      //   'midp' ,'cldc' , 'motorola', 'foma',
      //   'docomo', 'up.browser', 'up.link', 'blazer',
      //   'helio', 'hosin', 'huawei', 'novarra',
      //   'coolpad', 'webos', 'techfaith', 'palmsource',
      //   'alcatel', 'amoi', 'ktouch', 'nexian',
      //   'ericsson', 'philips', 'sagem', 'wellcom',
      //   'bunjalloo', 'maui', 'smartphone', 'iemobile',
      //   'spice', 'bird', 'zte-', 'longcos',
      //   'pantech', 'gionee', 'portalmmm', 'jig browser',
      //   'hiptop', 'benq', 'haier', '^lct',
      //   '320x320', '240x320', '176x220'
      // ];
      // var pattern = new RegExp(mobileUA.join('|'), 'i');

      // return !isiPad && userAgent.match(pattern);
    }

    function store_search_xml(xmlResponse) {
        datas = $("entry", xmlResponse).map(function () {
          return {
            title: $("title", this).text(),
            content: $("content", this).text(),
            url: $("url", this).text(),
            encrypted: $("encrypted", this).text(),
          };
        }).get();
        // Put the object into storage
        localStorage.setItem('local_search_xml_data', JSON.stringify(datas));
        is_load_xml_finished = 1;

        console.log("store search.xml finished.");
    }

    function ajax_store_search_xml() {
      $.ajax({
        url: "/search.xml",
        dataType: "xml",
        success: function (xmlResponse) {
            store_search_xml(xmlResponse);
        }
      });
    }

    function retrieve_search_xml() {
        // Retrieve the object from local storage
        var retrievedObject = localStorage.getItem('local_search_xml_data');
        var xml_resp = JSON.parse(retrievedObject)
        return xml_resp
    }

    var getSearchFile = function(){
      var path = "/search.xml";
      var local_search_result_name = isMobile() ? "local-search-result-mobile" : "local-search-result-pc";
      searchFunc(path, 'local-search-input', local_search_result_name);
    }

    var local_search_xml_data = localStorage.getItem('local_search_xml_data');
    if (local_search_xml_data) {
      is_load_xml_finished = 1;
      console.log("load search.xml finished.");
    }
    var last_use_local_search_date = localStorage.getItem('last_use_local_search_date');
    var curDate = new Date();
    // 只有在 localStorage 没有 search.xml数据或者 距离上次使用local search已经超过一天了才去取search.xml
    // 节省流量
    if (last_use_local_search_date != curDate.getDate() || !local_search_xml_data) {
      // preload search.xml
      ajax_store_search_xml();
    }

    localStorage.setItem('last_use_local_search_date', curDate.getDate());
    

  </script>





  

  

  

  

  

  


  <script type="text/javascript" src="/lib/wobble_window/wobblewindow.js"> </script>
<script type="text/javascript" src="/js/src/custom.js"></script>
</body>
</html>


<!-- 页面点击小红心 -->





<script type="text/javascript" src="/js/src/headroom.js"></script> 

<!-- 代码块复制功能 -->
<script type="text/javascript" src="/js/src/clipboard-use.js"></script>
