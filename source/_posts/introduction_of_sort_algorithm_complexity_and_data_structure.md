---
title: 排序算法一之谈一谈各类算法的复杂度和常用数据结构
date: 2014-08-19 17:38:55
tags:
- 排序
- c++
categories:
- c++
---

因为之前的笔记和书籍相关知识都是零零散散的， 没有一个汇总， 所以写了这篇博客。有些算法很简单，复杂度一眼都能看得出来， 几乎不需要记忆 ， 但是有些算法或者数据结构的操作的复杂度就不是一眼可以看得出来， 推导也是很费时间的， 所谓常识就是应该熟记于心且被认可的知识。




# 必须掌握的知识

- 数据结构
    - 链表
    - 二叉树
    - 栈
    - 队列
    - 散列表
- 算法
    - 二分查找
    - 快速排序
    - 归并排序
    - 堆排序
    - 插入排序
    - 树的插入/查找/删除
    - 广度优先搜索
    - 深度优先搜索

# 该注意的点

- 实用的排序算法有四种：插入、快速、归并、堆。其余的都不值得深究。这几个排序算法都有其特点，涵盖了常见的使用场景，在其特定的使用场景下是效率最高的。
    - **插入排序** : 在小数据量比起归并和快速排序有更佳的时间效率
    - **快速排序** : 时间复杂度依赖数据打乱的程度
        - 快排最差情形的时间复杂度是O(n2), 平均是O(nlogn)
        - 就地快速排序使用的空间是O(1)的，也就是个常数级；而真正消耗空间的就是递归调用了，因为每次递归就要保持一些数据；
            - 最优的情况下空间复杂度为：O(logn) ；每一次都平分数组的情况
            - 最差的情况下空间复杂度为：O( n ) ；退化为冒泡排序的情况
    - **归并排序** : 时间复杂度稳定但是占用2N的内存
        - 归并的空间复杂度就是那个临时的数组和递归时压入栈的数据占用的空间：n + logn；所以空间复杂度为: O(n)
        - 还有一种空间复杂度为O(1)的归并排序的实现
    - **堆排序** : 在不能一次排序N个数据并要求选出前M个数据时使用。
- 插入排序、堆排序、快速排序等都是**原址**排序。归并排序是**非原址**的。
- 插入排序、归并排序是**稳定**的, 堆排序、快速排序是**不稳定**的。

# 为什么在平均情况下快速排序比堆排序要优秀

堆排序是渐进最优的比较排序算法，达到了O(nlgn)这一下界，而快排有一定的可能性会产生最坏划分，时间复杂度可能为O(n^2)，那为什么快排在实际使用中通常优于堆排序？

- 虽然quick_sort会n^2（其实有稳定的nlgn的版本），但这毕竟很少出现。heap_sort大多数情况下比较次数都多于quick_sort，尽管大家都是nlgn。那就让倒霉蛋倒霉好了，大多数情况下快才是硬道理。
- 堆排比较的几乎都不是相邻元素，对cache极不友好，这才是很少被采用的原因。数学上的时间复杂度不代表实际运行时的情况.快排是分而治之，每次都在同一小段进行比较，最后越来约接近局部性。反观堆排，每次都是从堆地拿元素来替换，局部性破坏很严重。(局部性原理是指CPU访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。)

<!-- more -->

# 各类算法的复杂度汇总表

{% asset_img 各类算法的复杂度.png 各类算法的复杂度汇总表 %}

